// Code generated by ogen, DO NOT EDIT.

package zoomphone

import (
	"context"
	"net/url"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.19.0"
	"go.opentelemetry.io/otel/trace"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
)

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// AccountCallHistory invokes accountCallHistory operation.
	//
	// Returns an account's new edition [call logs](https://support.zoom.
	// us/hc/en-us/articles/360021114452-Viewing-Call-Logs).
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// * Account owner or a [role](https://support.zoom.
	// us/hc/en-us/articles/115001078646-Role-Based-Access-Control) with Zoom Phone management
	// **Scopes:** `phone:read:admin`,`phone_call_log:read:admin`
	// **Granular Scopes:** `phone:read:list_call_logs:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `HEAVY`.
	//
	// GET /phone/call_history
	AccountCallHistory(ctx context.Context, params AccountCallHistoryParams) (*AccountCallHistoryOK, error)
	// AccountCallLogs invokes accountCallLogs operation.
	//
	// Returns an account's [call logs](https://support.zoom.
	// us/hc/en-us/articles/360021114452-Viewing-Call-Logs).
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// * Account owner or a [role](https://support.zoom.
	// us/hc/en-us/articles/115001078646-Role-Based-Access-Control) with Zoom Phone management
	// **Scopes:** `phone:read:admin`,`phone_call_log:read:admin`
	// **Granular Scopes:** `phone:read:list_call_logs:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `HEAVY`.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /phone/call_logs
	AccountCallLogs(ctx context.Context, params AccountCallLogsParams) (*AccountCallLogsOK, error)
	// AccountSmsSession invokes accountSmsSession operation.
	//
	// Returns details about SMS sessions for an account.
	// **Prerequisites**
	// * Paid account
	// * User-enabled Zoom phone
	// **Scopes:** `phone:read:admin`,`phone_sms:read:admin`,`phone_sms:read`
	// **Granular Scopes:** `phone:read:list_sms_sessions`,`phone:read:list_sms_sessions:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// GET /phone/sms/sessions
	AccountSmsSession(ctx context.Context, params AccountSmsSessionParams) (*AccountSmsSessionOK, error)
	// AccountVoiceMails invokes accountVoiceMails operation.
	//
	// Use this API to get a user's Zoom Phone voicemails.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`,`phone_voicemail:read:admin`
	// **Granular Scopes:** `phone:read:list_voicemails:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Heavy`.
	//
	// GET /phone/voice_mails
	AccountVoiceMails(ctx context.Context, params AccountVoiceMailsParams) (*AccountVoiceMailsOK, error)
	// ActiveCRPhoneNumbers invokes activeCRPhoneNumbers operation.
	//
	// Use this API to change phone number status to 'active' in a carrier reseller's master account. Up
	// to 200 numbers at a time.
	// **Prerequisites:**
	// * A Pro or higher account plan
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:carrier_number:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// PATCH /phone/carrier_reseller/numbers
	ActiveCRPhoneNumbers(ctx context.Context, request []string) error
	// AddAccountLevelInboundBlockRules invokes AddAccountLevelInboundBlockRules operation.
	//
	// Adds an account level block rule for inbound calls and messaging from a phone number. As a result,
	// all extensions block calls and messages to the phone number.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:inbound_block_rule:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// POST /phone/inbound_blocked/rules
	AddAccountLevelInboundBlockRules(ctx context.Context, request OptAddAccountLevelInboundBlockRulesReq) (*AddAccountLevelInboundBlockRulesCreated, error)
	// AddAccountOutboundCallingExceptionRule invokes AddAccountOutboundCallingExceptionRule operation.
	//
	// Adds the account level outbound calling policy exception rule for country region.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:outbound_calling_rule:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// POST /phone/outbound_calling/exception_rules
	AddAccountOutboundCallingExceptionRule(ctx context.Context, request OptAddAccountOutboundCallingExceptionRuleReq) (*AddAccountOutboundCallingExceptionRuleCreated, error)
	// AddAnAlertSetting invokes AddAnAlertSetting operation.
	//
	// [Adds an alert setting](https://support.zoom.us/hc/en-us/articles/7146944434445).
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:alert_setting:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// POST /phone/alert_settings
	AddAnAlertSetting(ctx context.Context, request OptAddAnAlertSettingReq) (*AddAnAlertSettingCreated, error)
	// AddAnAudio invokes AddAnAudio operation.
	//
	// Adds an audio item for [text-to-speech conversion](https://support.zoom.
	// us/hc/en-us/articles/4402414203533-Using-the-audio-library-to-customize-audio#h_01F8B0D2ZJBKEDH10DFZ7J2CM7). Only the admin or user can add your audio and directly pass the `me` value instead of the `userId` parameter.
	// **Prerequisites:**
	// * Business or Education account
	// * Zoom Phone license
	// **Scopes:** `phone:write`,`phone:write:admin`
	// **Granular Scopes:** `phone:write:audio`,`phone:write:audio:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// POST /phone/users/{userId}/audios
	AddAnAudio(ctx context.Context, request OptAddAnAudioReq, params AddAnAudioParams) (*AddAnAudioCreated, error)
	// AddAnumberToBlockedList invokes addAnumberToBlockedList operation.
	//
	// A Zoom account owner or a user with the admin privilege can block phone numbers for phone users in
	// an account. Blocked numbers can be inbound (numbers will be blocked from calling in) and outbound
	// (phone users in your account won't be able to dial those numbers). Blocked callers will hear a
	// generic message stating that the person they are calling is not available. Use this API to create
	// a block list and add a number to the list.
	// **Prerequisites:**
	// * Pro or higher account plan with Zoom phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:blocked_list:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/blocked_list
	AddAnumberToBlockedList(ctx context.Context, request OptAddAnumberToBlockedListReq) (*AddAnumberToBlockedListCreated, error)
	// AddAudioItem invokes AddAudioItem operation.
	//
	// Adds the audio items. You can only upload voice files at this time. Only the admin or user can add
	// your audio and directly pass the `me` value instead of the `userId` parameter.
	// **Prerequisites:**
	// * Business or Education account
	// * Zoom Phone license
	// **Size and quantity limits for audio attachments:**
	// * Up to 5 attachments
	// * Each file size should be no more than 1MB
	// **Scopes:** `phone:write`,`phone:write:admin`
	// **Granular Scopes:** `phone:write:batch_audios`,`phone:write:batch_audios:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `HEAVY`.
	//
	// POST /phone/users/{userId}/audios/batch
	AddAudioItem(ctx context.Context, request OptAddAudioItemReq, params AddAudioItemParams) (*AddAudioItemCreated, error)
	// AddAutoReceptionist invokes addAutoReceptionist operation.
	//
	// Adds an [auto receptionist](https://support.zoom.
	// us/hc/en-us/articles/360021121312-Managing-Auto-Receptionists-and-Interactive-Voice-Response-IVR-)
	// to a Zoom Phone. Auto receptionists answer calls with a personalized recording and routes calls to
	// a phone user, call queue, common area, voicemail or an IVR system.
	// **Prerequisites:**
	// * Pro or higher account with Zoom Phone license.
	// * Account owner or admin privileges
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:auto_receptionist:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/auto_receptionists
	AddAutoReceptionist(ctx context.Context, request OptAddAutoReceptionistReq) (*AddAutoReceptionistCreated, error)
	// AddBYOCNumber invokes addBYOCNumber operation.
	//
	// Use this API to add BYOC (Bring Your Own Carrier) phone numbers to Zoom Phone.
	// **Prerequisites:**
	// * A Business or Enterprise plan
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:byo_carrier_number:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/byoc_numbers
	AddBYOCNumber(ctx context.Context, request OptAddBYOCNumberReq) (*AddBYOCNumberCreated, error)
	// AddCQPolicySubSetting invokes addCQPolicySubSetting operation.
	//
	// Use this API to add the policy sub-setting for a specific [call queue](https://support.zoom.
	// us/hc/en-us/articles/360021524831) according to the `policyType`. For example, you can use this
	// API to set up shared access members.
	// **Prerequisites:**
	// * Pro or higher account with Zoom Phone license.
	// * Account owner or admin privileges
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:call_queue_policy:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/call_queues/{callQueueId}/policies/{policyType}
	AddCQPolicySubSetting(ctx context.Context, request OptAddCQPolicySubSettingReq, params AddCQPolicySubSettingParams) (*AddCQPolicySubSettingCreated, error)
	// AddCallHandling invokes addCallHandling operation.
	//
	// Adds Zoom Phone call handling subsettings for your phone system. Call handling settings allow you
	// to control how your system routes calls during business, closed, or holiday hours. For more
	// information, see our [API guide](https://marketplace.zoom.
	// us/docs/guides/zoom-phone/call-handling/) or Zoom support article [Customizing call handling
	// settings](https://support.zoom.
	// us/hc/en-us/articles/360059966372-Customizing-call-handling-settings).
	// **Applicable to user, call queue, auto receptionist, or shared line group call handling at this
	// time.**
	// **Prerequisites:**
	// * A Pro or a higher account with Zoom Phone enabled
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:call_handling_setting:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// POST /phone/extension/{extensionId}/call_handling/settings/{settingType}
	AddCallHandling(ctx context.Context, request OptAddCallHandlingReq, params AddCallHandlingParams) (AddCallHandlingCreated, error)
	// AddClientCodeToCallLog invokes addClientCodeToCallLog operation.
	//
	// Adds a client code to a [call log](https://support.zoom.
	// us/hc/en-us/articles/360040999352-Assigning-client-codes-to-phone-calls). You can track call logs
	// with a client code.
	// **Prerequisites:**
	// * Business, or Education account
	// * Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:call_log:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// PUT /phone/call_logs/{callLogId}/client_code
	AddClientCodeToCallLog(ctx context.Context, request OptAddClientCodeToCallLogReq, params AddClientCodeToCallLogParams) error
	// AddCommonArea invokes addCommonArea operation.
	//
	// Use this API to add an instance of common area. Configure devices shared by users and deployed in
	// shared spaces.
	// **Note**: For use by customers who opted for `Common Area Optimization`
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:common_area:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/common_areas
	AddCommonArea(ctx context.Context, request OptAddCommonAreaReq) (*AddCommonAreaCreated, error)
	// AddCommonAreaOutboundCallingExceptionRule invokes AddCommonAreaOutboundCallingExceptionRule operation.
	//
	// Adds the common area level outbound calling policy exception rule for the country region.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:common_area_outbound_calling_rule:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// POST /phone/common_areas/{commonAreaId}/outbound_calling/exception_rules
	AddCommonAreaOutboundCallingExceptionRule(ctx context.Context, request OptAddCommonAreaOutboundCallingExceptionRuleReq, params AddCommonAreaOutboundCallingExceptionRuleParams) (*AddCommonAreaOutboundCallingExceptionRuleCreated, error)
	// AddCommonAreaSetting invokes AddCommonAreaSetting operation.
	//
	// Use this API to add the common area setting according to the setting type, specifically for desk
	// phones.
	// **Note**: For use by customers who opted for `Common Area Optimization`
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license.
	// * Account owner or admin permissions.
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:common_area_setting:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/common_areas/{commonAreaId}/settings/{settingType}
	AddCommonAreaSetting(ctx context.Context, request OptAddCommonAreaSettingReq, params AddCommonAreaSettingParams) (*AddCommonAreaSettingCreated, error)
	// AddEmergencyAddress invokes addEmergencyAddress operation.
	//
	// Adds an emergency address. If the address provided is not an exact match, the system generated
	// corrected address will be used.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:emergency_address:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/emergency_addresses
	AddEmergencyAddress(ctx context.Context, request OptAddEmergencyAddressReq) (*AddEmergencyAddressCreated, error)
	// AddExtensionsToADevice invokes addExtensionsToADevice operation.
	//
	// By default, all Zoom Phone users can make and receive calls using the Zoom desktop and mobile
	// applications. Additionally, if a desk phone is required, use this API to [add a desk phone and
	// assign it to a user](https://support.zoom.
	// us/hc/en-us/articles/360021119092#h_5ca07504-68a8-4c3d-ad0e-c1d3594436da).
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// * [Supported device](https://support.zoom.
	// us/hc/en-us/articles/360001299063-Zoom-Voice-Supported-Devices)
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:device_extension:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/devices/{deviceId}/extensions
	AddExtensionsToADevice(ctx context.Context, request OptAddExtensionsToADeviceReq, params AddExtensionsToADeviceParams) (jx.Raw, error)
	// AddExtensiontLevelInboundBlockRules invokes AddExtensiontLevelInboundBlockRules operation.
	//
	// Adds the given extension's block rule for inbound calls and messaging.
	// It adds the inbound block rule for the given Call Queue, Auto Receptionist, Shared Line Group,
	// Common Area, Zoom Room or User.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// **Scopes:** `phone:write:admin`,`phone:write`
	// **Granular Scopes:** `phone:write:extension_inbound_block_rule:admin`,
	// `phone:write:extension_inbound_block_rule`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// POST /phone/extension/{extensionId}/inbound_blocked/rules
	AddExtensiontLevelInboundBlockRules(ctx context.Context, request OptAddExtensiontLevelInboundBlockRulesReq, params AddExtensiontLevelInboundBlockRulesParams) (*AddExtensiontLevelInboundBlockRulesCreated, error)
	// AddExternalContact invokes addExternalContact operation.
	//
	// Adds an external contact.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:external_contact:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/external_contacts
	AddExternalContact(ctx context.Context, request OptAddExternalContactReq) (*AddExternalContactCreated, error)
	// AddFirmwareRule invokes AddFirmwareRule operation.
	//
	// Use this API to add a [firmware update rule](https://support.zoom.
	// us/hc/en-us/articles/360054198852-Setting-up-firmware-update-rules).
	// **Prerequisites:**
	// * Business, or Education account
	// * Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:firmware_update_rule:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/firmware_update_rules
	AddFirmwareRule(ctx context.Context, request OptAddFirmwareRuleReq) (*AddFirmwareRuleCreated, error)
	// AddGCP invokes addGCP operation.
	//
	// Use this API to add a [Group Call Pickup](https://support.zoom.
	// us/hc/en-us/articles/360060107472-Setting-up-and-using-group-call-pickup) instance to the account
	// that has the Zoom Phone license assigned.
	// **Prerequisites:**
	// * A Pro or higher account plan
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:call_pickup_group:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/group_call_pickup
	AddGCP(ctx context.Context, request OptAddGCPReq) (*AddGCPCreated, error)
	// AddGCPMembers invokes addGCPMembers operation.
	//
	// Use this API to add members to the specified [Group Call Pickup](https://support.zoom.
	// us/hc/en-us/articles/360060107472-Setting-up-and-using-group-call-pickup) object.
	// **Prerequisites:**
	// * A Pro or higher account plan
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:call_pickup_group_member:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/group_call_pickup/{groupId}/members
	AddGCPMembers(ctx context.Context, request OptAddGCPMembersReq, params AddGCPMembersParams) error
	// AddLocation invokes addLocation operation.
	//
	// Adds an emergency service location.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:emergency_location:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/locations
	AddLocation(ctx context.Context, request OptAddLocationReq) (*AddLocationCreated, error)
	// AddMembers invokes addMembers operation.
	//
	// Use this API to add members to a [Monitoring Group](https://support.zoom.
	// us/hc/en-us/articles/360044804711).
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:monitoring_group_member:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/monitoring_groups/{monitoringGroupId}/monitor_members
	AddMembers(ctx context.Context, request []string, params AddMembersParams) (jx.Raw, error)
	// AddMembersToCallQueue invokes addMembersToCallQueue operation.
	//
	// Add phone users and/or [common areas](https://support.zoom.us/hc/articles/4481136653709) as
	// members to a specific call queue.
	// **Prerequisites:**
	// * Pro or higher account plan.
	// * Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:call_queue_member:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/call_queues/{callQueueId}/members
	AddMembersToCallQueue(ctx context.Context, request OptAddMembersToCallQueueReq, params AddMembersToCallQueueParams) error
	// AddMembersToSharedLineGroup invokes addMembersToSharedLineGroup operation.
	//
	// [Adds members](https://support.zoom.
	// us/hc/en-us/articles/360038850792-Setting-up-shared-line-groups#h_7cb42370-48f6-4a8f-84f4-c6eee4d9f0ca) to a shared line group. A [shared line group](https://support.zoom.us/hc/en-us/articles/360038850792) allows Zoom Phone admins to share a phone number and extension with a group of phone users or common areas. This gives members of the shared line group access to the group's direct phone number and voicemail.  Note that a member can only be added to one shared line group.
	// **Prerequisites:**
	// * Pro or higher account with Zoom Phone license.
	// * A valid Shared Line Group
	// * Account owner or admin privileges
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:shared_line_member:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// POST /phone/shared_line_groups/{sharedLineGroupId}/members
	AddMembersToSharedLineGroup(ctx context.Context, request OptAddMembersToSharedLineGroupReq, params AddMembersToSharedLineGroupParams) error
	// AddOutboundCallerNumbers invokes addOutboundCallerNumbers operation.
	//
	// Adds the `account-level` customized outbound caller ID phone numbers. Note that when multiple
	// sites policy is enabled, users cannot manage the `account-level` configuration. The system will
	// throw an exception.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license.
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:customized_number:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/outbound_caller_id/customized_numbers
	AddOutboundCallerNumbers(ctx context.Context, request OptAddOutboundCallerNumbersReq) (jx.Raw, error)
	// AddPeeringPhoneNumbers invokes addPeeringPhoneNumbers operation.
	//
	// Adds phone numbers to Zoom through the Provider Exchange.
	// **Note**: Phone peering API and events are for partners who have completed the MoU to peer with
	// Zoom. To become a peering provider/ carrier, submit your [request](https://docs.google.
	// com/forms/d/e/1FAIpQLSewkY6ixVyKVNkWC-vgmejC16gigxsJWXji3dWzE3XlWtjsgg/viewform).
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`,`phone_peering:write:admin`
	// **Granular Scopes:** `phone:write:peering_number:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/peering/numbers
	AddPeeringPhoneNumbers(ctx context.Context, request OptAddPeeringPhoneNumbersReq) (*AddPeeringPhoneNumbersCreated, error)
	// AddPhoneDevice invokes addPhoneDevice operation.
	//
	// [Adda a desk phone and assigns it](https://support.zoom.
	// us/hc/en-us/articles/360021119092#h_5ca07504-68a8-4c3d-ad0e-c1d3594436da) to a user, if a desk
	// phone is required.
	// By default, all Zoom Phone users can make and receive calls using the Zoom desktop and mobile
	// applications.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// * [Supported device](https://support.zoom.
	// us/hc/en-us/articles/360001299063-Zoom-Voice-Supported-Devices)
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:device:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// POST /phone/devices
	AddPhoneDevice(ctx context.Context, request OptAddPhoneDeviceReq) (*AddPhoneDeviceCreated, error)
	// AddPolicy invokes AddPolicy operation.
	//
	// Adds a policy subsetting for a specific [auto receptionist](https://support.zoom.
	// us/hc/en-us/articles/360021121312-Managing-Auto-Receptionists-and-Interactive-Voice-Response-IVR-)
	// according to the `policyType`. For example, you can use this API to set up shared access members.
	// <br><br>**Prerequisites:**
	// * Pro or higher account plan with Zoom Phone License
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:auto_receptionist_policy:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// POST /phone/auto_receptionists/{autoReceptionistId}/policies/{policyType}
	AddPolicy(ctx context.Context, request OptAddPolicyReq, params AddPolicyParams) (*AddPolicyCreated, error)
	// AddProvisionTemplate invokes addProvisionTemplate operation.
	//
	// Use this API to [create a provision template](https://support.zoom.
	// us/hc/en-us/articles/360035817952#h_8266cb40-58fc-4c1a-8da2-885d72167234) in a Zoom account.
	// **Prerequisites:**
	// * A Pro or higher account plan
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:provision_template:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/provision_templates
	AddProvisionTemplate(ctx context.Context, request OptAddProvisionTemplateReq) (*AddProvisionTemplateCreated, error)
	// AddRoleMembers invokes AddRoleMembers operation.
	//
	// Use this API to add members to [roles](https://support.zoom.
	// us/hc/en-us/articles/360042099012-Using-Zoom-Phone-role-management#h_01EFHY1R4QWAYTA6Z661NM9Q27).
	// **Prerequisites:**
	// * Business or Education account
	// * Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:role_member:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/roles/{roleId}/members
	AddRoleMembers(ctx context.Context, request OptAddRoleMembersReq, params AddRoleMembersParams) error
	// AddRoutingRule invokes addRoutingRule operation.
	//
	// Creates a directory backup routing rule.
	// The directory backup routing rules are a series of predefined regular expressions. These rules are
	// used to route outgoing calls. If a dialed number does not match a Zoom Phone user, and does not
	// match a defined external contact, these rules are tested next. If a dialed number does not match
	// any rules, the call will be routed through the PSTN.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:routing_rule:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/routing_rules
	AddRoutingRule(ctx context.Context, request OptAddRoutingRuleReq) (*AddRoutingRuleCreated, error)
	// AddSLGPolicySubSetting invokes addSLGPolicySubSetting operation.
	//
	// Adds the policy sub-setting for a specific [shared line group](https://support.zoom.
	// us/hc/en-us/articles/360038850792) according to the `policyType`. For example, you can use this
	// API to set up shared access members. **Prerequisites:** * Pro or higher account with Zoom Phone
	// license.* Account owner or admin privileges
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:shared_line_group_policy:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// POST /phone/shared_line_groups/{slgId}/policies/{policyType}
	AddSLGPolicySubSetting(ctx context.Context, request OptAddSLGPolicySubSettingReq, params AddSLGPolicySubSettingParams) (*AddSLGPolicySubSettingCreated, error)
	// AddSettingTemplate invokes addSettingTemplate operation.
	//
	// Creates a Zoom Phone setting template for an account. After creating a phone template, the defined
	// settings will become the default settings for an account.
	// **Prerequisites:**
	// * A Business or enterprise Zoom account
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:setting_template:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/setting_templates
	AddSettingTemplate(ctx context.Context, request OptAddSettingTemplateReq) (*AddSettingTemplateCreated, error)
	// AddSiteOutboundCallerNumbers invokes addSiteOutboundCallerNumbers operation.
	//
	// Use this API to add the `site-level` customized outbound caller ID phone numbers.
	// * Multiple sites must be [enabled](https://support.zoom.
	// us/hc/en-us/articles/360020809672-Managing-Multiple-Sites#h_05c88e35-1593-491f-b1a8-b7139a75dc15).
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license.
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:site_customized_number:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/sites/{siteId}/outbound_caller_id/customized_numbers
	AddSiteOutboundCallerNumbers(ctx context.Context, request OptAddSiteOutboundCallerNumbersReq, params AddSiteOutboundCallerNumbersParams) (jx.Raw, error)
	// AddSiteOutboundCallingExceptionRule invokes AddSiteOutboundCallingExceptionRule operation.
	//
	// Adds the site level outbound calling policy exception rule for the country region.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:site_outbound_calling_rule:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// POST /phone/sites/{siteId}/outbound_calling/exception_rules
	AddSiteOutboundCallingExceptionRule(ctx context.Context, request OptAddSiteOutboundCallingExceptionRuleReq, params AddSiteOutboundCallingExceptionRuleParams) (*AddSiteOutboundCallingExceptionRuleCreated, error)
	// AddSiteSetting invokes addSiteSetting operation.
	//
	// Sites allow you to organize Zoom Phone users in your organization. Use this API to add a site
	// setting to a specific [site](https://support.zoom.us/hc/en-us/articles/360020809672) according to
	// the setting type.
	// **Prerequisites:**
	// * Account must have a Pro or a higher plan with Zoom Phone license.
	// * Multiple sites must be [enabled](https://support.zoom.
	// us/hc/en-us/articles/360020809672-Managing-Multiple-Sites#h_05c88e35-1593-491f-b1a8-b7139a75dc15).
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:site_setting:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/sites/{siteId}/settings/{settingType}
	AddSiteSetting(ctx context.Context, request OptAddSiteSettingReq, params AddSiteSettingParams) (*AddSiteSettingCreated, error)
	// AddUserOutboundCallerNumbers invokes addUserOutboundCallerNumbers operation.
	//
	// Adds users' customized outbound caller ID phone numbers.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license.
	// **Scopes:** `phone:write:admin`,`phone:write`
	// **Granular Scopes:** `phone:write:user_customized_number`,
	// `phone:write:user_customized_number:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/users/{userId}/outbound_caller_id/customized_numbers
	AddUserOutboundCallerNumbers(ctx context.Context, request OptAddUserOutboundCallerNumbersReq, params AddUserOutboundCallerNumbersParams) (jx.Raw, error)
	// AddUserOutboundCallingExceptionRule invokes AddUserOutboundCallingExceptionRule operation.
	//
	// Adds an user level outbound calling policy exception rule for the country region.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:user_outbound_calling_rule:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// POST /phone/users/{userId}/outbound_calling/exception_rules
	AddUserOutboundCallingExceptionRule(ctx context.Context, request OptAddUserOutboundCallingExceptionRuleReq, params AddUserOutboundCallingExceptionRuleParams) (*AddUserOutboundCallingExceptionRuleCreated, error)
	// AddUserSetting invokes addUserSetting operation.
	//
	// Adds the user setting according to the setting type, specifically for delegation, intercom and
	// shared access for voicemail, and call recordings. For user-level apps, pass [the `me`
	// value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the
	// `userId` parameter.
	// To see the shared access settings in the Zoom web portal, go to **Admin &gt; Phone System
	// Management &gt; Users &amp; Rooms** . Click **Users** and select **User Policy**. Go to
	// **Voicemail, Automatic Call Recording and Ad Hoc Call Recording**.
	// To view the delegation and intercom setting in your Zoom web portal, navigate to **Admin &gt;
	// Phone System Management &gt; Users &amp; Rooms**. Click the **Users** tab and select **User
	// Settings**
	// **Prerequisites:**
	// * A Business or Enterprise account
	// **Scopes:** `phone:write:admin`,`phone:write`
	// **Granular Scopes:** `phone:write:shared_setting`,`phone:write:shared_setting:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/users/{userId}/settings/{settingType}
	AddUserSetting(ctx context.Context, request OptAddUserSettingReq, params AddUserSettingParams) (*AddUserSettingCreated, error)
	// AddUsersToDirectory invokes AddUsersToDirectory operation.
	//
	// Use this API to add users to a [directory](https://support.zoom.
	// us/hc/en-us/articles/4404938949389-Using-a-dial-by-name-directory).
	// **Prerequisites:**
	// * Business or Education account
	// * Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:directory:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/dial_by_name_directory/extensions
	AddUsersToDirectory(ctx context.Context, request OptAddUsersToDirectoryReq) error
	// AddUsersToDirectoryBySite invokes AddUsersToDirectoryBySite operation.
	//
	// Use this API to add users to a [directory](https://support.zoom.
	// us/hc/en-us/articles/4404938949389-Using-a-dial-by-name-directory) of the specified site.
	// **Prerequisites:**
	// * Business or Education account
	// * Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:directory:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/sites/{siteId}/dial_by_name_directory/extensions
	AddUsersToDirectoryBySite(ctx context.Context, request OptAddUsersToDirectoryBySiteReq, params AddUsersToDirectoryBySiteParams) error
	// AddZoomRoom invokes addZoomRoom operation.
	//
	// Use this API to associate a [Zoom Room](https://support.zoom.
	// us/hc/en-us/articles/360025153711#h_70c74c57-50d6-406b-a4fa-2f33d4bebdbc) with a Zoom Phone
	// license.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:room:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/rooms
	AddZoomRoom(ctx context.Context, request OptAddZoomRoomReq) (jx.Raw, error)
	// AssignCallingPlan invokes assignCallingPlan operation.
	//
	// Assigns a [calling plan](https://marketplace.zoom.
	// us/docs/api-reference/other-references/plans#zoom-phone-calling-plans) to a [Zoom
	// Phone](https://support.zoom.us/hc/en-us/categories/360001370051-Zoom-Phone) user. For user-level
	// apps, pass [the `me` value](https://marketplace.zoom.
	// us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`,`phone:write`
	// **Granular Scopes:** `phone:write:calling_plan`,`phone:write:calling_plan:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/users/{userId}/calling_plans
	AssignCallingPlan(ctx context.Context, request OptAssignCallingPlanReq, params AssignCallingPlanParams) (jx.Raw, error)
	// AssignCallingPlanToRoom invokes assignCallingPlanToRoom operation.
	//
	// Use this API to assign [calling plans](https://marketplace.zoom.
	// us/docs/api-reference/other-references/plans#zoom-phone-calling-plans) to a [Zoom
	// Room](https://support.zoom.
	// us/hc/en-us/articles/360025153711#h_70c74c57-50d6-406b-a4fa-2f33d4bebdbc). Up to 200 numbers at a
	// time.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:room_calling_plan:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/rooms/{roomId}/calling_plans
	AssignCallingPlanToRoom(ctx context.Context, request OptAssignCallingPlanToRoomReq, params AssignCallingPlanToRoomParams) (jx.Raw, error)
	// AssignCallingPlansToCommonArea invokes assignCallingPlansToCommonArea operation.
	//
	// Use this API to assign calling plans to a common area.
	// **Note**: For use by customers who opted for `Common Area Optimization`
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license.
	// * Account owner or admin permissions.
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:common_area_calling_plan:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/common_areas/{commonAreaId}/calling_plans
	AssignCallingPlansToCommonArea(ctx context.Context, request OptAssignCallingPlansToCommonAreaReq, params AssignCallingPlansToCommonAreaParams) (*AssignCallingPlansToCommonAreaCreated, error)
	// AssignCampaignPhoneNumbers invokes assignCampaignPhoneNumbers operation.
	//
	// Use this API to [assign a phone number to the SMS campaign](https://support.zoom.
	// us/hc/en-us/articles/5016496738445-SMS-MMS-10DLC-Compliance-for-Zoom-Phone-and-Zoom-Contact-Center#h_01FYVVQM1WMW5JD48YNY3J581B).
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:sms_campaign_number:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/sms_campaigns/{smsCampaignId}/phone_numbers
	AssignCampaignPhoneNumbers(ctx context.Context, request OptAssignCampaignPhoneNumbersReq, params AssignCampaignPhoneNumbersParams) (*AssignCampaignPhoneNumbersCreated, error)
	// AssignPhoneNumber invokes assignPhoneNumber operation.
	//
	// Assigns a [phone number](https://support.zoom.
	// us/hc/en-us/articles/360020808292-Managing-Phone-Numbers) to a user who has already enabled Zoom
	// Phone.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:write`,`phone:write:admin`
	// **Granular Scopes:** `phone:write:user_number`,`phone:write:user_number:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/users/{userId}/phone_numbers
	AssignPhoneNumber(ctx context.Context, request OptAssignPhoneNumberReq, params AssignPhoneNumberParams) (*AssignPhoneNumberOK, error)
	// AssignPhoneNumberToZoomRoom invokes assignPhoneNumberToZoomRoom operation.
	//
	// Use this API to [assign phone numbers to a Zoom Room](https://support.zoom.
	// us/hc/en-us/articles/360025153711). Up to 200 numbers at a time.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:room_phone_number:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/rooms/{roomId}/phone_numbers
	AssignPhoneNumberToZoomRoom(ctx context.Context, request OptAssignPhoneNumberToZoomRoomReq, params AssignPhoneNumberToZoomRoomParams) (jx.Raw, error)
	// AssignPhoneNumbersAutoReceptionist invokes assignPhoneNumbersAutoReceptionist operation.
	//
	// Assigns available phone numbers to an [auto receptionist](https://support.zoom.
	// us/hc/en-us/articles/360021121312-Managing-Auto-Receptionists-and-Interactive-Voice-Response-IVR-).
	//  The available numbers can be retrieved using the List Phone Numbers API with `type` query
	// parameter set to &quot;unassigned&quot;.
	// **Prerequisites:**
	// * Pro or higher account plan with Zoom Phone License
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:auto_receptionist_number:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/auto_receptionists/{autoReceptionistId}/phone_numbers
	AssignPhoneNumbersAutoReceptionist(ctx context.Context, request OptAssignPhoneNumbersAutoReceptionistReq, params AssignPhoneNumbersAutoReceptionistParams) error
	// AssignPhoneNumbersSLG invokes assignPhoneNumbersSLG operation.
	//
	// Assigns phone numbers to a shared line groups. These direct phone numbers will be shared among
	// members of the [shared line group](https://support.zoom.
	// us/hc/en-us/articles/360038850792-Setting-up-shared-line-groups).
	// **Prerequisites:**
	// * Pro or higher account with Zoom Phone license.
	// * A valid Shared Line Group
	// * Account owner or admin privileges
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:shared_line_group_number:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/shared_line_groups/{sharedLineGroupId}/phone_numbers
	AssignPhoneNumbersSLG(ctx context.Context, request OptAssignPhoneNumbersSLGReq, params AssignPhoneNumbersSLGParams) error
	// AssignPhoneNumbersToCommonArea invokes assignPhoneNumbersToCommonArea operation.
	//
	// Assign phone numbers to a common area.
	// **Note**: For use by customers who opted for `Common Area Optimization`
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license.
	// * Account owner or admin permissions.
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:common_area_number:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/common_areas/{commonAreaId}/phone_numbers
	AssignPhoneNumbersToCommonArea(ctx context.Context, request OptAssignPhoneNumbersToCommonAreaReq, params AssignPhoneNumbersToCommonAreaParams) (*AssignPhoneNumbersToCommonAreaCreated, error)
	// AssignPhoneToCallQueue invokes assignPhoneToCallQueue operation.
	//
	// After [buying phone number(s)](https://support.zoom.
	// us/hc/en-us/articles/360020808292#h_007ec8c2-0914-4265-8351-96ab23efa3ad), you can assign it,
	// allowing callers to directly dial a number to reach a [call queue](https://support.zoom.
	// us/hc/en-us/articles/360021524831-Managing-Call-Queues).
	// **Prerequisites:**
	// * Pro or higher account plan.
	// * Account owner or admin permissions
	// * Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:call_queue_number:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/call_queues/{callQueueId}/phone_numbers
	AssignPhoneToCallQueue(ctx context.Context, request OptAssignPhoneToCallQueueReq, params AssignPhoneToCallQueueParams) error
	// BatchAddLocations invokes batchAddLocations operation.
	//
	// Batches the add emergency service locations.
	// **Prerequisites:**
	// * Pro or higher account plan with Zoom phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:batch_emergency_locations:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/batch_locations
	BatchAddLocations(ctx context.Context, request OptBatchAddLocationsReq) (*BatchAddLocationsCreated, error)
	// BatchAddUsers invokes batchAddUsers operation.
	//
	// Adds phone users in batch. You can add up to 10 users at a time.
	// **Prerequisites:**
	// * The users must be active in your [Zoom account](https://marketplace.zoom.
	// us/docs/api-reference/zoom-api/methods#tag/Users/operation/users).
	// * Pro or higher account plan with Zoom phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:batch_users:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// POST /phone/users/batch
	BatchAddUsers(ctx context.Context, request OptBatchAddUsersReq) ([]BatchAddUsersCreatedItem, error)
	// BatchUpdateDeviceLineKeySetting invokes batchUpdateDeviceLineKeySetting operation.
	//
	// Use this API to batch update the Zoom Phone device [line key position](https://support.zoom.
	// us/hc/en-us/articles/4402415568397-Customizing-keys-for-devices-with-multiple-users) information.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`,`phone:write`
	// **Granular Scopes:** `phone:update:device_line_keys`,`phone:update:device_line_keys:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Heavy`.
	//
	// PATCH /phone/devices/{deviceId}/line_keys
	BatchUpdateDeviceLineKeySetting(ctx context.Context, request OptBatchUpdateDeviceLineKeySettingReq, params BatchUpdateDeviceLineKeySettingParams) error
	// BatchUpdateLineKeySetting invokes BatchUpdateLineKeySetting operation.
	//
	// Use this API to batch update the Zoom Phone [line key settings](https://support.zoom.
	// us/hc/en-us/articles/360040587552) information.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`,`phone:write`
	// **Granular Scopes:** `phone:update:line_keys`,`phone:update:line_keys:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// PATCH /phone/extension/{extensionId}/line_keys
	BatchUpdateLineKeySetting(ctx context.Context, request OptBatchUpdateLineKeySettingReq, params BatchUpdateLineKeySettingParams) error
	// CreateASharedLineGroup invokes createASharedLineGroup operation.
	//
	// Creates a shared line group. A [shared line group](https://support.zoom.
	// us/hc/en-us/articles/360038850792) allows Zoom Phone admins to share a phone number and extension
	// with a group of phone users or common areas. This gives members of the shared line group access to
	// the group's direct phone number and voicemail. **Prerequisites:**    * Pro or higher account with
	// Zoom Phone license.* Account owner or admin privileges
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:shared_line_group:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// POST /phone/shared_line_groups
	CreateASharedLineGroup(ctx context.Context, request OptCreateASharedLineGroupReq) (*CreateASharedLineGroupCreated, error)
	// CreateCRPhoneNumbers invokes createCRPhoneNumbers operation.
	//
	// Use this API to add phone numbers to a carrier reseller (master) account. Up to 200 numbers at a
	// time. If this API is called in MA mode, it also has functions of distribution.
	// **Prerequisites:**
	// * A Pro or higher account plan
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:carrier_number:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/carrier_reseller/numbers
	CreateCRPhoneNumbers(ctx context.Context, request []CreateCRPhoneNumbersReqItem) error
	// CreateCallQueue invokes createCallQueue operation.
	//
	// [Creates a call queue](https://support.zoom.
	// us/hc/en-us/articles/360021524831-Managing-Call-Queues#h_e81faeeb-9184-429a-aaea-df49ff5ff413).
	// Call queues allow you to route incoming calls to a group of users. For instance, you can use call
	// queues to route calls to various departments in your organization such as sales, engineering,
	// billing, customer service, and so on.
	// You can add phone users or common areas to call queues.
	// **Prerequisites:**
	// * Pro, Business, or Education account
	// * Account owner or admin permissions
	// * Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:call_queue:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/call_queues
	CreateCallQueue(ctx context.Context, request OptCreateCallQueueReq) (*CreateCallQueueCreated, error)
	// CreateMonitoringGroup invokes createMonitoringGroup operation.
	//
	// Creates a [monitoring group](https://support.zoom.us/hc/en-us/articles/360044804711).
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:monitoring_group:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// POST /phone/monitoring_groups
	CreateMonitoringGroup(ctx context.Context, request OptCreateMonitoringGroupReq) (*CreateMonitoringGroupCreated, error)
	// CreatePhoneSite invokes createPhoneSite operation.
	//
	// Creates a [site](https://support.zoom.us/hc/en-us/articles/360020809672) that allows you to
	// organize the Zoom Phone users in your organization.
	// **Prerequisites:**
	// * Multiple sites must be [enabled](https://support.zoom.
	// us/hc/en-us/articles/360020809672-Managing-Multiple-Sites#h_05c88e35-1593-491f-b1a8-b7139a75dc15).
	// * Pro or a higher account with Zoom Phone enabled.
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:site:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// POST /phone/sites
	CreatePhoneSite(ctx context.Context, request OptCreatePhoneSiteReq) (*CreatePhoneSiteCreated, error)
	// DelRoleMembers invokes DelRoleMembers operation.
	//
	// Use this API to delete member(s) in a [role](https://support.zoom.
	// us/hc/en-us/articles/360042099012-Using-Zoom-Phone-role-management).
	// **Prerequisites:**
	// * Business or Education account
	// * Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:role_member:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/roles/{roleId}/members
	DelRoleMembers(ctx context.Context, params DelRoleMembersParams) error
	// DeleteABlockedList invokes deleteABlockedList operation.
	//
	// A Zoom account owner or a user with admin privilege can block phone numbers for phone users in an
	// account. Blocked numbers can be inbound (numbers will be blocked from calling in) and outbound
	// (phone users in your account won't be able to dial those numbers).
	// Use this API to delete a blocked list and therefore removing the associated number from the
	// blocked list. The number will be unblocked after the deletion.
	// **Prerequisites:**
	// * Pro or higher account plan with Zoom phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:blocked_list:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/blocked_list/{blockedListId}
	DeleteABlockedList(ctx context.Context, params DeleteABlockedListParams) error
	// DeleteACallQueue invokes deleteACallQueue operation.
	//
	// Call queues allow you to route incoming calls to a group of users. For instance, you can use call
	// queues to route calls to various departments in your organization such as sales, engineering,
	// billing, customer service etc.
	// Use this API to delete a Call Queue.
	// **Prerequisites:**
	// * Pro, Business, or Education account
	// * Account owner or admin permissions
	// * Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:call_queue:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/call_queues/{callQueueId}
	DeleteACallQueue(ctx context.Context, params DeleteACallQueueParams) error
	// DeleteADevice invokes deleteADevice operation.
	//
	// Remove a [desk phone device or ATA (Analog Telephone Adapter)](https://support.zoom.
	// us/hc/en-us/articles/360021119092) from the Zoom Phone System Management.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// * Device must not have been assigned to a user.
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:device:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/devices/{deviceId}
	DeleteADevice(ctx context.Context, params DeleteADeviceParams) error
	// DeleteAExternalContact invokes deleteAExternalContact operation.
	//
	// Removes an external contact.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:external_contact:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/external_contacts/{externalContactId}
	DeleteAExternalContact(ctx context.Context, params DeleteAExternalContactParams) error
	// DeleteAMemberSLG invokes deleteAMemberSLG operation.
	//
	// Unassigns **a specific member** from a shared line group. Members of the [shared line
	// group](https://support.zoom.us/hc/en-us/articles/360038850792) have access to the group's phone
	// number and voicemail.
	// **Prerequisites:**
	// * Pro or higher account with Zoom Phone license.
	// * A valid Shared Line Group
	// * Account owner or admin privileges
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:shared_line_member:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/shared_line_groups/{sharedLineGroupId}/members/{memberId}
	DeleteAMemberSLG(ctx context.Context, params DeleteAMemberSLGParams) error
	// DeleteAPhoneNumberSLG invokes deleteAPhoneNumberSLG operation.
	//
	// Unassigns a specific phone number that was assigned to the [shared line group](https://support.
	// zoom.us/hc/en-us/articles/360038850792-Setting-up-shared-line-groups).
	// **Prerequisites:**
	// * Pro or higher account with Zoom Phone license.
	// * A valid shared line group
	// * Account owner or admin privileges
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:shared_line_group_number:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// DELETE /phone/shared_line_groups/{sharedLineGroupId}/phone_numbers/{phoneNumberId}
	DeleteAPhoneNumberSLG(ctx context.Context, params DeleteAPhoneNumberSLGParams) error
	// DeleteASharedLineGroup invokes deleteASharedLineGroup operation.
	//
	// Deletes a shared line group. A [shared line group](https://support.zoom.
	// us/hc/en-us/articles/360038850792) allows Zoom Phone admins to share a phone number and extension
	// with a group of phone users or common areas.
	// **Prerequisites:**
	// * Pro or higher account with Zoom Phone license.
	// * Account owner or admin privileges
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:shared_line_group:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/shared_line_groups/{sharedLineGroupId}
	DeleteASharedLineGroup(ctx context.Context, params DeleteASharedLineGroupParams) error
	// DeleteAccountLevelInboundBlockRules invokes DeleteAccountLevelInboundBlockRules operation.
	//
	// Deletes the account level blocked rule for inbound calls and messaging.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:inbound_block_rule:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// DELETE /phone/inbound_blocked/rules
	DeleteAccountLevelInboundBlockRules(ctx context.Context, params DeleteAccountLevelInboundBlockRulesParams) error
	// DeleteAccountLevelInboundBlockedStatistics invokes DeleteAccountLevelInboundBlockedStatistics operation.
	//
	// Deletes the statistic of extensions blocked rule for inbound calls and messaging. (e.g. Call Queue,
	//  Auto Receptionist, Shared Line Group, Common Area, Zoom Room and User)
	// **Prerequisites:**
	// * Pro or higher account plan with Zoom phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:extension_inbound_block_rule_stat:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// DELETE /phone/inbound_blocked/extension_rules/statistics
	DeleteAccountLevelInboundBlockedStatistics(ctx context.Context, params DeleteAccountLevelInboundBlockedStatisticsParams) error
	// DeleteAccountOutboundCallingExceptionRule invokes deleteAccountOutboundCallingExceptionRule operation.
	//
	// Deletes the account level outbound calling exception rule.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:outbound_calling_rule:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// DELETE /phone/outbound_calling/exception_rules/{exceptionRuleId}
	DeleteAccountOutboundCallingExceptionRule(ctx context.Context, params DeleteAccountOutboundCallingExceptionRuleParams) error
	// DeleteAnAlertSetting invokes DeleteAnAlertSetting operation.
	//
	// Deletes an [alert setting](https://support.zoom.us/hc/en-us/articles/7146944434445).
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions.
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:alert_setting:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// DELETE /phone/alert_settings/{alertSettingId}
	DeleteAnAlertSetting(ctx context.Context, params DeleteAnAlertSettingParams) error
	// DeleteAudioItem invokes DeleteAudioItem operation.
	//
	// Deletes an audio item. Only the admin or user can delete your audio.
	// **Prerequisites:**
	// * Business, or Education account
	// * Zoom Phone license
	// **Scopes:** `phone:write`,`phone:write:admin`
	// **Granular Scopes:** `phone:delete:audio`,`phone:delete:audio:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// DELETE /phone/audios/{audioId}
	DeleteAudioItem(ctx context.Context, params DeleteAudioItemParams) error
	// DeleteAutoReceptionist invokes deleteAutoReceptionist operation.
	//
	// [Deletes a non-primary auto receptionist](https://support.zoom.
	// us/hc/en-us/articles/360021121312-Managing-Auto-Receptionists-and-Interactive-Voice-Response-IVR-#h_1d5ffc56-6ba3-4ce5-9d86-4a1a1ee743f3).
	// An auto receptionist answers calls with a personalized recording and routes calls to a phone user,
	// call queue, common area (phone), or to a voicemail. An auto receptionist can also be set up so
	// that it routes calls to an interactive voice response (IVR) system to allow callers to select the
	// routing options.
	// **Prerequisites:**
	// * Pro or higher account with Zoom Phone license.
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:auto_receptionist:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/auto_receptionists/{autoReceptionistId}
	DeleteAutoReceptionist(ctx context.Context, params DeleteAutoReceptionistParams) error
	// DeleteCRPhoneNumber invokes deleteCRPhoneNumber operation.
	//
	// Use this API to delete or unassign a phone number from a carrier reseller account.
	// **Prerequisites:**
	// * A Pro or higher account plan
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:carrier_number:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/carrier_reseller/numbers/{number}
	DeleteCRPhoneNumber(ctx context.Context, params DeleteCRPhoneNumberParams) error
	// DeleteCallHandling invokes deleteCallHandling operation.
	//
	// Deletes a Zoom Phone's call handling settings. Call handling settings let you control how your
	// system routes calls during business, closed, or holiday hours. For more information, read our [API
	// guide](https://marketplace.zoom.us/docs/guides/zoom-phone/call-handling/) or Zoom support article
	// [Customizing call handling settings](https://support.zoom.
	// us/hc/en-us/articles/360059966372-Customizing-call-handling-settings).
	// **Applicable to user, call queue, auto receptionist, or shared line group call handling at this
	// time.**
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone enabled
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:call_handling_setting:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// DELETE /phone/extension/{extensionId}/call_handling/settings/{settingType}
	DeleteCallHandling(ctx context.Context, params DeleteCallHandlingParams) error
	// DeleteCallLog invokes deleteCallLog operation.
	//
	// Deletes a user's [call log](https://support.zoom.
	// us/hc/en-us/articles/360021114452-Viewing-and-identifying-logs). For user-level apps, pass [the
	// `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of
	// the `userId` parameter.
	// **Prerequisites:**
	// * User must belong to a Business or Enterprise account
	// * User must have a Zoom Phone license
	// **Scopes:** `phone:write`,`phone:write:admin`,`phone_call_log:write`,`phone_call_log:write:admin`
	// **Granular Scopes:** `phone:delete:call_log`,`phone:delete:call_log:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/users/{userId}/call_logs/{callLogId}
	DeleteCallLog(ctx context.Context, params DeleteCallLogParams) error
	// DeleteCallRecording invokes deleteCallRecording operation.
	//
	// Deletes a call recording.
	// **Prerequisites:**
	// * User must belong to a Business or Enterprise account
	// * User must have a Zoom Phone license
	// **Scopes:** `phone:write:admin`,`phone:write`,`phone_recording:write`,`phone_recording:write:admin`
	// **Granular Scopes:** `phone:delete:call_recording`,`phone:delete:call_recording:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/recordings/{recordingId}
	DeleteCallRecording(ctx context.Context, params DeleteCallRecordingParams) error
	// DeleteCommonArea invokes deleteCommonArea operation.
	//
	// Use this API to remove the common area.
	// **Note**: For use by customers who opted for `Common Area Optimization`
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license.
	// * Account owner or admin permissions.
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:common_area:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/common_areas/{commonAreaId}
	DeleteCommonArea(ctx context.Context, params DeleteCommonAreaParams) error
	// DeleteCommonAreaOutboundCallingExceptionRule invokes deleteCommonAreaOutboundCallingExceptionRule operation.
	//
	// Deletes the common area level outbound calling exception rule.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:common_area_outbound_calling_rule:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// DELETE /phone/common_areas/{commonAreaId}/outbound_calling/exception_rules/{exceptionRuleId}
	DeleteCommonAreaOutboundCallingExceptionRule(ctx context.Context, params DeleteCommonAreaOutboundCallingExceptionRuleParams) error
	// DeleteCommonAreaSetting invokes deleteCommonAreaSetting operation.
	//
	// Use this API to remove the common area subsetting from desk phones.
	// **Note**: For use by customers who opted for `Common Area Optimization`
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license.
	// * Account owner or admin permissions.
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:common_area_setting:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/common_areas/{commonAreaId}/settings/{settingType}
	DeleteCommonAreaSetting(ctx context.Context, params DeleteCommonAreaSettingParams) error
	// DeleteEmergencyAddress invokes deleteEmergencyAddress operation.
	//
	// Removes an emergency address.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:emergency_address:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Heavy`.
	//
	// DELETE /phone/emergency_addresses/{emergencyAddressId}
	DeleteEmergencyAddress(ctx context.Context, params DeleteEmergencyAddressParams) error
	// DeleteExtensionFromADevice invokes deleteExtensionFromADevice operation.
	//
	// Use this API to unassign a specific assignee from the device.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions.
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:device_extension:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/devices/{deviceId}/extensions/{extensionId}
	DeleteExtensionFromADevice(ctx context.Context, params DeleteExtensionFromADeviceParams) error
	// DeleteExtensiontLevelInboundBlockRules invokes DeleteExtensiontLevelInboundBlockRules operation.
	//
	// Deletes the given extension's blocked rule for inbound calls and messaging.
	// Use this API to delete inbound blocked rule for the given Call Queue, Auto Receptionist, Shared
	// Line Group, Common Area, Zoom Room or User.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// **Scopes:** `phone:write:admin`,`phone:write`
	// **Granular Scopes:** `phone:delete:extension_inbound_block_rule:admin`,
	// `phone:delete:extension_inbound_block_rule`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// DELETE /phone/extension/{extensionId}/inbound_blocked/rules
	DeleteExtensiontLevelInboundBlockRules(ctx context.Context, params DeleteExtensiontLevelInboundBlockRulesParams) error
	// DeleteFirmwareUpdateRule invokes DeleteFirmwareUpdateRule operation.
	//
	// Use this API to delete the [firmware update rule](https://support.zoom.
	// us/hc/en-us/articles/360054198852-Setting-up-firmware-update-rules).
	// **Prerequisites:**
	// * Business or Education account
	// * Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:firmware_update_rule:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/firmware_update_rules/{ruleId}
	DeleteFirmwareUpdateRule(ctx context.Context, params DeleteFirmwareUpdateRuleParams) error
	// DeleteGCP invokes deleteGCP operation.
	//
	// Use this API to remove a [Group Call Pickup](https://support.zoom.
	// us/hc/en-us/articles/360060107472-Setting-up-and-using-group-call-pickup) object.
	// **Prerequisites:**
	// * A Pro or higher account plan
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:call_pickup_group:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/group_call_pickup/{groupId}
	DeleteGCP(ctx context.Context, params DeleteGCPParams) error
	// DeleteLineKey invokes DeleteLineKey operation.
	//
	// Use this API to delete the Zoom Phone [line key settings](https://support.zoom.
	// us/hc/en-us/articles/360040587552) information.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`,`phone:write`
	// **Granular Scopes:** `phone:delete:line_keys`,`phone:delete:line_keys:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/extension/{extensionId}/line_keys/{lineKeyId}
	DeleteLineKey(ctx context.Context, params DeleteLineKeyParams) error
	// DeleteLocation invokes deleteLocation operation.
	//
	// Removes an emergency location.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:emergency_location:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/locations/{locationId}
	DeleteLocation(ctx context.Context, params DeleteLocationParams) error
	// DeleteMembersOfSLG invokes deleteMembersOfSLG operation.
	//
	// Unassigns **all** existing members from a Shared Line Group.Members of the [shared line
	// group](https://support.zoom.us/hc/en-us/articles/360038850792) have access to the group's phone
	// number and voicemail.
	// **Prerequisites:**
	// * Pro or higher account with Zoom Phone license.
	// * A valid Shared Line Group
	// * Account owner or admin privileges
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:shared_line_member:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/shared_line_groups/{sharedLineGroupId}/members
	DeleteMembersOfSLG(ctx context.Context, params DeleteMembersOfSLGParams) error
	// DeleteMonitoringGroup invokes deleteMonitoringGroup operation.
	//
	// Use this API to delete a [Monitoring Group](https://support.zoom.
	// us/hc/en-us/articles/360044804711).
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:monitoring_group:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/monitoring_groups/{monitoringGroupId}
	DeleteMonitoringGroup(ctx context.Context, params DeleteMonitoringGroupParams) error
	// DeleteOutboundCallerNumbers invokes deleteOutboundCallerNumbers operation.
	//
	// Deletes the `account-level` customized outbound caller ID phone numbers. Note that when multiple
	// sites policy is enabled, users cannot manage the `account-level` configuration. The system will
	// throw an exception.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license.
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:customized_number:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/outbound_caller_id/customized_numbers
	DeleteOutboundCallerNumbers(ctx context.Context, params DeleteOutboundCallerNumbersParams) error
	// DeletePeeringPhoneNumbers invokes deletePeeringPhoneNumbers operation.
	//
	// Removes phone numbers added to Zoom through the Provider Exchange.
	// **Note**: Phone peering API and events are for partners who have completed the MoU to peer with
	// Zoom. To become a peering provider/ carrier, submit your [request](https://docs.google.
	// com/forms/d/e/1FAIpQLSewkY6ixVyKVNkWC-vgmejC16gigxsJWXji3dWzE3XlWtjsgg/viewform).
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`,`phone_peering:write:admin`
	// **Granular Scopes:** `phone:delete:peering_number:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/peering/numbers
	DeletePeeringPhoneNumbers(ctx context.Context, request OptDeletePeeringPhoneNumbersReq) (*DeletePeeringPhoneNumbersOK, error)
	// DeletePhoneNumbersSLG invokes deletePhoneNumbersSLG operation.
	//
	// Unassigns all the phone numbers that have been assigned to the [shared line group](https://support.
	// zoom.us/hc/en-us/articles/360038850792-Setting-up-shared-line-groups).
	// **Prerequisites:**
	// * Pro or higher account with Zoom Phone license.
	// * A valid Shared Line Group
	// * Account owner or admin privileges
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:shared_line_group_number:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// DELETE /phone/shared_line_groups/{sharedLineGroupId}/phone_numbers
	DeletePhoneNumbersSLG(ctx context.Context, params DeletePhoneNumbersSLGParams) error
	// DeletePhoneRole invokes DeletePhoneRole operation.
	//
	// Use this API to delete a phone [role](https://support.zoom.
	// us/hc/en-us/articles/360042099012-Using-Zoom-Phone-role-management).
	// **Prerequisites:**
	// * Business, or Education account
	// * Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:role:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/roles/{roleId}
	DeletePhoneRole(ctx context.Context, params DeletePhoneRoleParams) error
	// DeletePhoneSite invokes deletePhoneSite operation.
	//
	// Use this API to delete a specific [site](https://support.zoom.us/hc/en-us/articles/360020809672)
	// in a Zoom account. To delete a site, in the query parameter, you must provide the site ID of
	// another site where the assets of current site (users, numbers and phones) can be transferred to.
	// You cannot use this API to delete the main site.
	// **Prerequisites:**
	// * Account must have a Pro or a higher plan with Zoom Phone license.
	// * [Multiple sites](https://support.zoom.us/hc/en-us/articles/360020809672-Managing-Multiple-Sites)
	// must be enabled.
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:site:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/sites/{siteId}
	DeletePhoneSite(ctx context.Context, params DeletePhoneSiteParams) error
	// DeletePolicy invokes DeletePolicy operation.
	//
	// Removes the policy subsetting for a specific [auto receptionist](https://support.zoom.
	// us/hc/en-us/articles/360021121312-Managing-Auto-Receptionists-and-Interactive-Voice-Response-IVR-)
	// according to the `policyType`. For example, you can use this API to remove shared access members.
	// **Prerequisites:**
	// * Pro or higher account plan with Zoom Phone License
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:auto_receptionist_policy:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// DELETE /phone/auto_receptionists/{autoReceptionistId}/policies/{policyType}
	DeletePolicy(ctx context.Context, params DeletePolicyParams) error
	// DeleteProvisionTemplate invokes deleteProvisionTemplate operation.
	//
	// Use this API to [delete a provision template](https://support.zoom.
	// us/hc/en-us/articles/360035817952#h_7b34cd1d-5ae6-4a23-bd04-454a6ad8cb3e) in a Zoom account.
	// **Prerequisites:**
	// * A Pro or higher account plan
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:provision_template:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/provision_templates/{templateId}
	DeleteProvisionTemplate(ctx context.Context, params DeleteProvisionTemplateParams) error
	// DeleteRoutingRule invokes deleteRoutingRule operation.
	//
	// Deletes the directory backup routing rule.
	// The directory backup routing rules are a series of predefined Regular Expressions. These rules are
	// used to route outgoing calls. If a dialed number does not match a Zoom Phone user, and does not
	// match a defined External Contact, these rules are tested next. If a dialed number does not match
	// any rules, the call will be routed via the PSTN.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:routing_rule:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/routing_rules/{routingRuleId}
	DeleteRoutingRule(ctx context.Context, params DeleteRoutingRuleParams) error
	// DeleteSiteOutboundCallerNumbers invokes deleteSiteOutboundCallerNumbers operation.
	//
	// Use this API to remove the `site-level` customized outbound caller ID phone numbers.
	// * Multiple sites must be [enabled](https://support.zoom.
	// us/hc/en-us/articles/360020809672-Managing-Multiple-Sites#h_05c88e35-1593-491f-b1a8-b7139a75dc15).
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license.
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:site_customized_number:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/sites/{siteId}/outbound_caller_id/customized_numbers
	DeleteSiteOutboundCallerNumbers(ctx context.Context, params DeleteSiteOutboundCallerNumbersParams) error
	// DeleteSiteOutboundCallingExceptionRule invokes deleteSiteOutboundCallingExceptionRule operation.
	//
	// Deletes the site level outbound calling exception rule.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:site_outbound_calling_rule:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// DELETE /phone/sites/{siteId}/outbound_calling/exception_rules/{exceptionRuleId}
	DeleteSiteOutboundCallingExceptionRule(ctx context.Context, params DeleteSiteOutboundCallingExceptionRuleParams) error
	// DeleteSiteSetting invokes deleteSiteSetting operation.
	//
	// Sites allow you to organize Zoom Phone users in your organization. Use this API to delete the site
	// setting of a specific [site](https://support.zoom.us/hc/en-us/articles/360020809672).
	// **Prerequisites:**
	// * Account must have a Pro or a higher plan with Zoom Phone license.
	// * Multiple sites must be [enabled](https://support.zoom.
	// us/hc/en-us/articles/360020809672-Managing-Multiple-Sites#h_05c88e35-1593-491f-b1a8-b7139a75dc15).
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:site_setting:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/sites/{siteId}/settings/{settingType}
	DeleteSiteSetting(ctx context.Context, params DeleteSiteSettingParams) error
	// DeleteUnassignedPhoneNumbers invokes deleteUnassignedPhoneNumbers operation.
	//
	// Deletes unassigned [phone numbers](https://support.zoom.
	// us/hc/en-us/articles/360020808292-Managing-Phone-Numbers#h_38ba8b01-26e3-4b1b-a9b5-0717c00a7ca6).
	// Up to 20 phone numbers can be removed in a single request.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// * The user must have been previously assigned a Zoom Phone number
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:number:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// DELETE /phone/numbers
	DeleteUnassignedPhoneNumbers(ctx context.Context, params DeleteUnassignedPhoneNumbersParams) error
	// DeleteUserOutboundCallerNumbers invokes deleteUserOutboundCallerNumbers operation.
	//
	// Removes the users' customized outbound caller ID phone numbers.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license.
	// **Scopes:** `phone:write:admin`,`phone:write`
	// **Granular Scopes:** `phone:delete:user_customized_number`,
	// `phone:delete:user_customized_number:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/users/{userId}/outbound_caller_id/customized_numbers
	DeleteUserOutboundCallerNumbers(ctx context.Context, params DeleteUserOutboundCallerNumbersParams) error
	// DeleteUserOutboundCallingExceptionRule invokes deleteUserOutboundCallingExceptionRule operation.
	//
	// Deletes the user level outbound calling exception rule.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:user_outbound_calling_rule:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// DELETE /phone/users/{userId}/outbound_calling/exception_rules/{exceptionRuleId}
	DeleteUserOutboundCallingExceptionRule(ctx context.Context, params DeleteUserOutboundCallingExceptionRuleParams) error
	// DeleteUserSetting invokes deleteUserSetting operation.
	//
	// Removes the user setting according to the setting type, specifically for delegation, intercom and
	// shared access for voicemail and call recordings. For user-level apps, pass [the `me`
	// value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the
	// `userId` parameter.
	// To see the shared access settings in the Zoom web portal, go to **Admin &gt; Phone System
	// Management &gt; Users &amp; Rooms** . Click **Users** and select **User Policy**. Go to
	// **Voicemail, Automatic Call Recording and Ad Hoc Call Recording**.
	// To view the delegation and intercom setting in your Zoom web portal, navigate to **Admin &gt;
	// Phone System Management &gt; Users &amp; Rooms**. Click the **Users** tab and select **User
	// Settings**
	// **Prerequisites:**
	// * A Business or Enterprise account
	// **Scopes:** `phone:write:admin`,`phone:write`
	// **Granular Scopes:** `phone:delete:shared_setting`,`phone:delete:shared_setting:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/users/{userId}/settings/{settingType}
	DeleteUserSetting(ctx context.Context, params DeleteUserSettingParams) error
	// DeleteUsersFromDirectory invokes DeleteUsersFromDirectory operation.
	//
	// Use this API to delete users from the [directory](https://support.zoom.
	// us/hc/en-us/articles/4404938949389-Using-a-dial-by-name-directory).
	// **Prerequisites:**
	// * Business or Education account
	// * Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:directory:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/dial_by_name_directory/extensions
	DeleteUsersFromDirectory(ctx context.Context, params DeleteUsersFromDirectoryParams) error
	// DeleteUsersFromDirectoryBySite invokes DeleteUsersFromDirectoryBySite operation.
	//
	// Use this API to delete users from a [directory](https://support.zoom.
	// us/hc/en-us/articles/4404938949389-Using-a-dial-by-name-directory) of the specified site.
	// **Prerequisites:**
	// * Business or Education account
	// * Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:directory:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/sites/{siteId}/dial_by_name_directory/extensions
	DeleteUsersFromDirectoryBySite(ctx context.Context, params DeleteUsersFromDirectoryBySiteParams) error
	// DuplicatePhoneRole invokes DuplicatePhoneRole operation.
	//
	// Use this API to duplicate a phone role.
	// **Prerequisites:**
	// * Business or Education account
	// * Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:role:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /phone/roles
	DuplicatePhoneRole(ctx context.Context, request OptDuplicatePhoneRoleReq) (*DuplicatePhoneRoleCreated, error)
	// GetABillingAccount invokes GetABillingAccount operation.
	//
	// A Zoom account owner or a user with admin privilege can use this API to get information about a
	// billing account.
	// **Prerequisites:**
	// * Pro or higher account plan with Zoom phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:billing_account:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /phone/billing_accounts/{billingAccountId}
	GetABillingAccount(ctx context.Context, params GetABillingAccountParams) (*GetABillingAccountOK, error)
	// GetABlockedList invokes getABlockedList operation.
	//
	// A Zoom account owner or a user with admin privilege can block phone numbers for phone users in an
	// account. Blocked numbers can be inbound (numbers will be blocked from calling in) and outbound
	// (phone users in your account won't be able to dial those numbers). Blocked callers will hear a
	// generic message stating that the person they are calling is not available.
	// Use this API to get information about a specific blocked list.
	// **Prerequisites:**
	// * Pro or higher account plan with Zoom phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:blocked_list:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /phone/blocked_list/{blockedListId}
	GetABlockedList(ctx context.Context, params GetABlockedListParams) (*GetABlockedListOK, error)
	// GetACallQueue invokes getACallQueue operation.
	//
	// Call queues allow you to route incoming calls to a group of users. For instance, you can use call
	// queues to route calls to various departments in your organization such as sales, engineering,
	// billing, customer service etc.
	// Use this API to get information on a specific Call Queue.
	// **Prerequisites:**
	// * Pro, Business, or Education account
	// * Account owner or admin permissions
	// * Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:call_queue:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /phone/call_queues/{callQueueId}
	GetACallQueue(ctx context.Context, params GetACallQueueParams) (*GetACallQueueOK, error)
	// GetACommonArea invokes getACommonArea operation.
	//
	// Use this API to get detailed information on the common area.
	// **Note**: For use by customers who opted for `Common Area Optimization`
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:common_area:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// GET /phone/common_areas/{commonAreaId}
	GetACommonArea(ctx context.Context, params GetACommonAreaParams) (*GetACommonAreaOK, error)
	// GetADevice invokes getADevice operation.
	//
	// Gets detailed information about a specific [desk phone device](https://support.zoom.
	// us/hc/en-us/articles/360021119092).
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:device:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /phone/devices/{deviceId}
	GetADevice(ctx context.Context, params GetADeviceParams) (*GetADeviceOK, error)
	// GetAExternalContact invokes getAExternalContact operation.
	//
	// Gets an external contact's information.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:external_contact:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /phone/external_contacts/{externalContactId}
	GetAExternalContact(ctx context.Context, params GetAExternalContactParams) (*GetAExternalContactOK, error)
	// GetASharedLineGroup invokes getASharedLineGroup operation.
	//
	// Lists all the shared line groups. A [shared line group](https://support.zoom.
	// us/hc/en-us/articles/360038850792) allows Zoom Phone admins to share a phone number and extension
	// with a group of phone users or common areas. This gives members of the shared line group access to
	// the group's direct phone number and voicemail.
	// **Prerequisites:**
	// * Pro or higher account with Zoom Phone license.
	// * Account owner or admin privileges
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:shared_line_group:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// GET /phone/shared_line_groups/{sharedLineGroupId}
	GetASharedLineGroup(ctx context.Context, params GetASharedLineGroupParams) (*GetASharedLineGroupOK, error)
	// GetASite invokes getASite operation.
	//
	// Returns information on a specific [site](https://support.zoom.us/hc/en-us/articles/360020809672).
	// Sites allow you to organize Zoom Phone users in your organization.
	// **Prerequisites:**
	// * Account must have a Pro or a higher plan with Zoom Phone license.
	// * Multiple sites must be [enabled](https://support.zoom.
	// us/hc/en-us/articles/360020809672-Managing-Multiple-Sites#h_05c88e35-1593-491f-b1a8-b7139a75dc15).
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:site:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// GET /phone/sites/{siteId}
	GetASite(ctx context.Context, params GetASiteParams) (*GetASiteOK, error)
	// GetAccountOutboundCallingCountriesAndRegions invokes GetAccountOutboundCallingCountriesAndRegions operation.
	//
	// Returns the account level outbound calling countries and regions.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_outbound_calling_rules:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// GET /phone/outbound_calling/countries_regions
	GetAccountOutboundCallingCountriesAndRegions(ctx context.Context, params GetAccountOutboundCallingCountriesAndRegionsParams) (*GetAccountOutboundCallingCountriesAndRegionsOK, error)
	// GetAlertSettingDetails invokes GetAlertSettingDetails operation.
	//
	// Gets detailed information about a specific [Alert setting](https://support.zoom.
	// us/hc/en-us/articles/7146944434445).
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:alert_setting:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// GET /phone/alert_settings/{alertSettingId}
	GetAlertSettingDetails(ctx context.Context, params GetAlertSettingDetailsParams) (*GetAlertSettingDetailsOK, error)
	// GetAudioItem invokes GetAudioItem operation.
	//
	// Returns an audio item. Only the admin or user can access your audio.
	// **Prerequisites:**
	// * Business or Education account
	// * Zoom Phone license
	// **Scopes:** `phone:read`,`phone:read:admin`
	// **Granular Scopes:** `phone:read:audio`,`phone:read:audio:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// GET /phone/audios/{audioId}
	GetAudioItem(ctx context.Context, params GetAudioItemParams) (*GetAudioItemOK, error)
	// GetAutoReceptionistDetail invokes getAutoReceptionistDetail operation.
	//
	// Returns information on a specific auto receptionist.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license.
	// * Account owner or admin permissions.
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:auto_receptionist:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// GET /phone/auto_receptionists/{autoReceptionistId}
	GetAutoReceptionistDetail(ctx context.Context, params GetAutoReceptionistDetailParams) (*GetAutoReceptionistDetailOK, error)
	// GetAutoReceptionistIVR invokes getAutoReceptionistIVR operation.
	//
	// Gets an [interactive voice response (IVR) system](https://support.zoom.
	// us/hc/en-us/articles/360038601971) of the specified auto receptionist.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:auto_receptionist_ivr:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /phone/auto_receptionists/{autoReceptionistId}/ivr
	GetAutoReceptionistIVR(ctx context.Context, params GetAutoReceptionistIVRParams) (*GetAutoReceptionistIVROK, error)
	// GetAutoReceptionistsPolicy invokes getAutoReceptionistsPolicy operation.
	//
	// Returns the policy setting of a specific [auto receptionist](https://support.zoom.
	// us/hc/en-us/articles/360021121312-Managing-Auto-Receptionists-and-Interactive-Voice-Response-IVR-).
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:auto_receptionist_policy:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /phone/auto_receptionists/{autoReceptionistId}/policies
	GetAutoReceptionistsPolicy(ctx context.Context, params GetAutoReceptionistsPolicyParams) (*GetAutoReceptionistsPolicyOK, error)
	// GetCallChargesUsageReport invokes GetCallChargesUsageReport operation.
	//
	// Retrieves the **Phone Call Charges Report**.
	// The **Call charges usage report** allows account owners and admins to view monthly Zoom phone call
	// charges. Account owners and admins can also access this information when they log into their Zoom
	// accounts and navigate to [Call Charges Usage Report](https://zoom.
	// us/pbx/page/report/system#/report/phone-system/charge?page_size=15&amp;chargeRestrict=0&amp;by=1).
	// **Prerequisites:**
	// * Account must be enrollled in Pro or a higher plan
	// * Account must be enrolled in a [Zoom Phone](https://zoom.us/pricing/zoom-phone) plan
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:call_charges:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `HEAVY`.
	//
	// GET /phone/reports/call_charges
	GetCallChargesUsageReport(ctx context.Context, params GetCallChargesUsageReportParams) (*GetCallChargesUsageReportOK, error)
	// GetCallHandling invokes getCallHandling operation.
	//
	// Returns information about a Zoom Phone's call handling settings. Call handling settings let you
	// control how your system routes calls during business, closed, or holiday hours. For more
	// information, read our [API guide](https://developers.zoom.us/docs/zoom-phone/call-handling/) or
	// Zoom support article [Customizing call handling settings](https://support.zoom.
	// us/hc/en-us/articles/360059966372-Customizing-call-handling-settings).**Applicable to user, call
	// queue, auto receptionist, or shared line group call handling at this time.** **Prerequisites:** *
	// Pro or a higher account with Zoom Phone enabled
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_call_handling_settings:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// GET /phone/extension/{extensionId}/call_handling/settings
	GetCallHandling(ctx context.Context, params GetCallHandlingParams) (*GetCallHandlingOK, error)
	// GetCallLogDetails invokes getCallLogDetails operation.
	//
	// Returns information about a [call log](https://support.zoom.
	// us/hc/en-us/articles/360021114452-Viewing-and-identifying-logs).
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`,`phone_call_log:read:admin`
	// **Granular Scopes:** `phone:read:call_log:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /phone/call_logs/{callLogId}
	GetCallLogDetails(ctx context.Context, params GetCallLogDetailsParams) (*GetCallLogDetailsOK, error)
	// GetCallLogMetricsDetails invokes getCallLogMetricsDetails operation.
	//
	// Returns call log details of a specific call.
	// The call logs provide a record of all incoming and outgoing calls over Zoom Phone in an account.
	// **Prerequisites:**
	// * Business, or Education account
	// * Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:call_log:admin`.
	//
	// GET /phone/metrics/call_logs/{call_id}
	GetCallLogMetricsDetails(ctx context.Context, params GetCallLogMetricsDetailsParams) (*GetCallLogMetricsDetailsOK, error)
	// GetCallPath invokes getCallPath operation.
	//
	// Returns information about a [call log](https://support.zoom.
	// us/hc/en-us/articles/360021114452-Viewing-and-identifying-logs).
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`,`phone_call_log:read:admin`
	// **Granular Scopes:** `phone:read:call_log:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// GET /phone/call_history/{callLogId}
	GetCallPath(ctx context.Context, params GetCallPathParams) (*GetCallPathOK, error)
	// GetCallQoS invokes getCallQoS operation.
	//
	// Gets the call quality of service (QoS) data for a call made or received by a Zoom phone user in
	// the account.
	// **Prerequisites:**
	// * Business, or Education account
	// * Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:call_qos:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /phone/metrics/call_logs/{callId}/qos
	GetCallQoS(ctx context.Context, params GetCallQoSParams) (*GetCallQoSOK, error)
	// GetCallQueueRecordings invokes getCallQueueRecordings operation.
	//
	// Use this API to view [call recordings](https://support.zoom.
	// us/hc/en-us/articles/360038521091#h_cbc9f2a3-e06c-4daa-83d4-ddbceef9c77b) from the call queue.
	// **Prerequisites:**
	// * Pro or higher account with Zoom Phone license.
	// * [Automatic call recordings](https://support.zoom.
	// us/hc/en-us/articles/360033511872#h_fcb297bb-14e8-4094-91ca-dc61e1a18734) must be enabled in the
	// Policy Settings for call queues.
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_call_queue_recordings:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /phone/call_queues/{callQueueId}/recordings
	GetCallQueueRecordings(ctx context.Context, params GetCallQueueRecordingsParams) (*GetCallQueueRecordingsOK, error)
	// GetCommonAreaOutboundCallingCountriesAndRegions invokes GetCommonAreaOutboundCallingCountriesAndRegions operation.
	//
	// Returns the common area level outbound calling countries and regions.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:common_area_outbound_calling_rule:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// GET /phone/common_areas/{commonAreaId}/outbound_calling/countries_regions
	GetCommonAreaOutboundCallingCountriesAndRegions(ctx context.Context, params GetCommonAreaOutboundCallingCountriesAndRegionsParams) (*GetCommonAreaOutboundCallingCountriesAndRegionsOK, error)
	// GetCommonAreaSettings invokes getCommonAreaSettings operation.
	//
	// Use this API to get common area settings.
	// **Note**: For use by customers who opted for `Common Area Optimization`
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license.
	// * Account owner or admin permissions.
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_common_area_settings:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /phone/common_areas/{commonAreaId}/settings
	GetCommonAreaSettings(ctx context.Context, params GetCommonAreaSettingsParams) (*GetCommonAreaSettingsOK, error)
	// GetEmergencyAddress invokes getEmergencyAddress operation.
	//
	// Gets the emergency address information.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:emergency_address:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /phone/emergency_addresses/{emergencyAddressId}
	GetEmergencyAddress(ctx context.Context, params GetEmergencyAddressParams) (*GetEmergencyAddressOK, error)
	// GetFirmwareRuleDetail invokes GetFirmwareRuleDetail operation.
	//
	// Use this API to get the [firmware update rule](https://support.zoom.
	// us/hc/en-us/articles/360054198852-Setting-up-firmware-update-rules) information.
	// **Prerequisites:**
	// * Business or Education account
	// * Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:firmware_update_rule:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /phone/firmware_update_rules/{ruleId}
	GetFirmwareRuleDetail(ctx context.Context, params GetFirmwareRuleDetailParams) (*GetFirmwareRuleDetailOK, error)
	// GetGCP invokes GetGCP operation.
	//
	// Use this API to retrieve information on a specific [Group Call Pickup](https://support.zoom.
	// us/hc/en-us/articles/360060107472-Setting-up-and-using-group-call-pickup) object in an account.
	// **Prerequisites:**
	// * A Pro or higher account plan
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:call_pickup_group:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /phone/group_call_pickup/{groupId}
	GetGCP(ctx context.Context, params GetGCPParams) (*GetGCPOK, error)
	// GetGroupPhoneSettings invokes getGroupPhoneSettings operation.
	//
	// Returns group phone settings.
	// **Prerequisites:**
	// * Account must have a Pro or a higher plan with Zoom Phone license.
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:group_setting:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// GET /phone/groups/{groupId}/settings
	GetGroupPhoneSettings(ctx context.Context, params GetGroupPhoneSettingsParams) (*GetGroupPhoneSettingsOK, error)
	// GetLocation invokes getLocation operation.
	//
	// Returns an emergency service location's information.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:emergency_location:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /phone/locations/{locationId}
	GetLocation(ctx context.Context, params GetLocationParams) (*GetLocationOK, error)
	// GetMonitoringGroupById invokes getMonitoringGroupById operation.
	//
	// Returns a [monitoring group](https://support.zoom.us/hc/en-us/articles/360044804711) for the
	// specified ID.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:monitoring_group:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// GET /phone/monitoring_groups/{monitoringGroupId}
	GetMonitoringGroupById(ctx context.Context, params GetMonitoringGroupByIdParams) (*GetMonitoringGroupByIdOK, error)
	// GetPSOperationLogs invokes getPSOperationLogs operation.
	//
	// Retrieves the phone system operation logs report.
	// The phone system operation logs report allows account owners and admins to view monthly Zoom phone
	// related admin operation details.
	// Account owners and admins can also access this information by logging into their Zoom accounts and
	// navigating to [Phone System Operation Logs](https://zoom.
	// us/pbx/page/report/operations#/report/operation-logs).
	// **Prerequisites:**
	// * Account must be enrollled in Pro or a higher plan
	// * Account must be enrolled in a [Zoom Phone](https://zoom.us/pricing/zoom-phone) plan
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:operation_logs:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `HEAVY`.
	//
	// GET /phone/reports/operationlogs
	GetPSOperationLogs(ctx context.Context, params GetPSOperationLogsParams) (*GetPSOperationLogsOK, error)
	// GetPhoneNumberDetails invokes getPhoneNumberDetails operation.
	//
	// Returns information about an account's Zoom Phone number.
	// **Prerequisites:**
	// * A Pro or higher account plan
	// * A Zoom phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:numbers:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// GET /phone/numbers/{phoneNumberId}
	GetPhoneNumberDetails(ctx context.Context, params GetPhoneNumberDetailsParams) (*GetPhoneNumberDetailsOK, error)
	// GetPhoneRecordings invokes getPhoneRecordings operation.
	//
	// Returns an account's [call recordings](https://support.zoom.
	// us/hc/en-us/articles/360038521091-Accessing-and-sharing-call-recordings).
	// **Prerequisites:**
	// * A Pro or higher account plan
	// * A Zoom Phone license
	// * Account owner or admin privileges
	// **Scopes:** `phone:read:admin`,`phone_recording:read:admin`
	// **Granular Scopes:** `phone:read:list_call_recordings:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// GET /phone/recordings
	GetPhoneRecordings(ctx context.Context, params GetPhoneRecordingsParams) (*GetPhoneRecordingsOK, error)
	// GetPhoneRecordingsByCallIdOrCallLogId invokes getPhoneRecordingsByCallIdOrCallLogId operation.
	//
	// Returns an account's [call recording](https://support.zoom.
	// us/hc/en-us/articles/360038521091-Accessing-and-sharing-call-recordings) by the recording's
	// `callId` or `callLogId` ID.
	// **Note**: This  API returns the `file_url` in the JSON query results.
	// **Prerequisites:**
	// * A Pro or higher account with Zoom Phone license
	// * Account owner or admin privileges
	// **Scopes:** `phone:read:admin`,`phone_recording:read`,`phone_recording:read:admin`
	// **Granular Scopes:** `phone:read:call_recording`,`phone:read:call_recording:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// GET /phone/call_logs/{id}/recordings
	GetPhoneRecordingsByCallIdOrCallLogId(ctx context.Context, params GetPhoneRecordingsByCallIdOrCallLogIdParams) (*GetPhoneRecordingsByCallIdOrCallLogIdOK, error)
	// GetPhoneUserVoiceMails invokes GetPhoneUserVoiceMails operation.
	//
	// Retrieves a user's Zoom Phone voicemails in descending order. For user-level apps, pass [the `me`
	// value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the
	// `userId` parameter.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`,`phone:read`
	// **Granular Scopes:** `phone:read:list_voicemails`,`phone:read:list_voicemails:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// GET /phone/users/{userId}/voice_mails/sync
	GetPhoneUserVoiceMails(ctx context.Context, params GetPhoneUserVoiceMailsParams) (*GetPhoneUserVoiceMailsOK, error)
	// GetPortedNumbersDetails invokes getPortedNumbersDetails operation.
	//
	// Use this API to get details on the ported numbers by specifying `order_id`.
	// **Prerequisites:**
	// * A Pro or higher account plan
	// * A Zoom phone license
	// **Scopes:** `phone:read:admin`,`phone_peering:read:admin`
	// **Granular Scopes:** `phone:read:ported_number:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /phone/ported_numbers/orders/{orderId}
	GetPortedNumbersDetails(ctx context.Context, params GetPortedNumbersDetailsParams) (*GetPortedNumbersDetailsOK, error)
	// GetProvisionTemplate invokes GetProvisionTemplate operation.
	//
	// Use this API to get a specific [provision template](https://support.zoom.
	// us/hc/en-us/articles/360035817952).
	// **Prerequisites:**
	// * A Pro or higher account plan
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:provision_template:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /phone/provision_templates/{templateId}
	GetProvisionTemplate(ctx context.Context, params GetProvisionTemplateParams) (*GetProvisionTemplateOK, error)
	// GetRoleInformation invokes getRoleInformation operation.
	//
	// Use this API to get information on a phone [role](https://support.zoom.
	// us/hc/en-us/articles/360042099012-Using-Zoom-Phone-role-management).
	// **Prerequisites:**
	// * Business, or Education account
	// * Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:role:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /phone/roles/{roleId}
	GetRoleInformation(ctx context.Context, params GetRoleInformationParams) (*GetRoleInformationOK, error)
	// GetRoutingRule invokes getRoutingRule operation.
	//
	// Returns the directory backup routing rule. The directory backup routing rules are a series of
	// predefined Regular Expressions. These rules are used to route outgoing calls. If a dialed number
	// does not match a Zoom Phone user, and does not match a defined External Contact, these rules are
	// tested next. If a dialed number does not match any rules, the call will be routed via the PSTN.
	// **Prerequisites:** * A Business or Enterprise account * A Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:routing_rule:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /phone/routing_rules/{routingRuleId}
	GetRoutingRule(ctx context.Context, params GetRoutingRuleParams) (*GetRoutingRuleOK, error)
	// GetSMSCampaign invokes GetSMSCampaign operation.
	//
	// Use this API to get a specific SMS campaign.
	// **Prerequisites:**
	// * A Pro or higher account plan
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:sms_campaign:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /phone/sms_campaigns/{smsCampaignId}
	GetSMSCampaign(ctx context.Context, params GetSMSCampaignParams) (*GetSMSCampaignOK, error)
	// GetSMSChargesUsageReport invokes GetSMSChargesUsageReport operation.
	//
	// Retrieves the **SMS/MMS Charges Report**.  The **SMS/MMS charges usage report** allows account
	// owners and admins to view monthly Zoom phone call charges. Account owners and admins can also
	// access this information by when they log into their Zoom accounts and navigate to [ SMS/MMS
	// Charges Usage Report](https://zoom.
	// us/pbx/page/report/system#/report/phone-system/charge?page_size=15&amp;chargeRestrict=0&amp;by=2).
	//  **Prerequisites:**  * Account must be enrolled in Pro or a higher plan * Account must be enrolled
	// in a [Zoom Phone](https://zoom.us/pricing/zoom-phone) plan
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:sms_charges:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `HEAVY`.
	//
	// GET /phone/reports/sms_charges
	GetSMSChargesUsageReport(ctx context.Context, params GetSMSChargesUsageReportParams) (*GetSMSChargesUsageReportOK, error)
	// GetSettingTemplate invokes getSettingTemplate operation.
	//
	// Returns information about an account's phone template.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:setting_template:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /phone/setting_templates/{templateId}
	GetSettingTemplate(ctx context.Context, params GetSettingTemplateParams) (*GetSettingTemplateOK, error)
	// GetSharedLineGroupPolicy invokes getSharedLineGroupPolicy operation.
	//
	// Returns the policy setting of a specific [shared line group](https://support.zoom.
	// us/hc/en-us/articles/360038850792).
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:shared_line_group_policy:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// GET /phone/shared_line_groups/{sharedLineGroupId}/policies
	GetSharedLineGroupPolicy(ctx context.Context, params GetSharedLineGroupPolicyParams) (*GetSharedLineGroupPolicyOK, error)
	// GetSiteOutboundCallingCountriesAndRegions invokes GetSiteOutboundCallingCountriesAndRegions operation.
	//
	// Returns the site level outbound calling countries and regions.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:site_outbound_calling_rule:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// GET /phone/sites/{siteId}/outbound_calling/countries_regions
	GetSiteOutboundCallingCountriesAndRegions(ctx context.Context, params GetSiteOutboundCallingCountriesAndRegionsParams) (*GetSiteOutboundCallingCountriesAndRegionsOK, error)
	// GetSiteSettingForType invokes getSiteSettingForType operation.
	//
	// Sites allow you to organize Zoom Phone users in your organization. Use this API to get site
	// setting about a specific [site](https://support.zoom.us/hc/en-us/articles/360020809672) according
	// to the setting type.
	// **Prerequisites:**
	// * Account must have a Pro or a higher plan with Zoom Phone license.
	// * Multiple sites must be [enabled](https://support.zoom.
	// us/hc/en-us/articles/360020809672-Managing-Multiple-Sites#h_05c88e35-1593-491f-b1a8-b7139a75dc15).
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:site_setting:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /phone/sites/{siteId}/settings/{settingType}
	GetSiteSettingForType(ctx context.Context, params GetSiteSettingForTypeParams) (*GetSiteSettingForTypeOK, error)
	// GetSmsSessions invokes GetSmsSessions operation.
	//
	// Retrieves the user's SMS sessions in descending order. Mirrors the ZP client behavior with the
	// most recent on top.
	// **Prerequisites:**
	// * Paid account
	// * User-enabled Zoom phone
	// **Scopes:** `phone:read:admin`,`phone:read`,`phone_sms:read:admin`,`phone_sms:read`
	// **Granular Scopes:** `phone:read:sms_session`,`phone:read:sms_session:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /phone/users/{userId}/sms/sessions/sync
	GetSmsSessions(ctx context.Context, params GetSmsSessionsParams) (*GetSmsSessionsOK, error)
	// GetUserOutboundCallingCountriesAndRegions invokes GetUserOutboundCallingCountriesAndRegions operation.
	//
	// Returns the user level outbound calling countries and regions.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:user_outbound_calling_rule:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// GET /phone/users/{userId}/outbound_calling/countries_regions
	GetUserOutboundCallingCountriesAndRegions(ctx context.Context, params GetUserOutboundCallingCountriesAndRegionsParams) (*GetUserOutboundCallingCountriesAndRegionsOK, error)
	// GetVoicemailDetails invokes getVoicemailDetails operation.
	//
	// Use this API to return information about a [voicemail message](https://support.zoom.
	// us/hc/en-us/articles/360021400211-Managing-voicemail-messages).
	// **Prerequisites:**
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`,`phone:read`,`phone_voicemail:read:admin`,`phone_voicemail:read`
	// **Granular Scopes:** `phone:read:voicemail`,`phone:read:voicemail:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /phone/voice_mails/{voicemailId}
	GetVoicemailDetails(ctx context.Context, params GetVoicemailDetailsParams) (*GetVoicemailDetailsOK, error)
	// GetVoicemailDetailsByCallIdOrCallLogId invokes getVoicemailDetailsByCallIdOrCallLogId operation.
	//
	// Use this API to return detailed information on a voicemail associated with a call log ID. For
	// user-level apps, pass [the `me` value](https://marketplace.zoom.
	// us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
	// **Prerequisites:**
	// * User must belong to a Business or Enterprise account
	// * User must have a Zoom Phone license
	// **Scopes:** `phone:read`,`phone:read:admin`,`phone_voicemail:read`,`phone_voicemail:read:admin`
	// **Granular Scopes:** `phone:read:voicemail`,`phone:read:voicemail:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /phone/users/{userId}/call_logs/{id}/voice_mail
	GetVoicemailDetailsByCallIdOrCallLogId(ctx context.Context, params GetVoicemailDetailsByCallIdOrCallLogIdParams) (*GetVoicemailDetailsByCallIdOrCallLogIdOK, error)
	// GetZoomRoom invokes getZoomRoom operation.
	//
	// Use this API to get a specific [Zoom Room](https://support.zoom.us/hc/en-us/articles/360025153711)
	// in an account that has the Zoom Phone license assigned.
	// **Prerequisites:**
	// * A Pro or higher account plan
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:room:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /phone/rooms/{roomId}
	GetZoomRoom(ctx context.Context, params GetZoomRoomParams) (*GetZoomRoomOK, error)
	// ListAccountLevelInboundBlockRules invokes ListAccountLevelInboundBlockRules operation.
	//
	// Returns a list of account level inbound block rule for inbound calls and messaging.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_inbound_block_rules:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// GET /phone/inbound_blocked/rules
	ListAccountLevelInboundBlockRules(ctx context.Context, params ListAccountLevelInboundBlockRulesParams) (*ListAccountLevelInboundBlockRulesOK, error)
	// ListAccountLevelInboundBlockedStatistics invokes ListAccountLevelInboundBlockedStatistics operation.
	//
	// Returns the list of the statistics of the extensions blocked rule for inbound calls and messaging.
	// (e.g. Call Queue, Auto Receptionist, Shared Line Group, Common Area, Zoom Room and User)
	// **Prerequisites:**
	// * Pro or higher account plan with Zoom phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_extension_inbound_block_rules_stat:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// GET /phone/inbound_blocked/extension_rules/statistics
	ListAccountLevelInboundBlockedStatistics(ctx context.Context, params ListAccountLevelInboundBlockedStatisticsParams) (*ListAccountLevelInboundBlockedStatisticsOK, error)
	// ListAccountOutboundCallingExceptionRule invokes listAccountOutboundCallingExceptionRule operation.
	//
	// Lists the account level outbound calling policy exception rules.
	// **Prerequisite:**
	// * Pro or higher account plan with Zoom phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_outbound_calling_rules:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// GET /phone/outbound_calling/exception_rules
	ListAccountOutboundCallingExceptionRule(ctx context.Context, params ListAccountOutboundCallingExceptionRuleParams) (*ListAccountOutboundCallingExceptionRuleOK, error)
	// ListAccountPhoneNumbers invokes listAccountPhoneNumbers operation.
	//
	// Returns a list all Zoom Phone numbers in a Zoom account.
	// **Prerequisites:**
	// * A Pro or higher account plan
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_numbers:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// GET /phone/numbers
	ListAccountPhoneNumbers(ctx context.Context, params ListAccountPhoneNumbersParams) (*ListAccountPhoneNumbersOK, error)
	// ListAccountProvisionTemplate invokes listAccountProvisionTemplate operation.
	//
	// Use this API to list all [provision templates](https://support.zoom.
	// us/hc/en-us/articles/360035817952) in a Zoom account.
	// **Prerequisites:**
	// * A Pro or higher account plan
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_provision_templates:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /phone/provision_templates
	ListAccountProvisionTemplate(ctx context.Context, params ListAccountProvisionTemplateParams) (*ListAccountProvisionTemplateOK, error)
	// ListAccountSMSCampaigns invokes listAccountSMSCampaigns operation.
	//
	// Use this API to list all SMS campaigns in a Zoom account.
	// **Prerequisites:**
	// * A Pro or higher account plan
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_sms_campaigns:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /phone/sms_campaigns
	ListAccountSMSCampaigns(ctx context.Context, params ListAccountSMSCampaignsParams) (*ListAccountSMSCampaignsOK, error)
	// ListActivationCodes invokes listActivationCodes operation.
	//
	// Returns a list of activation code information of the common areas under an account.
	// **Note**: This API serves customers who opted for `Common Area Optimization`.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_common_area_activation_codes:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`
	// **Not supported in Gov cluster**.
	//
	// GET /phone/common_areas/activation_codes
	ListActivationCodes(ctx context.Context, params ListActivationCodesParams) (*ListActivationCodesOK, error)
	// ListAlertSettingsWithPagingQuery invokes ListAlertSettingsWithPagingQuery operation.
	//
	// Gets [alert settings](https://support.zoom.us/hc/en-us/articles/7146944434445) for an account with
	// paging query.
	// **Prerequisites**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_alert_settings:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// GET /phone/alert_settings
	ListAlertSettingsWithPagingQuery(ctx context.Context, params ListAlertSettingsWithPagingQueryParams) (*ListAlertSettingsWithPagingQueryOK, error)
	// ListAudioItems invokes ListAudioItems operation.
	//
	// Returns personal audios. Only the admin or user can query your audios and directly pass the `me`
	// value instead of the `userId` parameter.
	// **Prerequisites:**
	// * Business or Education account
	// * Zoom Phone license
	// **Scopes:** `phone:read`,`phone:read:admin`
	// **Granular Scopes:** `phone:read:list_audios`,`phone:read:list_audios:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// GET /phone/users/{userId}/audios
	ListAudioItems(ctx context.Context, params ListAudioItemsParams) (*ListAudioItemsOK, error)
	// ListAutoReceptionists invokes listAutoReceptionists operation.
	//
	// Returns a list of auto receptionists.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license.
	// * Account owner or admin permissions.
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_auto_receptionists:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /phone/auto_receptionists
	ListAutoReceptionists(ctx context.Context, params ListAutoReceptionistsParams) (*ListAutoReceptionistsOK, error)
	// ListBYOCSIPTrunk invokes listBYOCSIPTrunk operation.
	//
	// Use this API to return a list of an account's assigned [BYOC (Bring Your Own Carrier) SIP (Session
	// Initiation Protocol) trunks](https://zoom.us/docs/doc/Zoom-Bring%20Your%20Own%20Carrier.pdf).
	// **Prerequisites:**
	// * A Business or Enterprise account
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_sip_trunks:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /phone/sip_trunk/trunks
	ListBYOCSIPTrunk(ctx context.Context, params ListBYOCSIPTrunkParams) (*ListBYOCSIPTrunkOK, error)
	// ListBillingAccount invokes listBillingAccount operation.
	//
	// A Zoom account owner or a user with admin privileges can use this API to retrieve a list of
	// billing accounts.
	// **Prerequisites:**
	// * Pro or higher account plan with Zoom phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_billing_accounts:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /phone/billing_accounts
	ListBillingAccount(ctx context.Context) (*ListBillingAccountOK, error)
	// ListBlockedList invokes listBlockedList operation.
	//
	// A Zoom account owner or a user with admin privilege can block phone numbers for phone users in an
	// account. Blocked numbers can be inbound (numbers will be blocked from calling in) and outbound
	// (phone users in your account won't be able to dial those numbers). Blocked callers will hear a
	// generic message stating that the person they are calling is not available.
	// Use this API to list all the blocked lists in an acccount.
	// **Prerequisites:**
	// * Pro or higher account plan with Zoom phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_blocked_lists:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /phone/blocked_list
	ListBlockedList(ctx context.Context, params ListBlockedListParams) (*ListBlockedListOK, error)
	// ListCRPhoneNumbers invokes listCRPhoneNumbers operation.
	//
	// Use this API to list phone numbers in a carrier reseller (master) account that can be pushed to
	// its subaccounts.
	// **Prerequisites:**
	// * A Pro or higher account plan
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_carrier_numbers:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /phone/carrier_reseller/numbers
	ListCRPhoneNumbers(ctx context.Context, params ListCRPhoneNumbersParams) (*ListCRPhoneNumbersOK, error)
	// ListCallLogsMetrics invokes listCallLogsMetrics operation.
	//
	// Lists the monthly call logs metrics. You can use query parameters to filter the response by date,
	// site and MOS(Mean Opinion Score) of the call.The call logs that provide a record of all incoming
	// and outgoing calls over Zoom Phone in an account.
	// **Prerequisites:**
	// * Business, or Education account
	// * Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_call_logs:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Heavy`.
	//
	// GET /phone/metrics/call_logs
	ListCallLogsMetrics(ctx context.Context, params ListCallLogsMetricsParams) (*ListCallLogsMetricsOK, error)
	// ListCallQueueMembers invokes listCallQueueMembers operation.
	//
	// Lists the call queue members.
	// **Prerequisites:**
	// * Pro, Business, or Education account
	// * Account owner or admin permissions
	// * Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_call_queue_members:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /phone/call_queues/{callQueueId}/members
	ListCallQueueMembers(ctx context.Context, params ListCallQueueMembersParams) (*ListCallQueueMembersOK, error)
	// ListCallQueues invokes listCallQueues operation.
	//
	// Call queues allow you to route incoming calls to a group of users. For instance, you can use call
	// queues to route calls to various departments in your organization such as sales, engineering,
	// billing, customer service etc.
	// Use this API to list Call queues.
	// **Prerequisites:**
	// * Pro, Business, or Education account
	// * Account owner or admin permissions
	// * Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_call_queues:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /phone/call_queues
	ListCallQueues(ctx context.Context, params ListCallQueuesParams) (*ListCallQueuesOK, error)
	// ListCallingPlans invokes listCallingPlans operation.
	//
	// Use this API to return all of an account's Zoom Phone [calling plans](https://marketplace.zoom.
	// us/docs/api-reference/other-references/plans#zoom-phone-calling-plans).
	// **Prerequisites:**
	// * A Pro or a higher account
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_calling_plans:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /phone/calling_plans
	ListCallingPlans(ctx context.Context) (*ListCallingPlansOK, error)
	// ListCarrierPeeringPhoneNumbers invokes listCarrierPeeringPhoneNumbers operation.
	//
	// Returns phone numbers pushed by the carrier to different customers.
	// To become a peering provider/ carrier, submit your [request](https://docs.google.
	// com/forms/d/e/1FAIpQLSewkY6ixVyKVNkWC-vgmejC16gigxsJWXji3dWzE3XlWtjsgg/viewform).
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`,`phone_peering:read:admin`
	// **Granular Scopes:** `phone:read:list_peering_numbers:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /phone/carrier_peering/numbers
	ListCarrierPeeringPhoneNumbers(ctx context.Context, params ListCarrierPeeringPhoneNumbersParams) (*ListCarrierPeeringPhoneNumbersOK, error)
	// ListCommonAreaOutboundCallingExceptionRule invokes listCommonAreaOutboundCallingExceptionRule operation.
	//
	// Lists the common area level outbound calling policy exception rules.
	// **Prerequisite:**
	// * Pro or higher account plan with Zoom phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:common_area_outbound_calling_rule:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// GET /phone/common_areas/{commonAreaId}/outbound_calling/exception_rules
	ListCommonAreaOutboundCallingExceptionRule(ctx context.Context, params ListCommonAreaOutboundCallingExceptionRuleParams) (*ListCommonAreaOutboundCallingExceptionRuleOK, error)
	// ListCommonAreas invokes listCommonAreas operation.
	//
	// Lists common areas under an account.
	// **Note**: For use by customers who opted for `Common Area Optimization`
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:common_area:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// GET /phone/common_areas
	ListCommonAreas(ctx context.Context, params ListCommonAreasParams) (*ListCommonAreasOK, error)
	// ListCustomizeOutboundCallerNumbers invokes listCustomizeOutboundCallerNumbers operation.
	//
	// Retrieves phone numbers that can be used as the `account-level` customized outbound caller ID.
	// Note that when multiple sites policy is enabled, users cannot manage the `account-level`
	// configuration. The system will throw an exception.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license.
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_customized_number:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /phone/outbound_caller_id/customized_numbers
	ListCustomizeOutboundCallerNumbers(ctx context.Context, params ListCustomizeOutboundCallerNumbersParams) (*ListCustomizeOutboundCallerNumbersOK, error)
	// ListDeviceLineKeySetting invokes listDeviceLineKeySetting operation.
	//
	// Use this API to get information on the Zoom Phone device [line keys](https://support.zoom.
	// us/hc/en-us/articles/4402415568397-Customizing-keys-for-devices-with-multiple-users) settings and
	// position.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`,`phone:read`
	// **Granular Scopes:** `phone:read:device_line_keys`,`phone:read:device_line_keys:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Heavy`.
	//
	// GET /phone/devices/{deviceId}/line_keys
	ListDeviceLineKeySetting(ctx context.Context, params ListDeviceLineKeySettingParams) (*ListDeviceLineKeySettingOK, error)
	// ListEmergencyAddresses invokes listEmergencyAddresses operation.
	//
	// Lists the emergency addresses.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_emergency_addresses:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /phone/emergency_addresses
	ListEmergencyAddresses(ctx context.Context, params ListEmergencyAddressesParams) (*ListEmergencyAddressesOK, error)
	// ListExtensionLevelInboundBlockRules invokes ListExtensionLevelInboundBlockRules operation.
	//
	// Returns a list of the given extension's block rule for inbound calls and messaging.
	// it lists inbound block rule for the given Call Queue, Auto Receptionist, Shared Line Group, Common
	// Area, Zoom Room, or User.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// **Scopes:** `phone:read:admin`,`phone:read`
	// **Granular Scopes:** `phone:read:list_extension_inbound_block_rules:admin`,
	// `phone:read:list_extension_inbound_block_rules`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// GET /phone/extension/{extensionId}/inbound_blocked/rules
	ListExtensionLevelInboundBlockRules(ctx context.Context, params ListExtensionLevelInboundBlockRulesParams) (*ListExtensionLevelInboundBlockRulesOK, error)
	// ListExternalContacts invokes listExternalContacts operation.
	//
	// Lists the external contacts.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_external_contacts:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /phone/external_contacts
	ListExternalContacts(ctx context.Context, params ListExternalContactsParams) (*ListExternalContactsOK, error)
	// ListFirmwareRules invokes ListFirmwareRules operation.
	//
	// Use this API to get [firmware update rules](https://support.zoom.
	// us/hc/en-us/articles/360054198852-Setting-up-firmware-update-rules).
	// **Prerequisites:**
	// * Business or Education account
	// * Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_firmware_update_rules:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /phone/firmware_update_rules
	ListFirmwareRules(ctx context.Context, params ListFirmwareRulesParams) (*ListFirmwareRulesOK, error)
	// ListFirmwares invokes ListFirmwares operation.
	//
	// Use this API to get updatable [firmwares](https://support.zoom.
	// us/hc/en-us/articles/360054198852-Setting-up-firmware-update-rules).
	// **Prerequisites:**
	// * Business or Education account
	// * Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_firmwares:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /phone/firmwares
	ListFirmwares(ctx context.Context, params ListFirmwaresParams) (*ListFirmwaresOK, error)
	// ListGCP invokes listGCP operation.
	//
	// Use this API to retrieve a list of [Group Call Pickup](https://support.zoom.
	// us/hc/en-us/articles/360060107472-Setting-up-and-using-group-call-pickup) objects in an account.
	// **Prerequisites:**
	// * A Pro or higher account plan
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_call_pickup_groups:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /phone/group_call_pickup
	ListGCP(ctx context.Context, params ListGCPParams) (*ListGCPOK, error)
	// ListGCPMembers invokes listGCPMembers operation.
	//
	// Use this API to retrieve members of a [call pickup group](https://support.zoom.
	// us/hc/en-us/articles/360060107472-Setting-up-and-using-group-call-pickup) in an account.
	// **Prerequisites:**
	// * A Pro or higher account plan
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:call_pickup_group_member:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /phone/group_call_pickup/{groupId}/members
	ListGCPMembers(ctx context.Context, params ListGCPMembersParams) (*ListGCPMembersOK, error)
	// ListLineKeySetting invokes listLineKeySetting operation.
	//
	// Use this API to get the Zoom Phone [line key settings](https://support.zoom.
	// us/hc/en-us/articles/360040587552) information.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`,`phone:read`
	// **Granular Scopes:** `phone:read:line_keys`,`phone:read:line_keys:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /phone/extension/{extensionId}/line_keys
	ListLineKeySetting(ctx context.Context, params ListLineKeySettingParams) (*ListLineKeySettingOK, error)
	// ListLocations invokes listLocations operation.
	//
	// Returns emergency service locations.
	// **Note**: When you enable [multiple sites](https://support.zoom.
	// us/hc/en-us/articles/360020809672-Managing-multiple-sites), the `site_id` parameter is required.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_emergency_locations:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// GET /phone/locations
	ListLocations(ctx context.Context, params ListLocationsParams) (*ListLocationsOK, error)
	// ListMembers invokes listMembers operation.
	//
	// Use this API to return members list of a [Monitoring Group](https://support.zoom.
	// us/hc/en-us/articles/360044804711).
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_monitoring_group_members:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /phone/monitoring_groups/{monitoringGroupId}/monitor_members
	ListMembers(ctx context.Context, params ListMembersParams) (*ListMembersOK, error)
	// ListMonitoringGroup invokes listMonitoringGroup operation.
	//
	// Returns an account's [monitoring group](https://support.zoom.us/hc/en-us/articles/360044804711)
	// list.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_monitoring_groups:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// GET /phone/monitoring_groups
	ListMonitoringGroup(ctx context.Context, params ListMonitoringGroupParams) (*ListMonitoringGroupOK, error)
	// ListPastCallMetrics invokes listPastCallMetrics operation.
	//
	// Returns all the call logs metrics of the account from the selected time period. The call logs
	// provide a record of all incoming and outgoing calls over Zoom Phone in an account. You can use
	// query parameters to filter the response by metrics of the call (such as date, phone number,
	// extension number and quality type).
	// **Prerequisites:**
	// * Business, or Education account
	// * Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_call_logs:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Heavy`.
	//
	// GET /phone/metrics/past_calls
	ListPastCallMetrics(ctx context.Context, params ListPastCallMetricsParams) (*ListPastCallMetricsOK, error)
	// ListPeeringPhoneNumbers invokes listPeeringPhoneNumbers operation.
	//
	// Returns phone numbers to Zoom through the Provider Exchange.
	// **Note**: Phone peering API and events are for partners who have completed the MoU to peer with
	// Zoom. To become a peering provider/ carrier, submit your [request](https://docs.google.
	// com/forms/d/e/1FAIpQLSewkY6ixVyKVNkWC-vgmejC16gigxsJWXji3dWzE3XlWtjsgg/viewform).
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`,`phone_peering:read:admin`
	// **Granular Scopes:** `phone:read:list_peering_numbers:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /phone/peering/numbers
	ListPeeringPhoneNumbers(ctx context.Context, params ListPeeringPhoneNumbersParams) (*ListPeeringPhoneNumbersOK, error)
	// ListPhoneDevices invokes listPhoneDevices operation.
	//
	// Lists all the [desk phone devices](https://support.zoom.us/hc/en-us/articles/360021119092) that
	// are configured with Zoom Phone on an account.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_devices:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// GET /phone/devices
	ListPhoneDevices(ctx context.Context, params ListPhoneDevicesParams) (*ListPhoneDevicesOK, error)
	// ListPhonePlans invokes listPhonePlans operation.
	//
	// Use this API to return all of an account's Zoom Phone [plan package](https://marketplace.zoom.
	// us/docs/api-reference/other-references/plans#additional-zoom-phone-plans-and-codes), phone number
	// usage and availability.
	// **Prerequisites:**
	// * A Pro or a higher account
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_calling_plans:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /phone/plans
	ListPhonePlans(ctx context.Context) (*ListPhonePlansOK, error)
	// ListPhoneRoles invokes ListPhoneRoles operation.
	//
	// Use this API to get phone roles.
	// **Prerequisites:**
	// * Business or Education account
	// * Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_roles:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /phone/roles
	ListPhoneRoles(ctx context.Context) (*ListPhoneRolesOK, error)
	// ListPhoneSites invokes listPhoneSites operation.
	//
	// Sites allow you to organize Zoom Phone users in your organization. Use this API to list all the
	// [sites](https://support.zoom.us/hc/en-us/articles/360020809672) that have been created for an
	// account.
	// **Prerequisites:**
	// * Multiple Sites must be [enabled](https://support.zoom.
	// us/hc/en-us/articles/360020809672-Managing-Multiple-Sites#h_05c88e35-1593-491f-b1a8-b7139a75dc15).
	// * Pro or a higher account with Zoom Phone enabled.
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_sites:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /phone/sites
	ListPhoneSites(ctx context.Context, params ListPhoneSitesParams) (*ListPhoneSitesOK, error)
	// ListPhoneUsers invokes listPhoneUsers operation.
	//
	// Returns a list of all of an account's users who are assigned a Zoom Phone license.
	// **Prerequisites:**
	// * A Pro or higher account plan
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_users:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// GET /phone/users
	ListPhoneUsers(ctx context.Context, params ListPhoneUsersParams) (*ListPhoneUsersOK, error)
	// ListPortedNumbers invokes listPortedNumbers operation.
	//
	// Use this API to list ported numbers in a Zoom account.
	// **Prerequisites:**
	// * A Pro or higher account plan
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`,`phone_peering:read:admin`
	// **Granular Scopes:** `phone:read:list_ported_numbers:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /phone/ported_numbers/orders
	ListPortedNumbers(ctx context.Context, params ListPortedNumbersParams) (*ListPortedNumbersOK, error)
	// ListRoleMembers invokes ListRoleMembers operation.
	//
	// Use this API to get members (not) in a [role](https://support.zoom.
	// us/hc/en-us/articles/360042099012-Using-Zoom-Phone-role-management).
	// **Prerequisites:**
	// * Business or Education account
	// * Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:role_member:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /phone/roles/{roleId}/members
	ListRoleMembers(ctx context.Context, params ListRoleMembersParams) (*ListRoleMembersOK, error)
	// ListRoutingRule invokes listRoutingRule operation.
	//
	// Returns a list of directory backup routing rules. The directory backup routing rules are a series
	// of predefined Regular Expressions. These rules are used to route outgoing calls. If a dialed
	// number does not match a Zoom Phone user, and does not match a defined External Contact, these
	// rules are tested next. If a dialed number does not match any rules, the call will be routed via
	// the PSTN. **Prerequisites:** * A Business or Enterprise account * A Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_routing_rules:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /phone/routing_rules
	ListRoutingRule(ctx context.Context, params ListRoutingRuleParams) ([]ListRoutingRuleOKItem, error)
	// ListSettingTemplates invokes listSettingTemplates operation.
	//
	// Gets a list of all the created phone template settings.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_setting_templates:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /phone/setting_templates
	ListSettingTemplates(ctx context.Context, params ListSettingTemplatesParams) (*ListSettingTemplatesOK, error)
	// ListSharedLineAppearances invokes listSharedLineAppearances operation.
	//
	// Use this API to list [shared line appearance](https://support.zoom.
	// us/hc/en-us/articles/4406753208461-Enabling-or-disabling-shared-lines-privacy-mode) instances.
	// **Prerequisites:**
	// * Pro or higher account with Zoom Phone license
	// * Account owner or admin privileges
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_shared_line_appearances:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /phone/shared_line_appearances
	ListSharedLineAppearances(ctx context.Context, params ListSharedLineAppearancesParams) (*ListSharedLineAppearancesOK, error)
	// ListSharedLineGroups invokes listSharedLineGroups operation.
	//
	// Lists all the shared line groups. A [shared line group](https://support.zoom.
	// us/hc/en-us/articles/360038850792) allows Zoom Phone admins to share a phone number and extension
	// with a group of phone users or common areas. This capability gives members of the shared line
	// group access to the group's direct phone number and voicemail.
	// **Prerequisites:**
	// * Pro or higher account with Zoom Phone license.
	// * Account owner or admin privileges
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_shared_line_groups:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /phone/shared_line_groups
	ListSharedLineGroups(ctx context.Context, params ListSharedLineGroupsParams) (*ListSharedLineGroupsOK, error)
	// ListSipGroups invokes listSipGroups operation.
	//
	// Use this API to list SIP (Session Initiation Protocol) groups.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_sip_groups:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /phone/sip_groups
	ListSipGroups(ctx context.Context, params ListSipGroupsParams) (*ListSipGroupsOK, error)
	// ListSiteCustomizeOutboundCallerNumbers invokes listSiteCustomizeOutboundCallerNumbers operation.
	//
	// Use this API to retrieve phone numbers that can be used as the `site-level` customized outbound
	// caller ID.
	// * Multiple sites must be [enabled](https://support.zoom.
	// us/hc/en-us/articles/360020809672-Managing-Multiple-Sites#h_05c88e35-1593-491f-b1a8-b7139a75dc15).
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license.
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_site_customized_number:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /phone/sites/{siteId}/outbound_caller_id/customized_numbers
	ListSiteCustomizeOutboundCallerNumbers(ctx context.Context, params ListSiteCustomizeOutboundCallerNumbersParams) (*ListSiteCustomizeOutboundCallerNumbersOK, error)
	// ListSiteOutboundCallingExceptionRule invokes listSiteOutboundCallingExceptionRule operation.
	//
	// Lists site level outbound calling policy exception rules.*
	// **Prerequisite:**
	// * Pro or higher account plan with Zoom phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:site_outbound_calling_rule:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// GET /phone/sites/{siteId}/outbound_calling/exception_rules
	ListSiteOutboundCallingExceptionRule(ctx context.Context, params ListSiteOutboundCallingExceptionRuleParams) (*ListSiteOutboundCallingExceptionRuleOK, error)
	// ListTrackedLocations invokes listTrackedLocations operation.
	//
	// Lists the tracked locations.
	// **Prerequisites:**
	// * Pro or higher account plan with Zoom phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_tracked_locations:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /phone/metrics/location_tracking
	ListTrackedLocations(ctx context.Context, params ListTrackedLocationsParams) (*ListTrackedLocationsOK, error)
	// ListUnassignedZoomRooms invokes listUnassignedZoomRooms operation.
	//
	// Use this API to retrieve [Zoom Rooms](https://support.zoom.us/hc/en-us/articles/360025153711) that
	// are not assigned a Zoom Phone.
	// **Prerequisites:**
	// * A Pro or higher account plan
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_rooms:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /phone/rooms/unassigned
	ListUnassignedZoomRooms(ctx context.Context, params ListUnassignedZoomRoomsParams) (*ListUnassignedZoomRoomsOK, error)
	// ListUserCustomizeOutboundCallerNumbers invokes listUserCustomizeOutboundCallerNumbers operation.
	//
	// Retrieves phone numbers that can be the `user-level` customized outbound caller ID.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license.
	// **Scopes:** `phone:read:admin`,`phone:read`
	// **Granular Scopes:** `phone:read:list_user_customized_number`,
	// `phone:read:list_user_customized_number:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /phone/users/{userId}/outbound_caller_id/customized_numbers
	ListUserCustomizeOutboundCallerNumbers(ctx context.Context, params ListUserCustomizeOutboundCallerNumbersParams) (*ListUserCustomizeOutboundCallerNumbersOK, error)
	// ListUserOutboundCallingExceptionRule invokes listUserOutboundCallingExceptionRule operation.
	//
	// Lists the user level outbound calling policy exception rules.
	// **Prerequisite:**
	// * Pro or higher account plan with Zoom phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:user_outbound_calling_rule:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// GET /phone/users/{userId}/outbound_calling/exception_rules
	ListUserOutboundCallingExceptionRule(ctx context.Context, params ListUserOutboundCallingExceptionRuleParams) (*ListUserOutboundCallingExceptionRuleOK, error)
	// ListUsersFromDirectory invokes ListUsersFromDirectory operation.
	//
	// Use this API to get users that are in or not in a [directory](https://support.zoom.
	// us/hc/en-us/articles/4404938949389-Using-a-dial-by-name-directory).
	// **Prerequisites:**
	// * Business or Education account
	// * Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:directory:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /phone/dial_by_name_directory/extensions
	ListUsersFromDirectory(ctx context.Context, params ListUsersFromDirectoryParams) (*ListUsersFromDirectoryOK, error)
	// ListUsersFromDirectoryBySite invokes ListUsersFromDirectoryBySite operation.
	//
	// Use this API to get users that are in or not in a [directory](https://support.zoom.
	// us/hc/en-us/articles/4404938949389-Using-a-dial-by-name-directory) of the specified site.
	// **Prerequisites:**
	// * Business or Education account
	// * Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:directory:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /phone/sites/{siteId}/dial_by_name_directory/extensions
	ListUsersFromDirectoryBySite(ctx context.Context, params ListUsersFromDirectoryBySiteParams) (*ListUsersFromDirectoryBySiteOK, error)
	// ListZoomPhoneAccountSettings invokes listZoomPhoneAccountSettings operation.
	//
	// Returns an account's Zoom phone settings.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_account_settings:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// GET /phone/account_settings
	ListZoomPhoneAccountSettings(ctx context.Context, params ListZoomPhoneAccountSettingsParams) (*ListZoomPhoneAccountSettingsOK, error)
	// ListZoomRooms invokes listZoomRooms operation.
	//
	// Retrieves a list of [Zoom Rooms](https://support.zoom.us/hc/en-us/articles/360025153711) under the
	// account that has the Zoom Phone license assigned.**Prerequisites:** * A Pro or higher account plan
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:list_rooms:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// GET /phone/rooms
	ListZoomRooms(ctx context.Context, params ListZoomRoomsParams) (*ListZoomRoomsOK, error)
	// MarkPhoneNumberAsBlockedForAllExtensions invokes MarkPhoneNumberAsBlockedForAllExtensions operation.
	//
	// Promotes and applies the phone number blocked from the extension level blocked rule to the account
	// level blocked rule. This action is contingent on the statistics of extensions blocked rule. All
	// extensions under the current account block this phone number.
	// **Prerequisites:**
	// * Pro or higher account plan with Zoom phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:inbound_blocked_for_all:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// PATCH /phone/inbound_blocked/extension_rules/statistics/blocked_for_all
	MarkPhoneNumberAsBlockedForAllExtensions(ctx context.Context, request OptMarkPhoneNumberAsBlockedForAllExtensionsReq) error
	// PhoneDownloadRecordingTranscript invokes phoneDownloadRecordingTranscript operation.
	//
	// Downloads the phone recording transcript.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:read`,`phone:read:admin`,`phone_recording:read`,`phone_recording:read:admin`
	// **Granular Scopes:** `phone:read:recording_transcript`,`phone:read:recording_transcript:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /phone/recording_transcript/download/{recordingId}
	PhoneDownloadRecordingTranscript(ctx context.Context, params PhoneDownloadRecordingTranscriptParams) error
	// PhoneSetting invokes phoneSetting operation.
	//
	// Returns an account's settings.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`
	// **Granular Scopes:** `phone:read:settings:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /phone/settings
	PhoneSetting(ctx context.Context) (*PhoneSettingOK, error)
	// PhoneUser invokes phoneUser operation.
	//
	// Returns a user's [Zoom phone](https://support.zoom.
	// us/hc/en-us/articles/360001297663-Quickstart-Guide-for-Zoom-Phone-Administrators) profile. For
	// user-level apps, pass [the `me` value](https://marketplace.zoom.
	// us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`,`phone:read`
	// **Granular Scopes:** `phone:read:user`,`phone:read:user:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// GET /phone/users/{userId}
	PhoneUser(ctx context.Context, params PhoneUserParams) (*PhoneUserOK, error)
	// PhoneUserCallLogs invokes phoneUserCallLogs operation.
	//
	// Returns a user's [Zoom phone](https://support.zoom.
	// us/hc/en-us/articles/360001297663-Quickstart-Guide-for-Zoom-Phone-Administrators) call logs. For
	// user-level apps, pass [the `me` value](https://marketplace.zoom.
	// us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:read`,`phone:read:admin`,`phone_call_log:read`,`phone_call_log:read:admin`
	// **Granular Scopes:** `phone:read:list_call_logs`,`phone:read:list_call_logs:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// GET /phone/users/{userId}/call_logs
	PhoneUserCallLogs(ctx context.Context, params PhoneUserCallLogsParams) (*PhoneUserCallLogsOK, error)
	// PhoneUserRecordings invokes phoneUserRecordings operation.
	//
	// Gets a user's [Zoom Phone recordings](https://support.zoom.
	// us/hc/en-us/articles/360021336671-Viewing-Call-History-and-Recordings). For user-level apps, pass
	// [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead
	// of the `userId` parameter.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone_recording:read:admin`,`phone_recording:read`,`phone:read`,`phone:read:admin`
	// **Granular Scopes:** `phone:read:list_recordings`,`phone:read:list_recordings:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /phone/users/{userId}/recordings
	PhoneUserRecordings(ctx context.Context, params PhoneUserRecordingsParams) (*PhoneUserRecordingsOK, error)
	// PhoneUserSettings invokes phoneUserSettings operation.
	//
	// Gets the Zoom Phone [profile settings](https://support.zoom.
	// us/hc/en-us/articles/360021325712-Configuring-Settings) of a user. For user-level apps, pass [the
	// `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of
	// the `userId` parameter.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`,`phone:read`
	// **Granular Scopes:** `phone:read:user_setting:admin`,`phone:read:user_setting`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /phone/users/{userId}/settings
	PhoneUserSettings(ctx context.Context, params PhoneUserSettingsParams) (*PhoneUserSettingsOK, error)
	// PhoneUserVoiceMails invokes phoneUserVoiceMails operation.
	//
	// Use this API to get a user's Zoom Phone voicemails. For user-level apps, pass [the `me`
	// value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the
	// `userId` parameter.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:read`,`phone:read:admin`,`phone_voicemail:read:admin`,`phone_voicemail:read`
	// **Granular Scopes:** `phone:read:list_voicemails`,`phone:read:list_voicemails:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /phone/users/{userId}/voice_mails
	PhoneUserVoiceMails(ctx context.Context, params PhoneUserVoiceMailsParams) (*PhoneUserVoiceMailsOK, error)
	// RebootPhoneDevice invokes rebootPhoneDevice operation.
	//
	// Use this API to reboot an online zero-touch or assisted-provisioning device. You can only send one
	// request every second.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions.
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:reboot_device:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Heavy`.
	//
	// POST /phone/devices/{deviceId}/reboot
	RebootPhoneDevice(ctx context.Context, params RebootPhoneDeviceParams) error
	// RemoveCQPolicySubSetting invokes removeCQPolicySubSetting operation.
	//
	// Use this API to remove the policy sub-setting for a specific [call queue](https://support.zoom.
	// us/hc/en-us/articles/360021524831) according to the `policyType`. For example, you can use this
	// API to remove shared access members.
	// **Prerequisites:**
	// * Pro or higher account with Zoom Phone license.
	// * Account owner or admin privileges
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:call_queue_policy:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/call_queues/{callQueueId}/policies/{policyType}
	RemoveCQPolicySubSetting(ctx context.Context, params RemoveCQPolicySubSettingParams) error
	// RemoveGCPMembers invokes removeGCPMembers operation.
	//
	// Use this API to remove member from the [Group Call Pickup](https://support.zoom.
	// us/hc/en-us/articles/360060107472-Setting-up-and-using-group-call-pickup) object.
	// **Prerequisites:**
	// * A Pro or higher account plan
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:call_pickup_group_member:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/group_call_pickup/{groupId}/members/{extensionId}
	RemoveGCPMembers(ctx context.Context, params RemoveGCPMembersParams) error
	// RemoveMember invokes removeMember operation.
	//
	// Use this API to remove a member from a [Monitoring Group](https://support.zoom.
	// us/hc/en-us/articles/360044804711).
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:monitoring_group_member:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/monitoring_groups/{monitoringGroupId}/monitor_members/{memberExtensionId}
	RemoveMember(ctx context.Context, params RemoveMemberParams) error
	// RemoveMembers invokes removeMembers operation.
	//
	// Use this API to remove all monitor or monitored members from a [Monitoring Group](https://support.
	// zoom.us/hc/en-us/articles/360044804711).
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:monitoring_group_member:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/monitoring_groups/{monitoringGroupId}/monitor_members
	RemoveMembers(ctx context.Context, params RemoveMembersParams) error
	// RemoveSLGPolicySubSetting invokes removeSLGPolicySubSetting operation.
	//
	// Removes the policy sub-setting for a specific [shared line group](https://support.zoom.
	// us/hc/en-us/articles/360038850792) according to the `policyType`. For example, you can use this
	// API to remove shared access members. **Prerequisites:** * Pro or higher account with Zoom Phone
	// license.* Account owner or admin privileges
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:shared_line_group_policy:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// DELETE /phone/shared_line_groups/{slgId}/policies/{policyType}
	RemoveSLGPolicySubSetting(ctx context.Context, params RemoveSLGPolicySubSettingParams) error
	// RemoveZoomRoom invokes RemoveZoomRoom operation.
	//
	// Use this API to remove [Zoom Room](https://support.zoom.
	// us/hc/en-us/articles/360025153711#h_140e30ba-5a88-40b9-b799-16883fa0a037) from a Zoom Phone
	// account.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:room:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/rooms/{roomId}
	RemoveZoomRoom(ctx context.Context, params RemoveZoomRoomParams) error
	// SmsByMessageId invokes smsByMessageId operation.
	//
	// Gets details about a specific message in an SMS session.
	// **Prerequisites**
	// * Paid account
	// * User-enabled Zoom phone
	// **Scopes:** `phone:read:admin`,`phone:read`,`phone_sms:read`,`phone_sms:read:admin`
	// **Granular Scopes:** `phone:read:sms_message`,`phone:read:sms_message:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// GET /phone/sms/sessions/{sessionId}/messages/{messageId}
	SmsByMessageId(ctx context.Context, params SmsByMessageIdParams) (*SmsByMessageIdOK, error)
	// SmsSessionDetails invokes smsSessionDetails operation.
	//
	// Get details about an SMS session.
	// **Prerequisites**
	// * Paid account
	// * User-enabled Zoom phone
	// **Scopes:** `phone:read:admin`,`phone:read`,`phone_sms:read`,`phone_sms:read:admin`
	// **Granular Scopes:** `phone:read:sms_session`,`phone:read:sms_session:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /phone/sms/sessions/{sessionId}
	SmsSessionDetails(ctx context.Context, params SmsSessionDetailsParams) (*SmsSessionDetailsOK, error)
	// SmsSessionSync invokes smsSessionSync operation.
	//
	// Use this API to sync SMS messages in a session.
	// **Prerequisites**
	// * Paid account
	// * User-enabled Zoom phone
	// **Scopes:** `phone:read:admin`,`phone:read`,`phone_sms:read`,`phone_sms:read:admin`
	// **Granular Scopes:** `phone:read:sms_session`,`phone:read:sms_session:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /phone/sms/sessions/{sessionId}/sync
	SmsSessionSync(ctx context.Context, params SmsSessionSyncParams) (*SmsSessionSyncOK, error)
	// SyncPhoneDevice invokes syncPhoneDevice operation.
	//
	// Use this API to resync all online zero-touch or assisted-provisioning devices in an account or a
	// site. Only allows sending one request every 15 minutes.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:write:sync_device:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Heavy`.
	//
	// POST /phone/devices/sync
	SyncPhoneDevice(ctx context.Context, request OptSyncPhoneDeviceReq) error
	// SyncUserCallLogs invokes syncUserCallLogs operation.
	//
	// Syncs a user's [Zoom phone](https://support.zoom.
	// us/hc/en-us/articles/360001297663-Quickstart-Guide-for-Zoom-Phone-Administrators) call logs. For
	// user-level apps, pass [the `me` value](https://marketplace.zoom.
	// us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:read:admin`,`phone:read`
	// **Granular Scopes:** `phone:read:list_call_logs`,`phone:read:list_call_logs:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// GET /phone/users/{userId}/call_logs/sync
	SyncUserCallLogs(ctx context.Context, params SyncUserCallLogsParams) (*SyncUserCallLogsOK, error)
	// UnAssignPhoneNumCallQueue invokes unAssignPhoneNumCallQueue operation.
	//
	// After assigning a phone number, you can unbind it if you don't want it to be assigned to a [Call
	// Queue](https://support.zoom.us/hc/en-us/articles/360021524831-Managing-Call-Queues). Use this API
	// to unbind a phone number from a Call Queue. After successful unbinding, the number will appear in
	// the [Unassigned tab](https://zoom.us/signin#/numbers/unassigned).
	// **Prerequisites:**
	// * Pro or higher account palan
	// * Account owner or admin permissions
	// * Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:call_queue_number:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/call_queues/{callQueueId}/phone_numbers/{phoneNumberId}
	UnAssignPhoneNumCallQueue(ctx context.Context, params UnAssignPhoneNumCallQueueParams) error
	// UnassignAPhoneNumAutoReceptionist invokes unassignAPhoneNumAutoReceptionist operation.
	//
	// Unassigns a specific phone number that was previously assigned to an [auto
	// receptionist](https://support.zoom.
	// us/hc/en-us/articles/360021121312-Managing-Auto-Receptionists-and-Interactive-Voice-Response-IVR-).
	// **Prerequisites:**
	// * Pro or higher account plan with Zoom Phone License
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:auto_receptionist_number:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/auto_receptionists/{autoReceptionistId}/phone_numbers/{phoneNumberId}
	UnassignAPhoneNumAutoReceptionist(ctx context.Context, params UnassignAPhoneNumAutoReceptionistParams) error
	// UnassignAPhoneNumCallQueue invokes unassignAPhoneNumCallQueue operation.
	//
	// Use this API to unbind all phone numbers that are assigned to a [Call Queue](https://support.zoom.
	// us/hc/en-us/articles/360021524831-Managing-Call-Queues) After successful unbinding, the numbers
	// will appear in the [Unassigned tab](https://zoom.us/signin#/numbers/unassigned).
	// If you only need to unassign a specific phone number, use the Unassign a Phone Number API instead.
	// **Prerequisites:**
	// * Pro or higher account palan
	// * Account owner or admin permissions
	// * Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:call_queue_number:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/call_queues/{callQueueId}/phone_numbers
	UnassignAPhoneNumCallQueue(ctx context.Context, params UnassignAPhoneNumCallQueueParams) error
	// UnassignAllMembers invokes unassignAllMembers operation.
	//
	// Removes all members from a call queue who were previously assigned to that call queue. The members
	// could be phone users or [common areas](https://support.zoom.us/hc/articles/4481136653709).
	// **Prerequisites:**
	// * Pro or higher account plan.
	// * Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:call_queue_member:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/call_queues/{callQueueId}/members
	UnassignAllMembers(ctx context.Context, params UnassignAllMembersParams) error
	// UnassignAllPhoneNumsAutoReceptionist invokes unassignAllPhoneNumsAutoReceptionist operation.
	//
	// Unassigns all phone numbers that were previously assigned to an [auto
	// receptionist](https://support.zoom.
	// us/hc/en-us/articles/360021121312-Managing-Auto-Receptionists-and-Interactive-Voice-Response-IVR-).
	// **Prerequisites:**
	// * Pro or higher account plan with Zoom Phone License
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:auto_receptionist_number:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// DELETE /phone/auto_receptionists/{autoReceptionistId}/phone_numbers
	UnassignAllPhoneNumsAutoReceptionist(ctx context.Context, params UnassignAllPhoneNumsAutoReceptionistParams) error
	// UnassignCallingPlan invokes unassignCallingPlan operation.
	//
	// Unassigns a a [Zoom Phone](https://support.zoom.us/hc/en-us/categories/360001370051) user's
	// [calling plan](https://marketplace.zoom.
	// us/docs/api-reference/other-references/plans#zoom-phone-calling-plans). For user-level apps, pass
	// [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead
	// of the `userId` parameter.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:write`,`phone:write:admin`
	// **Granular Scopes:** `phone:delete:users_calling_plan`,`phone:delete:users_calling_plan:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/users/{userId}/calling_plans/{type}
	UnassignCallingPlan(ctx context.Context, params UnassignCallingPlanParams) error
	// UnassignCallingPlanFromRoom invokes unassignCallingPlanFromRoom operation.
	//
	// Use this API to unassign a [calling plan](https://marketplace.zoom.
	// us/docs/api-reference/other-references/plans#zoom-phone-calling-plans) from a [Zoom
	// Room](https://support.zoom.
	// us/hc/en-us/articles/360025153711#h_140e30ba-5a88-40b9-b799-16883fa0a037).
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:room_calling_plan:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/rooms/{roomId}/calling_plans/{type}
	UnassignCallingPlanFromRoom(ctx context.Context, params UnassignCallingPlanFromRoomParams) error
	// UnassignCallingPlansFromCommonArea invokes unassignCallingPlansFromCommonArea operation.
	//
	// Use this API to unassign a calling plan from the common area.
	// **Note**: For use by customers who opted for `Common Area Optimization`
	// **Prerequisites:**
	// * A Pro or higher account with a Zoom Phone license
	// * An account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:common_area_calling_plan:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/common_areas/{commonAreaId}/calling_plans/{type}
	UnassignCallingPlansFromCommonArea(ctx context.Context, params UnassignCallingPlansFromCommonAreaParams) error
	// UnassignCampaignPhoneNumber invokes unassignCampaignPhoneNumber operation.
	//
	// Use this API to [unassign a phone number from the SMS campaign](https://support.zoom.
	// us/hc/en-us/articles/5016496738445-SMS-MMS-10DLC-Compliance-for-Zoom-Phone-and-Zoom-Contact-Center#h_01FYVVSPVM8MZN4Y9EW5690QHH).
	// Remove the assigned phone number from the campaign.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// * The campaign must have been previously assigned a Zoom Phone number
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:sms_campaign_number:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/sms_campaigns/{smsCampaignId}/phone_numbers/{phoneNumberId}
	UnassignCampaignPhoneNumber(ctx context.Context, params UnassignCampaignPhoneNumberParams) error
	// UnassignMemberFromCallQueue invokes unassignMemberFromCallQueue operation.
	//
	// Removes a member who was previously added to a call queue. The member could be a phone user or
	// common area. Note that you cannot use this API to unassign a call queue manager.
	// **Prerequisites:**
	// * Pro or higher account plan.
	// * Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:call_queue_member:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/call_queues/{callQueueId}/members/{memberId}
	UnassignMemberFromCallQueue(ctx context.Context, params UnassignMemberFromCallQueueParams) error
	// UnassignPhoneNumber invokes UnassignPhoneNumber operation.
	//
	// Unassigns Zoom Phone user's [phone number](https://support.zoom.
	// us/hc/en-us/articles/360020808292-Managing-Phone-Numbers#h_38ba8b01-26e3-4b1b-a9b5-0717c00a7ca6).
	// After assigning a phone number, you can remove it if you do not want it to be assigned to anyone.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// * The user must have been previously assigned a Zoom Phone number
	// **Scopes:** `phone:write`,`phone:write:admin`
	// **Granular Scopes:** `phone:delete:user_number`,`phone:delete:user_number:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/users/{userId}/phone_numbers/{phoneNumberId}
	UnassignPhoneNumber(ctx context.Context, params UnassignPhoneNumberParams) error
	// UnassignPhoneNumberFromZoomRoom invokes UnassignPhoneNumberFromZoomRoom operation.
	//
	// Use this API to unassign a [phone number](https://support.zoom.
	// us/hc/en-us/articles/360020808292-Managing-Phone-Numbers#h_38ba8b01-26e3-4b1b-a9b5-0717c00a7ca6)
	// from a [Zoom Room](https://support.zoom.
	// us/hc/en-us/articles/360025153711#h_140e30ba-5a88-40b9-b799-16883fa0a037).
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// * The Zoom Room must have been previously assigned a Zoom Phone number
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:room_phone_number:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/rooms/{roomId}/phone_numbers/{phoneNumberId}
	UnassignPhoneNumberFromZoomRoom(ctx context.Context, params UnassignPhoneNumberFromZoomRoomParams) error
	// UnassignPhoneNumbersFromCommonArea invokes unassignPhoneNumbersFromCommonArea operation.
	//
	// Use this API to unassign a phone number from a common area.
	// **Note**: For use by customers who opted for `Common Area Optimization`
	// **Prerequisites:**
	// * A Pro or a higher account with a Zoom Phone license
	// * An account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:delete:common_area_number:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /phone/common_areas/{commonAreaId}/phone_numbers/{phoneNumberId}
	UnassignPhoneNumbersFromCommonArea(ctx context.Context, params UnassignPhoneNumbersFromCommonAreaParams) error
	// UpdateADevice invokes updateADevice operation.
	//
	// Updates the information of a [desk phone device](https://support.zoom.
	// us/hc/en-us/articles/360021119092).
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license* Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:device:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// PATCH /phone/devices/{deviceId}
	UpdateADevice(ctx context.Context, request OptUpdateADeviceReq, params UpdateADeviceParams) error
	// UpdateAccountLevelInboundBlockRule invokes UpdateAccountLevelInboundBlockRule operation.
	//
	// Updates the account level block rule for inbound calls and messaging.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:inbound_block_rule:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// PATCH /phone/inbound_blocked/rules/{blockedRuleId}
	UpdateAccountLevelInboundBlockRule(ctx context.Context, request OptUpdateAccountLevelInboundBlockRuleReq, params UpdateAccountLevelInboundBlockRuleParams) error
	// UpdateAccountOutboundCallingCountriesOrRegions invokes UpdateAccountOutboundCallingCountriesOrRegions operation.
	//
	// Updates the account level outbound calling policy country or region.
	// **Prerequisite:**
	// * Account must have a Pro or a higher plan with a Zoom Phone license.
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:outbound_calling_rule:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// PATCH /phone/outbound_calling/countries_regions
	UpdateAccountOutboundCallingCountriesOrRegions(ctx context.Context, request OptUpdateAccountOutboundCallingCountriesOrRegionsReq) error
	// UpdateAccountOutboundCallingExceptionRule invokes UpdateAccountOutboundCallingExceptionRule operation.
	//
	// Updates the account level outbound calling policy for the country region exception rule.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:outbound_calling_rule:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// PATCH /phone/outbound_calling/exception_rules/{exceptionRuleId}
	UpdateAccountOutboundCallingExceptionRule(ctx context.Context, request OptUpdateAccountOutboundCallingExceptionRuleReq, params UpdateAccountOutboundCallingExceptionRuleParams) error
	// UpdateAnAlertSetting invokes UpdateAnAlertSetting operation.
	//
	// Updates information of an [Alert setting](https://support.zoom.us/hc/en-us/articles/7146944434445).
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:patch:alert_setting:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// PATCH /phone/alert_settings/{alertSettingId}
	UpdateAnAlertSetting(ctx context.Context, request OptUpdateAnAlertSettingReq, params UpdateAnAlertSettingParams) error
	// UpdateAudioItem invokes UpdateAudioItem operation.
	//
	// Updates an audio item. Only the admin or user can update your audio.
	// **Prerequisites:**
	// * Business or Education account
	// * Zoom Phone license
	// **Scopes:** `phone:write`,`phone:write:admin`
	// **Granular Scopes:** `phone:update:audio`,`phone:update:audio:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// PATCH /phone/audios/{audioId}
	UpdateAudioItem(ctx context.Context, request OptUpdateAudioItemReq, params UpdateAudioItemParams) error
	// UpdateAutoDeleteField invokes UpdateAutoDeleteField operation.
	//
	// Updates the auto delete field for recording. It only updates if you enable the **Auto Delete Data
	// After Retention Duration** setting in the account settings for recordings.
	// **Prerequisites:**
	// * User must belong to a Business or Enterprise account
	// * User must have a Zoom Phone license.
	// **Scopes:** `phone:write:admin`,`phone:write`,`phone_recording:write`,`phone_recording:write:admin`
	// **Granular Scopes:** `phone:update:call_recording`,`phone:update:call_recording:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// PATCH /phone/recordings/{recordingId}
	UpdateAutoDeleteField(ctx context.Context, request OptUpdateAutoDeleteFieldReq, params UpdateAutoDeleteFieldParams) error
	// UpdateAutoReceptionist invokes updateAutoReceptionist operation.
	//
	// [Changes information](https://support.zoom.
	// us/hc/en-us/articles/360021121312-Managing-Auto-Receptionists-and-Interactive-Voice-Response-IVR-#h_1d5ffc56-6ba3-4ce5-9d86-4a1a1ee743f3) such as the display name and the extension number assigned to the main auto receptionist.
	// An auto receptionist answers calls with a personalized recording. And it routes calls to a phone
	// user, call queue, common area, or voicemail. An auto receptionist can also be set up so that it
	// routes calls to an interactive voice response (IVR) system to allow callers to select the routing
	// options.
	// **Prerequisites:**
	// * Pro or higher account with Zoom Phone license.
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:auto_receptionist:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// PATCH /phone/auto_receptionists/{autoReceptionistId}
	UpdateAutoReceptionist(ctx context.Context, request OptUpdateAutoReceptionistReq, params UpdateAutoReceptionistParams) error
	// UpdateAutoReceptionistIVR invokes updateAutoReceptionistIVR operation.
	//
	// Updates the [interactive voice response (IVR) system](https://support.zoom.
	// us/hc/en-us/articles/360038601971) of the specified auto receptionist.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:auto_receptionist_ivr:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// PATCH /phone/auto_receptionists/{autoReceptionistId}/ivr
	UpdateAutoReceptionistIVR(ctx context.Context, request OptUpdateAutoReceptionistIVRReq, params UpdateAutoReceptionistIVRParams) error
	// UpdateAutoReceptionistPolicy invokes updateAutoReceptionistPolicy operation.
	//
	// Updates the policy setting of a specific [auto receptionist](https://support.zoom.
	// us/hc/en-us/articles/360021121312-Managing-Auto-Receptionists-and-Interactive-Voice-Response-IVR-).
	// **Prerequisites:**
	// * Pro or higher account plan with Zoom Phone License
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:auto_receptionist_policy:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// PATCH /phone/auto_receptionists/{autoReceptionistId}/policies
	UpdateAutoReceptionistPolicy(ctx context.Context, request OptUpdateAutoReceptionistPolicyReq, params UpdateAutoReceptionistPolicyParams) error
	// UpdateCQPolicySubSetting invokes updateCQPolicySubSetting operation.
	//
	// Use this API to update the policy sub-setting for a specific [call queue](https://support.zoom.
	// us/hc/en-us/articles/360021524831) according to the `policyType`. For example, you can use this
	// API to update shared access members.
	// **Prerequisites:**
	// * Pro or higher account with Zoom Phone license.
	// * Account owner or admin privileges
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:call_queue_policy:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// PATCH /phone/call_queues/{callQueueId}/policies/{policyType}
	UpdateCQPolicySubSetting(ctx context.Context, request OptUpdateCQPolicySubSettingReq, params UpdateCQPolicySubSettingParams) error
	// UpdateCallHandling invokes updateCallHandling operation.
	//
	// Updates a Zoom Phone's call handling setting.
	// Call handling settings allow you to control how your system routes calls during business, closed,
	// or holiday hours. For more information, read our [Call Handling API guide](https://developers.zoom.
	// us/docs/zoom-phone/call-handling/) or Zoom support article [Customizing call handling
	// settings](https://support.zoom.
	// us/hc/en-us/articles/360059966372-Customizing-call-handling-settings).
	// **Applicable to user, call queue, auto receptionist, or shared line group call handling at this
	// time.**
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone enabled
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:call_handling_setting:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// PATCH /phone/extension/{extensionId}/call_handling/settings/{settingType}
	UpdateCallHandling(ctx context.Context, request OptUpdateCallHandlingReq, params UpdateCallHandlingParams) error
	// UpdateCallQueue invokes updateCallQueue operation.
	//
	// Call queues allow you to route incoming calls to a group of users. For instance, you can use call
	// queues to route calls to various departments in your organization such as sales, engineering,
	// billing, customer service etc.
	// Use this API to update information of a specific Call Queue.
	// **Prerequisites:**
	// * Pro, Business, or Education account
	// * Account owner or admin permissions
	// * Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:call_queue:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// PATCH /phone/call_queues/{callQueueId}
	UpdateCallQueue(ctx context.Context, request OptUpdateCallQueueReq, params UpdateCallQueueParams) error
	// UpdateCallingPlan invokes updateCallingPlan operation.
	//
	// Switches [calling plans](https://marketplace.zoom.
	// us/docs/api-reference/other-references/plans#zoom-phone-calling-plans) of a [Zoom
	// Phone](https://support.zoom.us/hc/en-us/categories/360001370051-Zoom-Phone) user. For user-level
	// apps, pass [the `me` value](https://marketplace.zoom.
	// us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`,`phone:write`
	// **Granular Scopes:** `phone:update:calling_plan`,`phone:update:calling_plan:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// PUT /phone/users/{userId}/calling_plans
	UpdateCallingPlan(ctx context.Context, request OptUpdateCallingPlanReq, params UpdateCallingPlanParams) error
	// UpdateCommonArea invokes updateCommonArea operation.
	//
	// Use this API to update the common area information.
	// **Note**: For use by customers who opted for `Common Area Optimization`
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:common_area:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// PATCH /phone/common_areas/{commonAreaId}
	UpdateCommonArea(ctx context.Context, request OptUpdateCommonAreaReq, params UpdateCommonAreaParams) error
	// UpdateCommonAreaOutboundCallingCountriesOrRegions invokes UpdateCommonAreaOutboundCallingCountriesOrRegions operation.
	//
	// Updates the common area level outbound calling policy country or region.
	// **Prerequisite:**
	// * Account must have a Pro or a higher plan with a Zoom Phone license.
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:common_area_outbound_calling_rule:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// PATCH /phone/common_areas/{commonAreaId}/outbound_calling/countries_regions
	UpdateCommonAreaOutboundCallingCountriesOrRegions(ctx context.Context, request OptUpdateCommonAreaOutboundCallingCountriesOrRegionsReq, params UpdateCommonAreaOutboundCallingCountriesOrRegionsParams) error
	// UpdateCommonAreaOutboundCallingExceptionRule invokes UpdateCommonAreaOutboundCallingExceptionRule operation.
	//
	// Updates the common area level outbound calling policy for the country region exception rule.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:common_area_outbound_calling_rule:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// PATCH /phone/common_areas/{commonAreaId}/outbound_calling/exception_rules/{exceptionRuleId}
	UpdateCommonAreaOutboundCallingExceptionRule(ctx context.Context, request OptUpdateCommonAreaOutboundCallingExceptionRuleReq, params UpdateCommonAreaOutboundCallingExceptionRuleParams) error
	// UpdateCommonAreaSetting invokes UpdateCommonAreaSetting operation.
	//
	// Use this API to update the common area setting according to the setting type, specifically for
	// desk phones.
	// **Note**: For use by customers who opted for `Common Area Optimization`
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license.
	// * Account owner or admin permissions.
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:common_area_setting:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// PATCH /phone/common_areas/{commonAreaId}/settings/{settingType}
	UpdateCommonAreaSetting(ctx context.Context, request OptUpdateCommonAreaSettingReq, params UpdateCommonAreaSettingParams) error
	// UpdateEmergencyAddress invokes updateEmergencyAddress operation.
	//
	// Updates an emergency address information. If the address provided is not an exact match, the
	// system generated corrected address will be used.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:emergency_address:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// PATCH /phone/emergency_addresses/{emergencyAddressId}
	UpdateEmergencyAddress(ctx context.Context, request OptUpdateEmergencyAddressReq, params UpdateEmergencyAddressParams) (*UpdateEmergencyAddressOK, error)
	// UpdateExternalContact invokes updateExternalContact operation.
	//
	// Updates an external contact's information.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:external_contact:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// PATCH /phone/external_contacts/{externalContactId}
	UpdateExternalContact(ctx context.Context, request OptUpdateExternalContactReq, params UpdateExternalContactParams) error
	// UpdateFirmwareRule invokes UpdateFirmwareRule operation.
	//
	// Use this API to update a specific [firmware update rule](https://support.zoom.
	// us/hc/en-us/articles/360054198852-Setting-up-firmware-update-rules).
	// **Prerequisites:**
	// * Business, or Education account
	// * Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:firmware_update_rule:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// PATCH /phone/firmware_update_rules/{ruleId}
	UpdateFirmwareRule(ctx context.Context, request OptUpdateFirmwareRuleReq, params UpdateFirmwareRuleParams) error
	// UpdateGCP invokes updateGCP operation.
	//
	// Use this API to update a specific [Group Call Pickup](https://support.zoom.
	// us/hc/en-us/articles/360060107472-Setting-up-and-using-group-call-pickup) object information.
	// **Prerequisites:**
	// * A Pro or higher account plan
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:call_pickup_group:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// PATCH /phone/group_call_pickup/{groupId}
	UpdateGCP(ctx context.Context, request OptUpdateGCPReq, params UpdateGCPParams) error
	// UpdateLocation invokes updateLocation operation.
	//
	// Updates an emergency location's information.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:emergency_location:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// PATCH /phone/locations/{locationId}
	UpdateLocation(ctx context.Context, request OptUpdateLocationReq, params UpdateLocationParams) error
	// UpdateMonitoringGroup invokes updateMonitoringGroup operation.
	//
	// Use this API to update a [Monitoring Group](https://support.zoom.
	// us/hc/en-us/articles/360044804711).
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:monitoring_group:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// PATCH /phone/monitoring_groups/{monitoringGroupId}
	UpdateMonitoringGroup(ctx context.Context, request OptUpdateMonitoringGroupReq, params UpdateMonitoringGroupParams) error
	// UpdatePeeringPhoneNumbers invokes updatePeeringPhoneNumbers operation.
	//
	// Updates phone numbers to Zoom through the Provider Exchange.
	// **Note**: Phone peering API and events are for partners that have completed the MoU to peer with
	// Zoom. To become a peering provider/ carrier, submit your [request](https://docs.google.
	// com/forms/d/e/1FAIpQLSewkY6ixVyKVNkWC-vgmejC16gigxsJWXji3dWzE3XlWtjsgg/viewform).
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`,`phone_peering:write:admin`
	// **Granular Scopes:** `phone:update:peering_number:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// PATCH /phone/peering/numbers
	UpdatePeeringPhoneNumbers(ctx context.Context, request OptUpdatePeeringPhoneNumbersReq) (*UpdatePeeringPhoneNumbersOK, error)
	// UpdatePhoneNumberDetails invokes updatePhoneNumberDetails operation.
	//
	// Updates a Zoom Phone number's information.
	// **Prerequisites:**
	// * A Paid account
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:number:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// PATCH /phone/numbers/{phoneNumberId}
	UpdatePhoneNumberDetails(ctx context.Context, request OptUpdatePhoneNumberDetailsReq, params UpdatePhoneNumberDetailsParams) error
	// UpdatePhoneRole invokes UpdatePhoneRole operation.
	//
	// Use this API to update a role.
	// **Prerequisites:**
	// * Business, or Education account
	// * Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:role:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// PATCH /phone/roles/{roleId}
	UpdatePhoneRole(ctx context.Context, request OptUpdatePhoneRoleReq, params UpdatePhoneRoleParams) error
	// UpdatePhoneSettings invokes updatePhoneSettings operation.
	//
	// Updates Zoom Phone [account settings](https://support.zoom.us/hc/en-us/articles/360025846692).
	// **Prerequisites:**
	// * A Business or Enterprise account
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:settings:admin`.
	//
	// PATCH /phone/settings
	UpdatePhoneSettings(ctx context.Context, request OptUpdatePhoneSettingsReq) error
	// UpdatePolicy invokes updatePolicy operation.
	//
	// Updates the policy subsetting of a specific [auto receptionist](https://support.zoom.
	// us/hc/en-us/articles/360021121312-Managing-Auto-Receptionists-and-Interactive-Voice-Response-IVR-)
	// according to the `policyType`. For example, you can use this API to update shared access members.
	// **Prerequisites:**
	// * Pro or higher account plan with Zoom Phone License
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:auto_receptionist_policy:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// PATCH /phone/auto_receptionists/{autoReceptionistId}/policies/{policyType}
	UpdatePolicy(ctx context.Context, request OptUpdatePolicyReq, params UpdatePolicyParams) error
	// UpdateProvisionTemplate invokes updateProvisionTemplate operation.
	//
	// Use this API to update a [provision template](https://support.zoom.
	// us/hc/en-us/articles/360035817952#h_7b34cd1d-5ae6-4a23-bd04-454a6ad8cb3e) in a Zoom account.
	// **Prerequisites:**
	// * A Pro or higher account plan
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:provision_template:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// PATCH /phone/provision_templates/{templateId}
	UpdateProvisionTemplate(ctx context.Context, request OptUpdateProvisionTemplateReq, params UpdateProvisionTemplateParams) error
	// UpdateProvisionTemplateToDevice invokes updateProvisionTemplateToDevice operation.
	//
	// Use this API to [assign a provision template to a device](https://support.zoom.
	// us/hc/en-us/articles/360035817952#h_6b52ef26-d070-40ed-a3fa-520571944afc) or [remove a provision
	// template from the device](https://support.zoom.
	// us/hc/en-us/articles/360035817952#h_7b34cd1d-5ae6-4a23-bd04-454a6ad8cb3e) by leaving `templateId`
	// empty.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// * [Supported device](https://support.zoom.us/hc/en-us/articles/360029698771#note)
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:device_provision_template:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// PUT /phone/devices/{deviceId}/provision_templates
	UpdateProvisionTemplateToDevice(ctx context.Context, request OptUpdateProvisionTemplateToDeviceReq, params UpdateProvisionTemplateToDeviceParams) error
	// UpdateRecordingStatus invokes UpdateRecordingStatus operation.
	//
	// Updates the status of a single recording in account.
	// **Prerequisites:**
	// * User must belong to a Business or Enterprise account
	// * User must have a Zoom Phone license
	// **Scopes:** `phone:write:admin`,`phone:write`,`phone_recording:write`,`phone_recording:write:admin`
	// **Granular Scopes:** `phone:update:call_recording`,`phone:update:call_recording:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// PUT /phone/recordings/{recordingId}/status
	UpdateRecordingStatus(ctx context.Context, request OptUpdateRecordingStatusReq, params UpdateRecordingStatusParams) error
	// UpdateRoutingRule invokes updateRoutingRule operation.
	//
	// Updates the directory backup routing rule.
	// The directory backup routing rules are a series of predefined regular expressions. These rules are
	// used to route outgoing calls. If a dialed number does not match a Zoom Phone user, and does not
	// match a defined external contact, these rules are tested next. If a dialed number does not match
	// any rules, the call will be routed through the PSTN.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:routing_rule:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// PATCH /phone/routing_rules/{routingRuleId}
	UpdateRoutingRule(ctx context.Context, request OptUpdateRoutingRuleReq, params UpdateRoutingRuleParams) error
	// UpdateSLGPolicySubSetting invokes updateSLGPolicySubSetting operation.
	//
	// Updates the policy sub-setting for a specific [shared line group](https://support.zoom.
	// us/hc/en-us/articles/360038850792) according to the `policyType`. For example, you can use this
	// API to update shared access members.
	// **Prerequisites:**
	// * Pro or higher account with Zoom Phone license.
	// * Account owner or admin privileges
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:shared_line_group_policy:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// PATCH /phone/shared_line_groups/{slgId}/policies/{policyType}
	UpdateSLGPolicySubSetting(ctx context.Context, request OptUpdateSLGPolicySubSettingReq, params UpdateSLGPolicySubSettingParams) error
	// UpdateSettingTemplate invokes updateSettingTemplate operation.
	//
	// Updates or modifies a phone template's settings.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:setting_template:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// PATCH /phone/setting_templates/{templateId}
	UpdateSettingTemplate(ctx context.Context, request OptUpdateSettingTemplateReq, params UpdateSettingTemplateParams) error
	// UpdateSharedLineGroupPolicy invokes updateSharedLineGroupPolicy operation.
	//
	// Updates the policy setting of a specific [shared line group](https://support.zoom.
	// us/hc/en-us/articles/360038850792).
	// **Prerequisites:**
	// * Pro or higher account plan with Zoom Phone License
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:shared_line_group_policy:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// PATCH /phone/shared_line_groups/{sharedLineGroupId}/policies
	UpdateSharedLineGroupPolicy(ctx context.Context, request OptUpdateSharedLineGroupPolicyReq, params UpdateSharedLineGroupPolicyParams) error
	// UpdateSiteDetails invokes updateSiteDetails operation.
	//
	// Updates information about a specific [site](https://support.zoom.
	// us/hc/en-us/articles/360020809672). It allows you to organize Zoom Phone users in your
	// organization.
	// **Prerequisites:**
	// * Account must have a Pro or a higher plan with Zoom Phone license.
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:site:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// PATCH /phone/sites/{siteId}
	UpdateSiteDetails(ctx context.Context, request OptUpdateSiteDetailsReq, params UpdateSiteDetailsParams) error
	// UpdateSiteForUnassignedPhoneNumbers invokes updateSiteForUnassignedPhoneNumbers operation.
	//
	// Updates a site's unassigned [phone numbers](https://support.zoom.
	// us/hc/en-us/articles/360020808292-Managing-Phone-Numbers#h_38ba8b01-26e3-4b1b-a9b5-0717c00a7ca6).
	// Up to 20 phone numbers can be updated in a single request.
	// **Prerequisites:**
	// * A Pro or higher account plan
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:site_number:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// PATCH /phone/numbers/sites/{siteId}
	UpdateSiteForUnassignedPhoneNumbers(ctx context.Context, request OptUpdateSiteForUnassignedPhoneNumbersReq, params UpdateSiteForUnassignedPhoneNumbersParams) error
	// UpdateSiteOutboundCallingCountriesOrRegions invokes UpdateSiteOutboundCallingCountriesOrRegions operation.
	//
	// Updates the site level outbound calling policy country or region.
	// **Prerequisites:**
	// * Account must have a Pro or a higher plan with a Zoom Phone license.
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:site_outbound_calling_rule:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// PATCH /phone/sites/{siteId}/outbound_calling/countries_regions
	UpdateSiteOutboundCallingCountriesOrRegions(ctx context.Context, request OptUpdateSiteOutboundCallingCountriesOrRegionsReq, params UpdateSiteOutboundCallingCountriesOrRegionsParams) error
	// UpdateSiteOutboundCallingExceptionRule invokes UpdateSiteOutboundCallingExceptionRule operation.
	//
	// Updates the site level outbound calling policy for the country region exception rule.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license
	// * Account owner or admin permissions
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:site_outbound_calling_rule:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// PATCH /phone/sites/{siteId}/outbound_calling/exception_rules/{exceptionRuleId}
	UpdateSiteOutboundCallingExceptionRule(ctx context.Context, request OptUpdateSiteOutboundCallingExceptionRuleReq, params UpdateSiteOutboundCallingExceptionRuleParams) error
	// UpdateSiteSetting invokes updateSiteSetting operation.
	//
	// Sites allow you to organize Zoom Phone users in your organization. Use this API to update the site
	// setting of a specific [site](https://support.zoom.us/hc/en-us/articles/360020809672) according to
	// the setting type.
	// **Prerequisites:**
	// * Account must have a Pro or a higher plan with Zoom Phone license.
	// * Multiple sites must be [enabled](https://support.zoom.
	// us/hc/en-us/articles/360020809672-Managing-Multiple-Sites#h_05c88e35-1593-491f-b1a8-b7139a75dc15).
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:site_setting:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// PATCH /phone/sites/{siteId}/settings/{settingType}
	UpdateSiteSetting(ctx context.Context, request OptUpdateSiteSettingReq, params UpdateSiteSettingParams) error
	// UpdateUserOutboundCallingCountriesOrRegions invokes UpdateUserOutboundCallingCountriesOrRegions operation.
	//
	// Updates the user level outbound calling policy country or region.
	// **Prerequisite:**
	// * Account must have a Pro or a higher plan with a Zoom Phone license.
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:user_outbound_calling_rule:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// PATCH /phone/users/{userId}/outbound_calling/countries_regions
	UpdateUserOutboundCallingCountriesOrRegions(ctx context.Context, request OptUpdateUserOutboundCallingCountriesOrRegionsReq, params UpdateUserOutboundCallingCountriesOrRegionsParams) error
	// UpdateUserOutboundCallingExceptionRule invokes UpdateUserOutboundCallingExceptionRule operation.
	//
	// Updates the user level outbound calling policy for the country region exception rule.
	// **Prerequisites:**
	// * Pro or a higher account with Zoom Phone license.
	// * Account owner or admin permissions.
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:user_outbound_calling_rule:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// PATCH /phone/users/{userId}/outbound_calling/exception_rules/{exceptionRuleId}
	UpdateUserOutboundCallingExceptionRule(ctx context.Context, request OptUpdateUserOutboundCallingExceptionRuleReq, params UpdateUserOutboundCallingExceptionRuleParams) error
	// UpdateUserProfile invokes updateUserProfile operation.
	//
	// Updates a user's [Zoom Phone](https://support.zoom.us/hc/en-us/categories/360001370051-Zoom-Phone)
	// profile. For user-level apps, pass [the `me` value](https://marketplace.zoom.
	// us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
	// To add, update or remove the shared access members for voicemail and call recordings, use the
	// [Add](https://marketplace.zoom.
	// us/docs/api-reference/phone/methods#tag/Users/operation/addUserSetting)/[Update](https://marketplace.zoom.us/docs/api-reference/phone/methods#tag/Users/operation/updateUserSetting)/[Delete](https://marketplace.zoom.us/docs/api-reference/phone/methods#tag/Users/operation/deleteUserSetting) a user's shared access setting API.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:write`,`phone:write:admin`
	// **Granular Scopes:** `phone:update:user`,`phone:update:user:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// PATCH /phone/users/{userId}
	UpdateUserProfile(ctx context.Context, request OptUpdateUserProfileReq, params UpdateUserProfileParams) error
	// UpdateUserSetting invokes updateUserSetting operation.
	//
	// Updates the user setting according to the setting type, specifically for delegation, intercom and
	// shared access for voicemail and call recordings. For user-level apps, pass [the `me`
	// value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the
	// `userId` parameter.
	// To see the shared access settings in the Zoom web portal, go to **Admin &gt; Phone System
	// Management &gt; Users &amp; Rooms** . Click **Users** and select **User Policy**. Go to
	// **Voicemail, Automatic Call Recording and Ad Hoc Call Recording**.
	// To view the delegation and intercom setting in your Zoom web portal, navigate to **Admin &gt;
	// Phone System Management &gt; Users &amp; Rooms**. Click the **Users** tab and select **User
	// Settings**
	// **Prerequisites:**
	// * A Business or Enterprise account
	// **Scopes:** `phone:write:admin`,`phone:write`
	// **Granular Scopes:** `phone:update:shared_setting`,`phone:update:shared_setting:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// PATCH /phone/users/{userId}/settings/{settingType}
	UpdateUserSetting(ctx context.Context, request OptUpdateUserSettingReq, params UpdateUserSettingParams) error
	// UpdateUserSettings invokes updateUserSettings operation.
	//
	// Updates the Zoom Phone [profile settings](https://support.zoom.
	// us/hc/en-us/articles/360021325712-Configuring-Settings) of a user. For user-level apps, pass [the
	// `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of
	// the `userId` parameter.
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:write`,`phone:write:admin`
	// **Granular Scopes:** `phone:update:user_setting`,`phone:update:user_setting:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// PATCH /phone/users/{userId}/settings
	UpdateUserSettings(ctx context.Context, request OptUpdateUserSettingsReq, params UpdateUserSettingsParams) error
	// UpdateUsersPropertiesInBatch invokes updateUsersPropertiesInBatch operation.
	//
	// Updates multiple users' properties in batch. For example, you can update the users'
	// [site](https://support.zoom.us/hc/en-us/articles/360020809672) when `batchType` is equal to
	// `move_site`. You can update 10 users at a time.
	// **Prerequisites:**
	// * Business, or Education account
	// * Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:batch_users:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// PUT /phone/users/batch
	UpdateUsersPropertiesInBatch(ctx context.Context, request OptUpdateUsersPropertiesInBatchReq) error
	// UpdateVoicemailReadStatus invokes updateVoicemailReadStatus operation.
	//
	// Updates the status of [voicemail message](https://support.zoom.
	// us/hc/en-us/articles/360021400211-Managing-voicemail-messages).
	// **Prerequisites:**
	// * A Business or Enterprise account
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`,`phone:write`,`phone_voicemail:write`,`phone_voicemail:write:admin`
	// **Granular Scopes:** `phone:update:voicemail`,`phone:update:voicemail:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// PATCH /phone/voice_mails/{voicemailId}
	UpdateVoicemailReadStatus(ctx context.Context, params UpdateVoicemailReadStatusParams) error
	// UpdateZoomRoom invokes updateZoomRoom operation.
	//
	// Use this API to update a [Zoom Room](https://support.zoom.us/hc/en-us/articles/360025153711) in an
	// account that has the Zoom Phone license assigned.
	// **Prerequisites:**
	// * A Pro or higher account plan
	// * A Zoom Phone license
	// **Scopes:** `phone:write:admin`
	// **Granular Scopes:** `phone:update:room:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// PATCH /phone/rooms/{roomId}
	UpdateZoomRoom(ctx context.Context, request OptUpdateZoomRoomReq, params UpdateZoomRoomParams) error
	// UserSmsSession invokes userSmsSession operation.
	//
	// Returns details about SMS sessions for a user.
	// For user-level apps, pass [the `me` value](https://marketplace.zoom.
	// us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
	// **Prerequisites:**
	// * Paid account
	// * User-enabled Zoom phone
	// **Scopes:** `phone:read:admin`,`phone:read`,`phone_sms:read`,`phone_sms:read:admin`
	// **Granular Scopes:** `phone:read:list_sms_sessions`,`phone:read:list_sms_sessions:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// GET /phone/users/{userId}/sms/sessions
	UserSmsSession(ctx context.Context, params UserSmsSessionParams) (*UserSmsSessionOK, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// AccountCallHistory invokes accountCallHistory operation.
//
// Returns an account's new edition [call logs](https://support.zoom.
// us/hc/en-us/articles/360021114452-Viewing-Call-Logs).
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// * Account owner or a [role](https://support.zoom.
// us/hc/en-us/articles/115001078646-Role-Based-Access-Control) with Zoom Phone management
// **Scopes:** `phone:read:admin`,`phone_call_log:read:admin`
// **Granular Scopes:** `phone:read:list_call_logs:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `HEAVY`.
//
// GET /phone/call_history
func (c *Client) AccountCallHistory(ctx context.Context, params AccountCallHistoryParams) (*AccountCallHistoryOK, error) {
	res, err := c.sendAccountCallHistory(ctx, params)
	return res, err
}

func (c *Client) sendAccountCallHistory(ctx context.Context, params AccountCallHistoryParams) (res *AccountCallHistoryOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("accountCallHistory"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/call_history"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AccountCallHistory",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/call_history"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "from" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "from",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.From.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "to" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "to",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.To.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "keyword" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "keyword",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Keyword.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "directions" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "directions",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.Directions != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.Directions {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "connect_types" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "connect_types",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.ConnectTypes != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.ConnectTypes {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "number_types" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "number_types",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.NumberTypes != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.NumberTypes {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "call_types" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "call_types",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.CallTypes != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.CallTypes {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "extension_types" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "extension_types",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.ExtensionTypes != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.ExtensionTypes {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "call_results" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "call_results",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.CallResults != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.CallResults {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "group_ids" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "group_ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.GroupIds != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.GroupIds {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "site_ids" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "site_ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.SiteIds != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.SiteIds {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "department" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "department",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Department.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "cost_center" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cost_center",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CostCenter.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "time_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "time_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.TimeType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "recording_status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "recording_status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.RecordingStatus.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AccountCallHistory", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AccountCallHistory", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAccountCallHistoryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AccountCallLogs invokes accountCallLogs operation.
//
// Returns an account's [call logs](https://support.zoom.
// us/hc/en-us/articles/360021114452-Viewing-Call-Logs).
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// * Account owner or a [role](https://support.zoom.
// us/hc/en-us/articles/115001078646-Role-Based-Access-Control) with Zoom Phone management
// **Scopes:** `phone:read:admin`,`phone_call_log:read:admin`
// **Granular Scopes:** `phone:read:list_call_logs:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `HEAVY`.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /phone/call_logs
func (c *Client) AccountCallLogs(ctx context.Context, params AccountCallLogsParams) (*AccountCallLogsOK, error) {
	res, err := c.sendAccountCallLogs(ctx, params)
	return res, err
}

func (c *Client) sendAccountCallLogs(ctx context.Context, params AccountCallLogsParams) (res *AccountCallLogsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("accountCallLogs"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/call_logs"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AccountCallLogs",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/call_logs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "from" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "from",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.From.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "to" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "to",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.To.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "path" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "path",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Path.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "time_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "time_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.TimeType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "site_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "site_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SiteID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "charged_call_logs" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "charged_call_logs",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ChargedCallLogs.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AccountCallLogs", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AccountCallLogs", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAccountCallLogsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AccountSmsSession invokes accountSmsSession operation.
//
// Returns details about SMS sessions for an account.
// **Prerequisites**
// * Paid account
// * User-enabled Zoom phone
// **Scopes:** `phone:read:admin`,`phone_sms:read:admin`,`phone_sms:read`
// **Granular Scopes:** `phone:read:list_sms_sessions`,`phone:read:list_sms_sessions:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// GET /phone/sms/sessions
func (c *Client) AccountSmsSession(ctx context.Context, params AccountSmsSessionParams) (*AccountSmsSessionOK, error) {
	res, err := c.sendAccountSmsSession(ctx, params)
	return res, err
}

func (c *Client) sendAccountSmsSession(ctx context.Context, params AccountSmsSessionParams) (res *AccountSmsSessionOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("accountSmsSession"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/sms/sessions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AccountSmsSession",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/sms/sessions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "from" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "from",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.From.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "to" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "to",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.To.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "session_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "session_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SessionType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "phone_number" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "phone_number",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PhoneNumber.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AccountSmsSession", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AccountSmsSession", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAccountSmsSessionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AccountVoiceMails invokes accountVoiceMails operation.
//
// Use this API to get a user's Zoom Phone voicemails.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`,`phone_voicemail:read:admin`
// **Granular Scopes:** `phone:read:list_voicemails:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Heavy`.
//
// GET /phone/voice_mails
func (c *Client) AccountVoiceMails(ctx context.Context, params AccountVoiceMailsParams) (*AccountVoiceMailsOK, error) {
	res, err := c.sendAccountVoiceMails(ctx, params)
	return res, err
}

func (c *Client) sendAccountVoiceMails(ctx context.Context, params AccountVoiceMailsParams) (res *AccountVoiceMailsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("accountVoiceMails"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/voice_mails"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AccountVoiceMails",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/voice_mails"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Status.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "site_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "site_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SiteID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "owner_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "owner_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OwnerType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "voicemail_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "voicemail_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.VoicemailType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "from" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "from",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.From.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "to" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "to",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.To.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AccountVoiceMails", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AccountVoiceMails", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAccountVoiceMailsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActiveCRPhoneNumbers invokes activeCRPhoneNumbers operation.
//
// Use this API to change phone number status to 'active' in a carrier reseller's master account. Up
// to 200 numbers at a time.
// **Prerequisites:**
// * A Pro or higher account plan
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:carrier_number:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// PATCH /phone/carrier_reseller/numbers
func (c *Client) ActiveCRPhoneNumbers(ctx context.Context, request []string) error {
	_, err := c.sendActiveCRPhoneNumbers(ctx, request)
	return err
}

func (c *Client) sendActiveCRPhoneNumbers(ctx context.Context, request []string) (res *ActiveCRPhoneNumbersNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activeCRPhoneNumbers"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/carrier_reseller/numbers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActiveCRPhoneNumbers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/carrier_reseller/numbers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActiveCRPhoneNumbersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ActiveCRPhoneNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ActiveCRPhoneNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActiveCRPhoneNumbersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddAccountLevelInboundBlockRules invokes AddAccountLevelInboundBlockRules operation.
//
// Adds an account level block rule for inbound calls and messaging from a phone number. As a result,
// all extensions block calls and messages to the phone number.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:inbound_block_rule:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// POST /phone/inbound_blocked/rules
func (c *Client) AddAccountLevelInboundBlockRules(ctx context.Context, request OptAddAccountLevelInboundBlockRulesReq) (*AddAccountLevelInboundBlockRulesCreated, error) {
	res, err := c.sendAddAccountLevelInboundBlockRules(ctx, request)
	return res, err
}

func (c *Client) sendAddAccountLevelInboundBlockRules(ctx context.Context, request OptAddAccountLevelInboundBlockRulesReq) (res *AddAccountLevelInboundBlockRulesCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("AddAccountLevelInboundBlockRules"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/inbound_blocked/rules"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddAccountLevelInboundBlockRules",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/inbound_blocked/rules"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddAccountLevelInboundBlockRulesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddAccountLevelInboundBlockRules", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddAccountLevelInboundBlockRules", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddAccountLevelInboundBlockRulesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddAccountOutboundCallingExceptionRule invokes AddAccountOutboundCallingExceptionRule operation.
//
// Adds the account level outbound calling policy exception rule for country region.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:outbound_calling_rule:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// POST /phone/outbound_calling/exception_rules
func (c *Client) AddAccountOutboundCallingExceptionRule(ctx context.Context, request OptAddAccountOutboundCallingExceptionRuleReq) (*AddAccountOutboundCallingExceptionRuleCreated, error) {
	res, err := c.sendAddAccountOutboundCallingExceptionRule(ctx, request)
	return res, err
}

func (c *Client) sendAddAccountOutboundCallingExceptionRule(ctx context.Context, request OptAddAccountOutboundCallingExceptionRuleReq) (res *AddAccountOutboundCallingExceptionRuleCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("AddAccountOutboundCallingExceptionRule"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/outbound_calling/exception_rules"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddAccountOutboundCallingExceptionRule",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/outbound_calling/exception_rules"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddAccountOutboundCallingExceptionRuleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddAccountOutboundCallingExceptionRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddAccountOutboundCallingExceptionRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddAccountOutboundCallingExceptionRuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddAnAlertSetting invokes AddAnAlertSetting operation.
//
// [Adds an alert setting](https://support.zoom.us/hc/en-us/articles/7146944434445).
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:alert_setting:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// POST /phone/alert_settings
func (c *Client) AddAnAlertSetting(ctx context.Context, request OptAddAnAlertSettingReq) (*AddAnAlertSettingCreated, error) {
	res, err := c.sendAddAnAlertSetting(ctx, request)
	return res, err
}

func (c *Client) sendAddAnAlertSetting(ctx context.Context, request OptAddAnAlertSettingReq) (res *AddAnAlertSettingCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("AddAnAlertSetting"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/alert_settings"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddAnAlertSetting",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/alert_settings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddAnAlertSettingRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddAnAlertSetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddAnAlertSetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddAnAlertSettingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddAnAudio invokes AddAnAudio operation.
//
// Adds an audio item for [text-to-speech conversion](https://support.zoom.
// us/hc/en-us/articles/4402414203533-Using-the-audio-library-to-customize-audio#h_01F8B0D2ZJBKEDH10DFZ7J2CM7). Only the admin or user can add your audio and directly pass the `me` value instead of the `userId` parameter.
// **Prerequisites:**
// * Business or Education account
// * Zoom Phone license
// **Scopes:** `phone:write`,`phone:write:admin`
// **Granular Scopes:** `phone:write:audio`,`phone:write:audio:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// POST /phone/users/{userId}/audios
func (c *Client) AddAnAudio(ctx context.Context, request OptAddAnAudioReq, params AddAnAudioParams) (*AddAnAudioCreated, error) {
	res, err := c.sendAddAnAudio(ctx, request, params)
	return res, err
}

func (c *Client) sendAddAnAudio(ctx context.Context, request OptAddAnAudioReq, params AddAnAudioParams) (res *AddAnAudioCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("AddAnAudio"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/users/{userId}/audios"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddAnAudio",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/audios"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddAnAudioRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddAnAudio", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddAnAudio", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddAnAudioResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddAnumberToBlockedList invokes addAnumberToBlockedList operation.
//
// A Zoom account owner or a user with the admin privilege can block phone numbers for phone users in
// an account. Blocked numbers can be inbound (numbers will be blocked from calling in) and outbound
// (phone users in your account won't be able to dial those numbers). Blocked callers will hear a
// generic message stating that the person they are calling is not available. Use this API to create
// a block list and add a number to the list.
// **Prerequisites:**
// * Pro or higher account plan with Zoom phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:blocked_list:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/blocked_list
func (c *Client) AddAnumberToBlockedList(ctx context.Context, request OptAddAnumberToBlockedListReq) (*AddAnumberToBlockedListCreated, error) {
	res, err := c.sendAddAnumberToBlockedList(ctx, request)
	return res, err
}

func (c *Client) sendAddAnumberToBlockedList(ctx context.Context, request OptAddAnumberToBlockedListReq) (res *AddAnumberToBlockedListCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addAnumberToBlockedList"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/blocked_list"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddAnumberToBlockedList",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/blocked_list"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddAnumberToBlockedListRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddAnumberToBlockedList", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddAnumberToBlockedList", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddAnumberToBlockedListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddAudioItem invokes AddAudioItem operation.
//
// Adds the audio items. You can only upload voice files at this time. Only the admin or user can add
// your audio and directly pass the `me` value instead of the `userId` parameter.
// **Prerequisites:**
// * Business or Education account
// * Zoom Phone license
// **Size and quantity limits for audio attachments:**
// * Up to 5 attachments
// * Each file size should be no more than 1MB
// **Scopes:** `phone:write`,`phone:write:admin`
// **Granular Scopes:** `phone:write:batch_audios`,`phone:write:batch_audios:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `HEAVY`.
//
// POST /phone/users/{userId}/audios/batch
func (c *Client) AddAudioItem(ctx context.Context, request OptAddAudioItemReq, params AddAudioItemParams) (*AddAudioItemCreated, error) {
	res, err := c.sendAddAudioItem(ctx, request, params)
	return res, err
}

func (c *Client) sendAddAudioItem(ctx context.Context, request OptAddAudioItemReq, params AddAudioItemParams) (res *AddAudioItemCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("AddAudioItem"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/users/{userId}/audios/batch"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddAudioItem",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/audios/batch"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddAudioItemRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddAudioItem", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddAudioItem", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddAudioItemResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddAutoReceptionist invokes addAutoReceptionist operation.
//
// Adds an [auto receptionist](https://support.zoom.
// us/hc/en-us/articles/360021121312-Managing-Auto-Receptionists-and-Interactive-Voice-Response-IVR-)
// to a Zoom Phone. Auto receptionists answer calls with a personalized recording and routes calls to
// a phone user, call queue, common area, voicemail or an IVR system.
// **Prerequisites:**
// * Pro or higher account with Zoom Phone license.
// * Account owner or admin privileges
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:auto_receptionist:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/auto_receptionists
func (c *Client) AddAutoReceptionist(ctx context.Context, request OptAddAutoReceptionistReq) (*AddAutoReceptionistCreated, error) {
	res, err := c.sendAddAutoReceptionist(ctx, request)
	return res, err
}

func (c *Client) sendAddAutoReceptionist(ctx context.Context, request OptAddAutoReceptionistReq) (res *AddAutoReceptionistCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addAutoReceptionist"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/auto_receptionists"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddAutoReceptionist",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/auto_receptionists"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddAutoReceptionistRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddAutoReceptionist", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddAutoReceptionist", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddAutoReceptionistResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddBYOCNumber invokes addBYOCNumber operation.
//
// Use this API to add BYOC (Bring Your Own Carrier) phone numbers to Zoom Phone.
// **Prerequisites:**
// * A Business or Enterprise plan
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:byo_carrier_number:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/byoc_numbers
func (c *Client) AddBYOCNumber(ctx context.Context, request OptAddBYOCNumberReq) (*AddBYOCNumberCreated, error) {
	res, err := c.sendAddBYOCNumber(ctx, request)
	return res, err
}

func (c *Client) sendAddBYOCNumber(ctx context.Context, request OptAddBYOCNumberReq) (res *AddBYOCNumberCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addBYOCNumber"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/byoc_numbers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddBYOCNumber",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/byoc_numbers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddBYOCNumberRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddBYOCNumber", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddBYOCNumber", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddBYOCNumberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddCQPolicySubSetting invokes addCQPolicySubSetting operation.
//
// Use this API to add the policy sub-setting for a specific [call queue](https://support.zoom.
// us/hc/en-us/articles/360021524831) according to the `policyType`. For example, you can use this
// API to set up shared access members.
// **Prerequisites:**
// * Pro or higher account with Zoom Phone license.
// * Account owner or admin privileges
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:call_queue_policy:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/call_queues/{callQueueId}/policies/{policyType}
func (c *Client) AddCQPolicySubSetting(ctx context.Context, request OptAddCQPolicySubSettingReq, params AddCQPolicySubSettingParams) (*AddCQPolicySubSettingCreated, error) {
	res, err := c.sendAddCQPolicySubSetting(ctx, request, params)
	return res, err
}

func (c *Client) sendAddCQPolicySubSetting(ctx context.Context, request OptAddCQPolicySubSettingReq, params AddCQPolicySubSettingParams) (res *AddCQPolicySubSettingCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addCQPolicySubSetting"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/call_queues/{callQueueId}/policies/{policyType}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddCQPolicySubSetting",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/call_queues/"
	{
		// Encode "callQueueId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "callQueueId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallQueueId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/policies/"
	{
		// Encode "policyType" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "policyType",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PolicyType))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddCQPolicySubSettingRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddCQPolicySubSetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddCQPolicySubSetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddCQPolicySubSettingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddCallHandling invokes addCallHandling operation.
//
// Adds Zoom Phone call handling subsettings for your phone system. Call handling settings allow you
// to control how your system routes calls during business, closed, or holiday hours. For more
// information, see our [API guide](https://marketplace.zoom.
// us/docs/guides/zoom-phone/call-handling/) or Zoom support article [Customizing call handling
// settings](https://support.zoom.
// us/hc/en-us/articles/360059966372-Customizing-call-handling-settings).
// **Applicable to user, call queue, auto receptionist, or shared line group call handling at this
// time.**
// **Prerequisites:**
// * A Pro or a higher account with Zoom Phone enabled
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:call_handling_setting:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// POST /phone/extension/{extensionId}/call_handling/settings/{settingType}
func (c *Client) AddCallHandling(ctx context.Context, request OptAddCallHandlingReq, params AddCallHandlingParams) (AddCallHandlingCreated, error) {
	res, err := c.sendAddCallHandling(ctx, request, params)
	return res, err
}

func (c *Client) sendAddCallHandling(ctx context.Context, request OptAddCallHandlingReq, params AddCallHandlingParams) (res AddCallHandlingCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addCallHandling"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/extension/{extensionId}/call_handling/settings/{settingType}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddCallHandling",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/extension/"
	{
		// Encode "extensionId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "extensionId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ExtensionId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/call_handling/settings/"
	{
		// Encode "settingType" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "settingType",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SettingType))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddCallHandlingRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddCallHandling", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddCallHandling", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddCallHandlingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddClientCodeToCallLog invokes addClientCodeToCallLog operation.
//
// Adds a client code to a [call log](https://support.zoom.
// us/hc/en-us/articles/360040999352-Assigning-client-codes-to-phone-calls). You can track call logs
// with a client code.
// **Prerequisites:**
// * Business, or Education account
// * Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:call_log:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// PUT /phone/call_logs/{callLogId}/client_code
func (c *Client) AddClientCodeToCallLog(ctx context.Context, request OptAddClientCodeToCallLogReq, params AddClientCodeToCallLogParams) error {
	_, err := c.sendAddClientCodeToCallLog(ctx, request, params)
	return err
}

func (c *Client) sendAddClientCodeToCallLog(ctx context.Context, request OptAddClientCodeToCallLogReq, params AddClientCodeToCallLogParams) (res *AddClientCodeToCallLogNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addClientCodeToCallLog"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/phone/call_logs/{callLogId}/client_code"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddClientCodeToCallLog",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/call_logs/"
	{
		// Encode "callLogId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "callLogId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallLogId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/client_code"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddClientCodeToCallLogRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddClientCodeToCallLog", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddClientCodeToCallLog", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddClientCodeToCallLogResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddCommonArea invokes addCommonArea operation.
//
// Use this API to add an instance of common area. Configure devices shared by users and deployed in
// shared spaces.
// **Note**: For use by customers who opted for `Common Area Optimization`
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:common_area:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/common_areas
func (c *Client) AddCommonArea(ctx context.Context, request OptAddCommonAreaReq) (*AddCommonAreaCreated, error) {
	res, err := c.sendAddCommonArea(ctx, request)
	return res, err
}

func (c *Client) sendAddCommonArea(ctx context.Context, request OptAddCommonAreaReq) (res *AddCommonAreaCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addCommonArea"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/common_areas"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddCommonArea",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/common_areas"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddCommonAreaRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddCommonArea", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddCommonArea", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddCommonAreaResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddCommonAreaOutboundCallingExceptionRule invokes AddCommonAreaOutboundCallingExceptionRule operation.
//
// Adds the common area level outbound calling policy exception rule for the country region.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:common_area_outbound_calling_rule:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// POST /phone/common_areas/{commonAreaId}/outbound_calling/exception_rules
func (c *Client) AddCommonAreaOutboundCallingExceptionRule(ctx context.Context, request OptAddCommonAreaOutboundCallingExceptionRuleReq, params AddCommonAreaOutboundCallingExceptionRuleParams) (*AddCommonAreaOutboundCallingExceptionRuleCreated, error) {
	res, err := c.sendAddCommonAreaOutboundCallingExceptionRule(ctx, request, params)
	return res, err
}

func (c *Client) sendAddCommonAreaOutboundCallingExceptionRule(ctx context.Context, request OptAddCommonAreaOutboundCallingExceptionRuleReq, params AddCommonAreaOutboundCallingExceptionRuleParams) (res *AddCommonAreaOutboundCallingExceptionRuleCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("AddCommonAreaOutboundCallingExceptionRule"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/common_areas/{commonAreaId}/outbound_calling/exception_rules"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddCommonAreaOutboundCallingExceptionRule",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/common_areas/"
	{
		// Encode "commonAreaId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "commonAreaId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CommonAreaId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/outbound_calling/exception_rules"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddCommonAreaOutboundCallingExceptionRuleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddCommonAreaOutboundCallingExceptionRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddCommonAreaOutboundCallingExceptionRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddCommonAreaOutboundCallingExceptionRuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddCommonAreaSetting invokes AddCommonAreaSetting operation.
//
// Use this API to add the common area setting according to the setting type, specifically for desk
// phones.
// **Note**: For use by customers who opted for `Common Area Optimization`
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license.
// * Account owner or admin permissions.
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:common_area_setting:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/common_areas/{commonAreaId}/settings/{settingType}
func (c *Client) AddCommonAreaSetting(ctx context.Context, request OptAddCommonAreaSettingReq, params AddCommonAreaSettingParams) (*AddCommonAreaSettingCreated, error) {
	res, err := c.sendAddCommonAreaSetting(ctx, request, params)
	return res, err
}

func (c *Client) sendAddCommonAreaSetting(ctx context.Context, request OptAddCommonAreaSettingReq, params AddCommonAreaSettingParams) (res *AddCommonAreaSettingCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("AddCommonAreaSetting"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/common_areas/{commonAreaId}/settings/{settingType}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddCommonAreaSetting",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/common_areas/"
	{
		// Encode "commonAreaId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "commonAreaId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CommonAreaId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/settings/"
	{
		// Encode "settingType" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "settingType",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SettingType))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddCommonAreaSettingRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddCommonAreaSetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddCommonAreaSetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddCommonAreaSettingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddEmergencyAddress invokes addEmergencyAddress operation.
//
// Adds an emergency address. If the address provided is not an exact match, the system generated
// corrected address will be used.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:emergency_address:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/emergency_addresses
func (c *Client) AddEmergencyAddress(ctx context.Context, request OptAddEmergencyAddressReq) (*AddEmergencyAddressCreated, error) {
	res, err := c.sendAddEmergencyAddress(ctx, request)
	return res, err
}

func (c *Client) sendAddEmergencyAddress(ctx context.Context, request OptAddEmergencyAddressReq) (res *AddEmergencyAddressCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addEmergencyAddress"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/emergency_addresses"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddEmergencyAddress",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/emergency_addresses"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddEmergencyAddressRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddEmergencyAddress", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddEmergencyAddress", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddEmergencyAddressResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddExtensionsToADevice invokes addExtensionsToADevice operation.
//
// By default, all Zoom Phone users can make and receive calls using the Zoom desktop and mobile
// applications. Additionally, if a desk phone is required, use this API to [add a desk phone and
// assign it to a user](https://support.zoom.
// us/hc/en-us/articles/360021119092#h_5ca07504-68a8-4c3d-ad0e-c1d3594436da).
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// * [Supported device](https://support.zoom.
// us/hc/en-us/articles/360001299063-Zoom-Voice-Supported-Devices)
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:device_extension:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/devices/{deviceId}/extensions
func (c *Client) AddExtensionsToADevice(ctx context.Context, request OptAddExtensionsToADeviceReq, params AddExtensionsToADeviceParams) (jx.Raw, error) {
	res, err := c.sendAddExtensionsToADevice(ctx, request, params)
	return res, err
}

func (c *Client) sendAddExtensionsToADevice(ctx context.Context, request OptAddExtensionsToADeviceReq, params AddExtensionsToADeviceParams) (res jx.Raw, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addExtensionsToADevice"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/devices/{deviceId}/extensions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddExtensionsToADevice",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/devices/"
	{
		// Encode "deviceId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "deviceId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DeviceId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/extensions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddExtensionsToADeviceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddExtensionsToADevice", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddExtensionsToADevice", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddExtensionsToADeviceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddExtensiontLevelInboundBlockRules invokes AddExtensiontLevelInboundBlockRules operation.
//
// Adds the given extension's block rule for inbound calls and messaging.
// It adds the inbound block rule for the given Call Queue, Auto Receptionist, Shared Line Group,
// Common Area, Zoom Room or User.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// **Scopes:** `phone:write:admin`,`phone:write`
// **Granular Scopes:** `phone:write:extension_inbound_block_rule:admin`,
// `phone:write:extension_inbound_block_rule`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// POST /phone/extension/{extensionId}/inbound_blocked/rules
func (c *Client) AddExtensiontLevelInboundBlockRules(ctx context.Context, request OptAddExtensiontLevelInboundBlockRulesReq, params AddExtensiontLevelInboundBlockRulesParams) (*AddExtensiontLevelInboundBlockRulesCreated, error) {
	res, err := c.sendAddExtensiontLevelInboundBlockRules(ctx, request, params)
	return res, err
}

func (c *Client) sendAddExtensiontLevelInboundBlockRules(ctx context.Context, request OptAddExtensiontLevelInboundBlockRulesReq, params AddExtensiontLevelInboundBlockRulesParams) (res *AddExtensiontLevelInboundBlockRulesCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("AddExtensiontLevelInboundBlockRules"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/extension/{extensionId}/inbound_blocked/rules"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddExtensiontLevelInboundBlockRules",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/extension/"
	{
		// Encode "extensionId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "extensionId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ExtensionId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/inbound_blocked/rules"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddExtensiontLevelInboundBlockRulesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddExtensiontLevelInboundBlockRules", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddExtensiontLevelInboundBlockRules", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddExtensiontLevelInboundBlockRulesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddExternalContact invokes addExternalContact operation.
//
// Adds an external contact.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:external_contact:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/external_contacts
func (c *Client) AddExternalContact(ctx context.Context, request OptAddExternalContactReq) (*AddExternalContactCreated, error) {
	res, err := c.sendAddExternalContact(ctx, request)
	return res, err
}

func (c *Client) sendAddExternalContact(ctx context.Context, request OptAddExternalContactReq) (res *AddExternalContactCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addExternalContact"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/external_contacts"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddExternalContact",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/external_contacts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddExternalContactRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddExternalContact", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddExternalContact", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddExternalContactResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddFirmwareRule invokes AddFirmwareRule operation.
//
// Use this API to add a [firmware update rule](https://support.zoom.
// us/hc/en-us/articles/360054198852-Setting-up-firmware-update-rules).
// **Prerequisites:**
// * Business, or Education account
// * Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:firmware_update_rule:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/firmware_update_rules
func (c *Client) AddFirmwareRule(ctx context.Context, request OptAddFirmwareRuleReq) (*AddFirmwareRuleCreated, error) {
	res, err := c.sendAddFirmwareRule(ctx, request)
	return res, err
}

func (c *Client) sendAddFirmwareRule(ctx context.Context, request OptAddFirmwareRuleReq) (res *AddFirmwareRuleCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("AddFirmwareRule"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/firmware_update_rules"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddFirmwareRule",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/firmware_update_rules"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddFirmwareRuleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddFirmwareRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddFirmwareRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddFirmwareRuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddGCP invokes addGCP operation.
//
// Use this API to add a [Group Call Pickup](https://support.zoom.
// us/hc/en-us/articles/360060107472-Setting-up-and-using-group-call-pickup) instance to the account
// that has the Zoom Phone license assigned.
// **Prerequisites:**
// * A Pro or higher account plan
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:call_pickup_group:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/group_call_pickup
func (c *Client) AddGCP(ctx context.Context, request OptAddGCPReq) (*AddGCPCreated, error) {
	res, err := c.sendAddGCP(ctx, request)
	return res, err
}

func (c *Client) sendAddGCP(ctx context.Context, request OptAddGCPReq) (res *AddGCPCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addGCP"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/group_call_pickup"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddGCP",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/group_call_pickup"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddGCPRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddGCP", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddGCP", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddGCPResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddGCPMembers invokes addGCPMembers operation.
//
// Use this API to add members to the specified [Group Call Pickup](https://support.zoom.
// us/hc/en-us/articles/360060107472-Setting-up-and-using-group-call-pickup) object.
// **Prerequisites:**
// * A Pro or higher account plan
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:call_pickup_group_member:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/group_call_pickup/{groupId}/members
func (c *Client) AddGCPMembers(ctx context.Context, request OptAddGCPMembersReq, params AddGCPMembersParams) error {
	_, err := c.sendAddGCPMembers(ctx, request, params)
	return err
}

func (c *Client) sendAddGCPMembers(ctx context.Context, request OptAddGCPMembersReq, params AddGCPMembersParams) (res *AddGCPMembersCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addGCPMembers"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/group_call_pickup/{groupId}/members"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddGCPMembers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/group_call_pickup/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddGCPMembersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddGCPMembers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddGCPMembers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddGCPMembersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddLocation invokes addLocation operation.
//
// Adds an emergency service location.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:emergency_location:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/locations
func (c *Client) AddLocation(ctx context.Context, request OptAddLocationReq) (*AddLocationCreated, error) {
	res, err := c.sendAddLocation(ctx, request)
	return res, err
}

func (c *Client) sendAddLocation(ctx context.Context, request OptAddLocationReq) (res *AddLocationCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addLocation"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/locations"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddLocation",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/locations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddLocationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddLocation", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddLocation", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddLocationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddMembers invokes addMembers operation.
//
// Use this API to add members to a [Monitoring Group](https://support.zoom.
// us/hc/en-us/articles/360044804711).
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:monitoring_group_member:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/monitoring_groups/{monitoringGroupId}/monitor_members
func (c *Client) AddMembers(ctx context.Context, request []string, params AddMembersParams) (jx.Raw, error) {
	res, err := c.sendAddMembers(ctx, request, params)
	return res, err
}

func (c *Client) sendAddMembers(ctx context.Context, request []string, params AddMembersParams) (res jx.Raw, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addMembers"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/monitoring_groups/{monitoringGroupId}/monitor_members"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddMembers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/monitoring_groups/"
	{
		// Encode "monitoringGroupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "monitoringGroupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.MonitoringGroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/monitor_members"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "member_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "member_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.MemberType))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddMembersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddMembers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddMembers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddMembersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddMembersToCallQueue invokes addMembersToCallQueue operation.
//
// Add phone users and/or [common areas](https://support.zoom.us/hc/articles/4481136653709) as
// members to a specific call queue.
// **Prerequisites:**
// * Pro or higher account plan.
// * Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:call_queue_member:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/call_queues/{callQueueId}/members
func (c *Client) AddMembersToCallQueue(ctx context.Context, request OptAddMembersToCallQueueReq, params AddMembersToCallQueueParams) error {
	_, err := c.sendAddMembersToCallQueue(ctx, request, params)
	return err
}

func (c *Client) sendAddMembersToCallQueue(ctx context.Context, request OptAddMembersToCallQueueReq, params AddMembersToCallQueueParams) (res *AddMembersToCallQueueCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addMembersToCallQueue"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/call_queues/{callQueueId}/members"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddMembersToCallQueue",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/call_queues/"
	{
		// Encode "callQueueId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "callQueueId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallQueueId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddMembersToCallQueueRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddMembersToCallQueue", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddMembersToCallQueue", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddMembersToCallQueueResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddMembersToSharedLineGroup invokes addMembersToSharedLineGroup operation.
//
// [Adds members](https://support.zoom.
// us/hc/en-us/articles/360038850792-Setting-up-shared-line-groups#h_7cb42370-48f6-4a8f-84f4-c6eee4d9f0ca) to a shared line group. A [shared line group](https://support.zoom.us/hc/en-us/articles/360038850792) allows Zoom Phone admins to share a phone number and extension with a group of phone users or common areas. This gives members of the shared line group access to the group's direct phone number and voicemail.  Note that a member can only be added to one shared line group.
// **Prerequisites:**
// * Pro or higher account with Zoom Phone license.
// * A valid Shared Line Group
// * Account owner or admin privileges
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:shared_line_member:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// POST /phone/shared_line_groups/{sharedLineGroupId}/members
func (c *Client) AddMembersToSharedLineGroup(ctx context.Context, request OptAddMembersToSharedLineGroupReq, params AddMembersToSharedLineGroupParams) error {
	_, err := c.sendAddMembersToSharedLineGroup(ctx, request, params)
	return err
}

func (c *Client) sendAddMembersToSharedLineGroup(ctx context.Context, request OptAddMembersToSharedLineGroupReq, params AddMembersToSharedLineGroupParams) (res *AddMembersToSharedLineGroupCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addMembersToSharedLineGroup"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/shared_line_groups/{sharedLineGroupId}/members"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddMembersToSharedLineGroup",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/shared_line_groups/"
	{
		// Encode "sharedLineGroupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sharedLineGroupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SharedLineGroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddMembersToSharedLineGroupRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddMembersToSharedLineGroup", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddMembersToSharedLineGroup", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddMembersToSharedLineGroupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddOutboundCallerNumbers invokes addOutboundCallerNumbers operation.
//
// Adds the `account-level` customized outbound caller ID phone numbers. Note that when multiple
// sites policy is enabled, users cannot manage the `account-level` configuration. The system will
// throw an exception.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license.
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:customized_number:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/outbound_caller_id/customized_numbers
func (c *Client) AddOutboundCallerNumbers(ctx context.Context, request OptAddOutboundCallerNumbersReq) (jx.Raw, error) {
	res, err := c.sendAddOutboundCallerNumbers(ctx, request)
	return res, err
}

func (c *Client) sendAddOutboundCallerNumbers(ctx context.Context, request OptAddOutboundCallerNumbersReq) (res jx.Raw, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addOutboundCallerNumbers"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/outbound_caller_id/customized_numbers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddOutboundCallerNumbers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/outbound_caller_id/customized_numbers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddOutboundCallerNumbersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddOutboundCallerNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddOutboundCallerNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddOutboundCallerNumbersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddPeeringPhoneNumbers invokes addPeeringPhoneNumbers operation.
//
// Adds phone numbers to Zoom through the Provider Exchange.
// **Note**: Phone peering API and events are for partners who have completed the MoU to peer with
// Zoom. To become a peering provider/ carrier, submit your [request](https://docs.google.
// com/forms/d/e/1FAIpQLSewkY6ixVyKVNkWC-vgmejC16gigxsJWXji3dWzE3XlWtjsgg/viewform).
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`,`phone_peering:write:admin`
// **Granular Scopes:** `phone:write:peering_number:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/peering/numbers
func (c *Client) AddPeeringPhoneNumbers(ctx context.Context, request OptAddPeeringPhoneNumbersReq) (*AddPeeringPhoneNumbersCreated, error) {
	res, err := c.sendAddPeeringPhoneNumbers(ctx, request)
	return res, err
}

func (c *Client) sendAddPeeringPhoneNumbers(ctx context.Context, request OptAddPeeringPhoneNumbersReq) (res *AddPeeringPhoneNumbersCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addPeeringPhoneNumbers"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/peering/numbers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddPeeringPhoneNumbers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/peering/numbers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddPeeringPhoneNumbersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddPeeringPhoneNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddPeeringPhoneNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddPeeringPhoneNumbersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddPhoneDevice invokes addPhoneDevice operation.
//
// [Adda a desk phone and assigns it](https://support.zoom.
// us/hc/en-us/articles/360021119092#h_5ca07504-68a8-4c3d-ad0e-c1d3594436da) to a user, if a desk
// phone is required.
// By default, all Zoom Phone users can make and receive calls using the Zoom desktop and mobile
// applications.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// * [Supported device](https://support.zoom.
// us/hc/en-us/articles/360001299063-Zoom-Voice-Supported-Devices)
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:device:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// POST /phone/devices
func (c *Client) AddPhoneDevice(ctx context.Context, request OptAddPhoneDeviceReq) (*AddPhoneDeviceCreated, error) {
	res, err := c.sendAddPhoneDevice(ctx, request)
	return res, err
}

func (c *Client) sendAddPhoneDevice(ctx context.Context, request OptAddPhoneDeviceReq) (res *AddPhoneDeviceCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addPhoneDevice"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/devices"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddPhoneDevice",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/devices"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddPhoneDeviceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddPhoneDevice", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddPhoneDevice", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddPhoneDeviceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddPolicy invokes AddPolicy operation.
//
// Adds a policy subsetting for a specific [auto receptionist](https://support.zoom.
// us/hc/en-us/articles/360021121312-Managing-Auto-Receptionists-and-Interactive-Voice-Response-IVR-)
// according to the `policyType`. For example, you can use this API to set up shared access members.
// <br><br>**Prerequisites:**
// * Pro or higher account plan with Zoom Phone License
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:auto_receptionist_policy:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// POST /phone/auto_receptionists/{autoReceptionistId}/policies/{policyType}
func (c *Client) AddPolicy(ctx context.Context, request OptAddPolicyReq, params AddPolicyParams) (*AddPolicyCreated, error) {
	res, err := c.sendAddPolicy(ctx, request, params)
	return res, err
}

func (c *Client) sendAddPolicy(ctx context.Context, request OptAddPolicyReq, params AddPolicyParams) (res *AddPolicyCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("AddPolicy"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/auto_receptionists/{autoReceptionistId}/policies/{policyType}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddPolicy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/auto_receptionists/"
	{
		// Encode "autoReceptionistId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "autoReceptionistId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AutoReceptionistId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/policies/"
	{
		// Encode "policyType" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "policyType",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PolicyType))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddPolicyRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddPolicy", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddPolicy", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddPolicyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddProvisionTemplate invokes addProvisionTemplate operation.
//
// Use this API to [create a provision template](https://support.zoom.
// us/hc/en-us/articles/360035817952#h_8266cb40-58fc-4c1a-8da2-885d72167234) in a Zoom account.
// **Prerequisites:**
// * A Pro or higher account plan
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:provision_template:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/provision_templates
func (c *Client) AddProvisionTemplate(ctx context.Context, request OptAddProvisionTemplateReq) (*AddProvisionTemplateCreated, error) {
	res, err := c.sendAddProvisionTemplate(ctx, request)
	return res, err
}

func (c *Client) sendAddProvisionTemplate(ctx context.Context, request OptAddProvisionTemplateReq) (res *AddProvisionTemplateCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addProvisionTemplate"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/provision_templates"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddProvisionTemplate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/provision_templates"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddProvisionTemplateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddProvisionTemplate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddProvisionTemplate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddProvisionTemplateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddRoleMembers invokes AddRoleMembers operation.
//
// Use this API to add members to [roles](https://support.zoom.
// us/hc/en-us/articles/360042099012-Using-Zoom-Phone-role-management#h_01EFHY1R4QWAYTA6Z661NM9Q27).
// **Prerequisites:**
// * Business or Education account
// * Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:role_member:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/roles/{roleId}/members
func (c *Client) AddRoleMembers(ctx context.Context, request OptAddRoleMembersReq, params AddRoleMembersParams) error {
	_, err := c.sendAddRoleMembers(ctx, request, params)
	return err
}

func (c *Client) sendAddRoleMembers(ctx context.Context, request OptAddRoleMembersReq, params AddRoleMembersParams) (res *AddRoleMembersCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("AddRoleMembers"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/roles/{roleId}/members"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddRoleMembers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/roles/"
	{
		// Encode "roleId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "roleId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddRoleMembersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddRoleMembers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddRoleMembers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddRoleMembersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddRoutingRule invokes addRoutingRule operation.
//
// Creates a directory backup routing rule.
// The directory backup routing rules are a series of predefined regular expressions. These rules are
// used to route outgoing calls. If a dialed number does not match a Zoom Phone user, and does not
// match a defined external contact, these rules are tested next. If a dialed number does not match
// any rules, the call will be routed through the PSTN.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:routing_rule:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/routing_rules
func (c *Client) AddRoutingRule(ctx context.Context, request OptAddRoutingRuleReq) (*AddRoutingRuleCreated, error) {
	res, err := c.sendAddRoutingRule(ctx, request)
	return res, err
}

func (c *Client) sendAddRoutingRule(ctx context.Context, request OptAddRoutingRuleReq) (res *AddRoutingRuleCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addRoutingRule"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/routing_rules"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddRoutingRule",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/routing_rules"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddRoutingRuleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddRoutingRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddRoutingRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddRoutingRuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddSLGPolicySubSetting invokes addSLGPolicySubSetting operation.
//
// Adds the policy sub-setting for a specific [shared line group](https://support.zoom.
// us/hc/en-us/articles/360038850792) according to the `policyType`. For example, you can use this
// API to set up shared access members. **Prerequisites:** * Pro or higher account with Zoom Phone
// license.* Account owner or admin privileges
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:shared_line_group_policy:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// POST /phone/shared_line_groups/{slgId}/policies/{policyType}
func (c *Client) AddSLGPolicySubSetting(ctx context.Context, request OptAddSLGPolicySubSettingReq, params AddSLGPolicySubSettingParams) (*AddSLGPolicySubSettingCreated, error) {
	res, err := c.sendAddSLGPolicySubSetting(ctx, request, params)
	return res, err
}

func (c *Client) sendAddSLGPolicySubSetting(ctx context.Context, request OptAddSLGPolicySubSettingReq, params AddSLGPolicySubSettingParams) (res *AddSLGPolicySubSettingCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addSLGPolicySubSetting"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/shared_line_groups/{slgId}/policies/{policyType}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddSLGPolicySubSetting",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/shared_line_groups/"
	{
		// Encode "slgId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "slgId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SlgId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/policies/"
	{
		// Encode "policyType" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "policyType",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PolicyType))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddSLGPolicySubSettingRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddSLGPolicySubSetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddSLGPolicySubSetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddSLGPolicySubSettingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddSettingTemplate invokes addSettingTemplate operation.
//
// Creates a Zoom Phone setting template for an account. After creating a phone template, the defined
// settings will become the default settings for an account.
// **Prerequisites:**
// * A Business or enterprise Zoom account
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:setting_template:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/setting_templates
func (c *Client) AddSettingTemplate(ctx context.Context, request OptAddSettingTemplateReq) (*AddSettingTemplateCreated, error) {
	res, err := c.sendAddSettingTemplate(ctx, request)
	return res, err
}

func (c *Client) sendAddSettingTemplate(ctx context.Context, request OptAddSettingTemplateReq) (res *AddSettingTemplateCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addSettingTemplate"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/setting_templates"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddSettingTemplate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/setting_templates"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddSettingTemplateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddSettingTemplate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddSettingTemplate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddSettingTemplateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddSiteOutboundCallerNumbers invokes addSiteOutboundCallerNumbers operation.
//
// Use this API to add the `site-level` customized outbound caller ID phone numbers.
// * Multiple sites must be [enabled](https://support.zoom.
// us/hc/en-us/articles/360020809672-Managing-Multiple-Sites#h_05c88e35-1593-491f-b1a8-b7139a75dc15).
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license.
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:site_customized_number:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/sites/{siteId}/outbound_caller_id/customized_numbers
func (c *Client) AddSiteOutboundCallerNumbers(ctx context.Context, request OptAddSiteOutboundCallerNumbersReq, params AddSiteOutboundCallerNumbersParams) (jx.Raw, error) {
	res, err := c.sendAddSiteOutboundCallerNumbers(ctx, request, params)
	return res, err
}

func (c *Client) sendAddSiteOutboundCallerNumbers(ctx context.Context, request OptAddSiteOutboundCallerNumbersReq, params AddSiteOutboundCallerNumbersParams) (res jx.Raw, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addSiteOutboundCallerNumbers"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/sites/{siteId}/outbound_caller_id/customized_numbers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddSiteOutboundCallerNumbers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/sites/"
	{
		// Encode "siteId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "siteId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SiteId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/outbound_caller_id/customized_numbers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddSiteOutboundCallerNumbersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddSiteOutboundCallerNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddSiteOutboundCallerNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddSiteOutboundCallerNumbersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddSiteOutboundCallingExceptionRule invokes AddSiteOutboundCallingExceptionRule operation.
//
// Adds the site level outbound calling policy exception rule for the country region.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:site_outbound_calling_rule:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// POST /phone/sites/{siteId}/outbound_calling/exception_rules
func (c *Client) AddSiteOutboundCallingExceptionRule(ctx context.Context, request OptAddSiteOutboundCallingExceptionRuleReq, params AddSiteOutboundCallingExceptionRuleParams) (*AddSiteOutboundCallingExceptionRuleCreated, error) {
	res, err := c.sendAddSiteOutboundCallingExceptionRule(ctx, request, params)
	return res, err
}

func (c *Client) sendAddSiteOutboundCallingExceptionRule(ctx context.Context, request OptAddSiteOutboundCallingExceptionRuleReq, params AddSiteOutboundCallingExceptionRuleParams) (res *AddSiteOutboundCallingExceptionRuleCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("AddSiteOutboundCallingExceptionRule"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/sites/{siteId}/outbound_calling/exception_rules"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddSiteOutboundCallingExceptionRule",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/sites/"
	{
		// Encode "siteId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "siteId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SiteId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/outbound_calling/exception_rules"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddSiteOutboundCallingExceptionRuleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddSiteOutboundCallingExceptionRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddSiteOutboundCallingExceptionRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddSiteOutboundCallingExceptionRuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddSiteSetting invokes addSiteSetting operation.
//
// Sites allow you to organize Zoom Phone users in your organization. Use this API to add a site
// setting to a specific [site](https://support.zoom.us/hc/en-us/articles/360020809672) according to
// the setting type.
// **Prerequisites:**
// * Account must have a Pro or a higher plan with Zoom Phone license.
// * Multiple sites must be [enabled](https://support.zoom.
// us/hc/en-us/articles/360020809672-Managing-Multiple-Sites#h_05c88e35-1593-491f-b1a8-b7139a75dc15).
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:site_setting:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/sites/{siteId}/settings/{settingType}
func (c *Client) AddSiteSetting(ctx context.Context, request OptAddSiteSettingReq, params AddSiteSettingParams) (*AddSiteSettingCreated, error) {
	res, err := c.sendAddSiteSetting(ctx, request, params)
	return res, err
}

func (c *Client) sendAddSiteSetting(ctx context.Context, request OptAddSiteSettingReq, params AddSiteSettingParams) (res *AddSiteSettingCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addSiteSetting"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/sites/{siteId}/settings/{settingType}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddSiteSetting",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/sites/"
	{
		// Encode "siteId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "siteId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SiteId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/settings/"
	{
		// Encode "settingType" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "settingType",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SettingType))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddSiteSettingRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddSiteSetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddSiteSetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddSiteSettingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddUserOutboundCallerNumbers invokes addUserOutboundCallerNumbers operation.
//
// Adds users' customized outbound caller ID phone numbers.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license.
// **Scopes:** `phone:write:admin`,`phone:write`
// **Granular Scopes:** `phone:write:user_customized_number`,
// `phone:write:user_customized_number:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/users/{userId}/outbound_caller_id/customized_numbers
func (c *Client) AddUserOutboundCallerNumbers(ctx context.Context, request OptAddUserOutboundCallerNumbersReq, params AddUserOutboundCallerNumbersParams) (jx.Raw, error) {
	res, err := c.sendAddUserOutboundCallerNumbers(ctx, request, params)
	return res, err
}

func (c *Client) sendAddUserOutboundCallerNumbers(ctx context.Context, request OptAddUserOutboundCallerNumbersReq, params AddUserOutboundCallerNumbersParams) (res jx.Raw, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addUserOutboundCallerNumbers"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/users/{userId}/outbound_caller_id/customized_numbers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddUserOutboundCallerNumbers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/outbound_caller_id/customized_numbers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddUserOutboundCallerNumbersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddUserOutboundCallerNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddUserOutboundCallerNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddUserOutboundCallerNumbersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddUserOutboundCallingExceptionRule invokes AddUserOutboundCallingExceptionRule operation.
//
// Adds an user level outbound calling policy exception rule for the country region.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:user_outbound_calling_rule:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// POST /phone/users/{userId}/outbound_calling/exception_rules
func (c *Client) AddUserOutboundCallingExceptionRule(ctx context.Context, request OptAddUserOutboundCallingExceptionRuleReq, params AddUserOutboundCallingExceptionRuleParams) (*AddUserOutboundCallingExceptionRuleCreated, error) {
	res, err := c.sendAddUserOutboundCallingExceptionRule(ctx, request, params)
	return res, err
}

func (c *Client) sendAddUserOutboundCallingExceptionRule(ctx context.Context, request OptAddUserOutboundCallingExceptionRuleReq, params AddUserOutboundCallingExceptionRuleParams) (res *AddUserOutboundCallingExceptionRuleCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("AddUserOutboundCallingExceptionRule"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/users/{userId}/outbound_calling/exception_rules"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddUserOutboundCallingExceptionRule",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/outbound_calling/exception_rules"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddUserOutboundCallingExceptionRuleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddUserOutboundCallingExceptionRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddUserOutboundCallingExceptionRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddUserOutboundCallingExceptionRuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddUserSetting invokes addUserSetting operation.
//
// Adds the user setting according to the setting type, specifically for delegation, intercom and
// shared access for voicemail, and call recordings. For user-level apps, pass [the `me`
// value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the
// `userId` parameter.
// To see the shared access settings in the Zoom web portal, go to **Admin &gt; Phone System
// Management &gt; Users &amp; Rooms** . Click **Users** and select **User Policy**. Go to
// **Voicemail, Automatic Call Recording and Ad Hoc Call Recording**.
// To view the delegation and intercom setting in your Zoom web portal, navigate to **Admin &gt;
// Phone System Management &gt; Users &amp; Rooms**. Click the **Users** tab and select **User
// Settings**
// **Prerequisites:**
// * A Business or Enterprise account
// **Scopes:** `phone:write:admin`,`phone:write`
// **Granular Scopes:** `phone:write:shared_setting`,`phone:write:shared_setting:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/users/{userId}/settings/{settingType}
func (c *Client) AddUserSetting(ctx context.Context, request OptAddUserSettingReq, params AddUserSettingParams) (*AddUserSettingCreated, error) {
	res, err := c.sendAddUserSetting(ctx, request, params)
	return res, err
}

func (c *Client) sendAddUserSetting(ctx context.Context, request OptAddUserSettingReq, params AddUserSettingParams) (res *AddUserSettingCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addUserSetting"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/users/{userId}/settings/{settingType}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddUserSetting",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/settings/"
	{
		// Encode "settingType" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "settingType",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SettingType))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddUserSettingRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddUserSetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddUserSetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddUserSettingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddUsersToDirectory invokes AddUsersToDirectory operation.
//
// Use this API to add users to a [directory](https://support.zoom.
// us/hc/en-us/articles/4404938949389-Using-a-dial-by-name-directory).
// **Prerequisites:**
// * Business or Education account
// * Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:directory:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/dial_by_name_directory/extensions
func (c *Client) AddUsersToDirectory(ctx context.Context, request OptAddUsersToDirectoryReq) error {
	_, err := c.sendAddUsersToDirectory(ctx, request)
	return err
}

func (c *Client) sendAddUsersToDirectory(ctx context.Context, request OptAddUsersToDirectoryReq) (res *AddUsersToDirectoryCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("AddUsersToDirectory"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/dial_by_name_directory/extensions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddUsersToDirectory",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/dial_by_name_directory/extensions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddUsersToDirectoryRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddUsersToDirectory", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddUsersToDirectory", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddUsersToDirectoryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddUsersToDirectoryBySite invokes AddUsersToDirectoryBySite operation.
//
// Use this API to add users to a [directory](https://support.zoom.
// us/hc/en-us/articles/4404938949389-Using-a-dial-by-name-directory) of the specified site.
// **Prerequisites:**
// * Business or Education account
// * Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:directory:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/sites/{siteId}/dial_by_name_directory/extensions
func (c *Client) AddUsersToDirectoryBySite(ctx context.Context, request OptAddUsersToDirectoryBySiteReq, params AddUsersToDirectoryBySiteParams) error {
	_, err := c.sendAddUsersToDirectoryBySite(ctx, request, params)
	return err
}

func (c *Client) sendAddUsersToDirectoryBySite(ctx context.Context, request OptAddUsersToDirectoryBySiteReq, params AddUsersToDirectoryBySiteParams) (res *AddUsersToDirectoryBySiteCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("AddUsersToDirectoryBySite"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/sites/{siteId}/dial_by_name_directory/extensions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddUsersToDirectoryBySite",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/sites/"
	{
		// Encode "siteId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "siteId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SiteId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/dial_by_name_directory/extensions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddUsersToDirectoryBySiteRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddUsersToDirectoryBySite", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddUsersToDirectoryBySite", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddUsersToDirectoryBySiteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddZoomRoom invokes addZoomRoom operation.
//
// Use this API to associate a [Zoom Room](https://support.zoom.
// us/hc/en-us/articles/360025153711#h_70c74c57-50d6-406b-a4fa-2f33d4bebdbc) with a Zoom Phone
// license.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:room:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/rooms
func (c *Client) AddZoomRoom(ctx context.Context, request OptAddZoomRoomReq) (jx.Raw, error) {
	res, err := c.sendAddZoomRoom(ctx, request)
	return res, err
}

func (c *Client) sendAddZoomRoom(ctx context.Context, request OptAddZoomRoomReq) (res jx.Raw, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addZoomRoom"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/rooms"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddZoomRoom",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/rooms"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddZoomRoomRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AddZoomRoom", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AddZoomRoom", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddZoomRoomResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AssignCallingPlan invokes assignCallingPlan operation.
//
// Assigns a [calling plan](https://marketplace.zoom.
// us/docs/api-reference/other-references/plans#zoom-phone-calling-plans) to a [Zoom
// Phone](https://support.zoom.us/hc/en-us/categories/360001370051-Zoom-Phone) user. For user-level
// apps, pass [the `me` value](https://marketplace.zoom.
// us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`,`phone:write`
// **Granular Scopes:** `phone:write:calling_plan`,`phone:write:calling_plan:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/users/{userId}/calling_plans
func (c *Client) AssignCallingPlan(ctx context.Context, request OptAssignCallingPlanReq, params AssignCallingPlanParams) (jx.Raw, error) {
	res, err := c.sendAssignCallingPlan(ctx, request, params)
	return res, err
}

func (c *Client) sendAssignCallingPlan(ctx context.Context, request OptAssignCallingPlanReq, params AssignCallingPlanParams) (res jx.Raw, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("assignCallingPlan"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/users/{userId}/calling_plans"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AssignCallingPlan",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/calling_plans"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAssignCallingPlanRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AssignCallingPlan", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AssignCallingPlan", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAssignCallingPlanResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AssignCallingPlanToRoom invokes assignCallingPlanToRoom operation.
//
// Use this API to assign [calling plans](https://marketplace.zoom.
// us/docs/api-reference/other-references/plans#zoom-phone-calling-plans) to a [Zoom
// Room](https://support.zoom.
// us/hc/en-us/articles/360025153711#h_70c74c57-50d6-406b-a4fa-2f33d4bebdbc). Up to 200 numbers at a
// time.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:room_calling_plan:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/rooms/{roomId}/calling_plans
func (c *Client) AssignCallingPlanToRoom(ctx context.Context, request OptAssignCallingPlanToRoomReq, params AssignCallingPlanToRoomParams) (jx.Raw, error) {
	res, err := c.sendAssignCallingPlanToRoom(ctx, request, params)
	return res, err
}

func (c *Client) sendAssignCallingPlanToRoom(ctx context.Context, request OptAssignCallingPlanToRoomReq, params AssignCallingPlanToRoomParams) (res jx.Raw, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("assignCallingPlanToRoom"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/rooms/{roomId}/calling_plans"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AssignCallingPlanToRoom",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/rooms/"
	{
		// Encode "roomId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "roomId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoomId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/calling_plans"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAssignCallingPlanToRoomRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AssignCallingPlanToRoom", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AssignCallingPlanToRoom", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAssignCallingPlanToRoomResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AssignCallingPlansToCommonArea invokes assignCallingPlansToCommonArea operation.
//
// Use this API to assign calling plans to a common area.
// **Note**: For use by customers who opted for `Common Area Optimization`
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license.
// * Account owner or admin permissions.
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:common_area_calling_plan:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/common_areas/{commonAreaId}/calling_plans
func (c *Client) AssignCallingPlansToCommonArea(ctx context.Context, request OptAssignCallingPlansToCommonAreaReq, params AssignCallingPlansToCommonAreaParams) (*AssignCallingPlansToCommonAreaCreated, error) {
	res, err := c.sendAssignCallingPlansToCommonArea(ctx, request, params)
	return res, err
}

func (c *Client) sendAssignCallingPlansToCommonArea(ctx context.Context, request OptAssignCallingPlansToCommonAreaReq, params AssignCallingPlansToCommonAreaParams) (res *AssignCallingPlansToCommonAreaCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("assignCallingPlansToCommonArea"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/common_areas/{commonAreaId}/calling_plans"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AssignCallingPlansToCommonArea",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/common_areas/"
	{
		// Encode "commonAreaId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "commonAreaId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CommonAreaId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/calling_plans"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAssignCallingPlansToCommonAreaRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AssignCallingPlansToCommonArea", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AssignCallingPlansToCommonArea", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAssignCallingPlansToCommonAreaResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AssignCampaignPhoneNumbers invokes assignCampaignPhoneNumbers operation.
//
// Use this API to [assign a phone number to the SMS campaign](https://support.zoom.
// us/hc/en-us/articles/5016496738445-SMS-MMS-10DLC-Compliance-for-Zoom-Phone-and-Zoom-Contact-Center#h_01FYVVQM1WMW5JD48YNY3J581B).
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:sms_campaign_number:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/sms_campaigns/{smsCampaignId}/phone_numbers
func (c *Client) AssignCampaignPhoneNumbers(ctx context.Context, request OptAssignCampaignPhoneNumbersReq, params AssignCampaignPhoneNumbersParams) (*AssignCampaignPhoneNumbersCreated, error) {
	res, err := c.sendAssignCampaignPhoneNumbers(ctx, request, params)
	return res, err
}

func (c *Client) sendAssignCampaignPhoneNumbers(ctx context.Context, request OptAssignCampaignPhoneNumbersReq, params AssignCampaignPhoneNumbersParams) (res *AssignCampaignPhoneNumbersCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("assignCampaignPhoneNumbers"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/sms_campaigns/{smsCampaignId}/phone_numbers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AssignCampaignPhoneNumbers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/sms_campaigns/"
	{
		// Encode "smsCampaignId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "smsCampaignId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SmsCampaignId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/phone_numbers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAssignCampaignPhoneNumbersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AssignCampaignPhoneNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AssignCampaignPhoneNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAssignCampaignPhoneNumbersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AssignPhoneNumber invokes assignPhoneNumber operation.
//
// Assigns a [phone number](https://support.zoom.
// us/hc/en-us/articles/360020808292-Managing-Phone-Numbers) to a user who has already enabled Zoom
// Phone.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:write`,`phone:write:admin`
// **Granular Scopes:** `phone:write:user_number`,`phone:write:user_number:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/users/{userId}/phone_numbers
func (c *Client) AssignPhoneNumber(ctx context.Context, request OptAssignPhoneNumberReq, params AssignPhoneNumberParams) (*AssignPhoneNumberOK, error) {
	res, err := c.sendAssignPhoneNumber(ctx, request, params)
	return res, err
}

func (c *Client) sendAssignPhoneNumber(ctx context.Context, request OptAssignPhoneNumberReq, params AssignPhoneNumberParams) (res *AssignPhoneNumberOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("assignPhoneNumber"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/users/{userId}/phone_numbers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AssignPhoneNumber",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/phone_numbers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAssignPhoneNumberRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AssignPhoneNumber", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AssignPhoneNumber", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAssignPhoneNumberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AssignPhoneNumberToZoomRoom invokes assignPhoneNumberToZoomRoom operation.
//
// Use this API to [assign phone numbers to a Zoom Room](https://support.zoom.
// us/hc/en-us/articles/360025153711). Up to 200 numbers at a time.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:room_phone_number:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/rooms/{roomId}/phone_numbers
func (c *Client) AssignPhoneNumberToZoomRoom(ctx context.Context, request OptAssignPhoneNumberToZoomRoomReq, params AssignPhoneNumberToZoomRoomParams) (jx.Raw, error) {
	res, err := c.sendAssignPhoneNumberToZoomRoom(ctx, request, params)
	return res, err
}

func (c *Client) sendAssignPhoneNumberToZoomRoom(ctx context.Context, request OptAssignPhoneNumberToZoomRoomReq, params AssignPhoneNumberToZoomRoomParams) (res jx.Raw, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("assignPhoneNumberToZoomRoom"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/rooms/{roomId}/phone_numbers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AssignPhoneNumberToZoomRoom",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/rooms/"
	{
		// Encode "roomId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "roomId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoomId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/phone_numbers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAssignPhoneNumberToZoomRoomRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AssignPhoneNumberToZoomRoom", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AssignPhoneNumberToZoomRoom", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAssignPhoneNumberToZoomRoomResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AssignPhoneNumbersAutoReceptionist invokes assignPhoneNumbersAutoReceptionist operation.
//
// Assigns available phone numbers to an [auto receptionist](https://support.zoom.
// us/hc/en-us/articles/360021121312-Managing-Auto-Receptionists-and-Interactive-Voice-Response-IVR-).
//
//	The available numbers can be retrieved using the List Phone Numbers API with `type` query
//
// parameter set to &quot;unassigned&quot;.
// **Prerequisites:**
// * Pro or higher account plan with Zoom Phone License
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:auto_receptionist_number:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/auto_receptionists/{autoReceptionistId}/phone_numbers
func (c *Client) AssignPhoneNumbersAutoReceptionist(ctx context.Context, request OptAssignPhoneNumbersAutoReceptionistReq, params AssignPhoneNumbersAutoReceptionistParams) error {
	_, err := c.sendAssignPhoneNumbersAutoReceptionist(ctx, request, params)
	return err
}

func (c *Client) sendAssignPhoneNumbersAutoReceptionist(ctx context.Context, request OptAssignPhoneNumbersAutoReceptionistReq, params AssignPhoneNumbersAutoReceptionistParams) (res *AssignPhoneNumbersAutoReceptionistNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("assignPhoneNumbersAutoReceptionist"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/auto_receptionists/{autoReceptionistId}/phone_numbers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AssignPhoneNumbersAutoReceptionist",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/auto_receptionists/"
	{
		// Encode "autoReceptionistId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "autoReceptionistId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AutoReceptionistId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/phone_numbers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAssignPhoneNumbersAutoReceptionistRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AssignPhoneNumbersAutoReceptionist", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AssignPhoneNumbersAutoReceptionist", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAssignPhoneNumbersAutoReceptionistResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AssignPhoneNumbersSLG invokes assignPhoneNumbersSLG operation.
//
// Assigns phone numbers to a shared line groups. These direct phone numbers will be shared among
// members of the [shared line group](https://support.zoom.
// us/hc/en-us/articles/360038850792-Setting-up-shared-line-groups).
// **Prerequisites:**
// * Pro or higher account with Zoom Phone license.
// * A valid Shared Line Group
// * Account owner or admin privileges
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:shared_line_group_number:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/shared_line_groups/{sharedLineGroupId}/phone_numbers
func (c *Client) AssignPhoneNumbersSLG(ctx context.Context, request OptAssignPhoneNumbersSLGReq, params AssignPhoneNumbersSLGParams) error {
	_, err := c.sendAssignPhoneNumbersSLG(ctx, request, params)
	return err
}

func (c *Client) sendAssignPhoneNumbersSLG(ctx context.Context, request OptAssignPhoneNumbersSLGReq, params AssignPhoneNumbersSLGParams) (res *AssignPhoneNumbersSLGCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("assignPhoneNumbersSLG"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/shared_line_groups/{sharedLineGroupId}/phone_numbers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AssignPhoneNumbersSLG",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/shared_line_groups/"
	{
		// Encode "sharedLineGroupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sharedLineGroupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SharedLineGroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/phone_numbers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAssignPhoneNumbersSLGRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AssignPhoneNumbersSLG", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AssignPhoneNumbersSLG", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAssignPhoneNumbersSLGResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AssignPhoneNumbersToCommonArea invokes assignPhoneNumbersToCommonArea operation.
//
// Assign phone numbers to a common area.
// **Note**: For use by customers who opted for `Common Area Optimization`
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license.
// * Account owner or admin permissions.
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:common_area_number:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/common_areas/{commonAreaId}/phone_numbers
func (c *Client) AssignPhoneNumbersToCommonArea(ctx context.Context, request OptAssignPhoneNumbersToCommonAreaReq, params AssignPhoneNumbersToCommonAreaParams) (*AssignPhoneNumbersToCommonAreaCreated, error) {
	res, err := c.sendAssignPhoneNumbersToCommonArea(ctx, request, params)
	return res, err
}

func (c *Client) sendAssignPhoneNumbersToCommonArea(ctx context.Context, request OptAssignPhoneNumbersToCommonAreaReq, params AssignPhoneNumbersToCommonAreaParams) (res *AssignPhoneNumbersToCommonAreaCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("assignPhoneNumbersToCommonArea"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/common_areas/{commonAreaId}/phone_numbers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AssignPhoneNumbersToCommonArea",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/common_areas/"
	{
		// Encode "commonAreaId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "commonAreaId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CommonAreaId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/phone_numbers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAssignPhoneNumbersToCommonAreaRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AssignPhoneNumbersToCommonArea", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AssignPhoneNumbersToCommonArea", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAssignPhoneNumbersToCommonAreaResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AssignPhoneToCallQueue invokes assignPhoneToCallQueue operation.
//
// After [buying phone number(s)](https://support.zoom.
// us/hc/en-us/articles/360020808292#h_007ec8c2-0914-4265-8351-96ab23efa3ad), you can assign it,
// allowing callers to directly dial a number to reach a [call queue](https://support.zoom.
// us/hc/en-us/articles/360021524831-Managing-Call-Queues).
// **Prerequisites:**
// * Pro or higher account plan.
// * Account owner or admin permissions
// * Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:call_queue_number:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/call_queues/{callQueueId}/phone_numbers
func (c *Client) AssignPhoneToCallQueue(ctx context.Context, request OptAssignPhoneToCallQueueReq, params AssignPhoneToCallQueueParams) error {
	_, err := c.sendAssignPhoneToCallQueue(ctx, request, params)
	return err
}

func (c *Client) sendAssignPhoneToCallQueue(ctx context.Context, request OptAssignPhoneToCallQueueReq, params AssignPhoneToCallQueueParams) (res *AssignPhoneToCallQueueNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("assignPhoneToCallQueue"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/call_queues/{callQueueId}/phone_numbers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AssignPhoneToCallQueue",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/call_queues/"
	{
		// Encode "callQueueId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "callQueueId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallQueueId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/phone_numbers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAssignPhoneToCallQueueRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "AssignPhoneToCallQueue", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "AssignPhoneToCallQueue", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAssignPhoneToCallQueueResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// BatchAddLocations invokes batchAddLocations operation.
//
// Batches the add emergency service locations.
// **Prerequisites:**
// * Pro or higher account plan with Zoom phone license
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:batch_emergency_locations:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/batch_locations
func (c *Client) BatchAddLocations(ctx context.Context, request OptBatchAddLocationsReq) (*BatchAddLocationsCreated, error) {
	res, err := c.sendBatchAddLocations(ctx, request)
	return res, err
}

func (c *Client) sendBatchAddLocations(ctx context.Context, request OptBatchAddLocationsReq) (res *BatchAddLocationsCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("batchAddLocations"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/batch_locations"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "BatchAddLocations",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/batch_locations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeBatchAddLocationsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "BatchAddLocations", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "BatchAddLocations", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeBatchAddLocationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// BatchAddUsers invokes batchAddUsers operation.
//
// Adds phone users in batch. You can add up to 10 users at a time.
// **Prerequisites:**
// * The users must be active in your [Zoom account](https://marketplace.zoom.
// us/docs/api-reference/zoom-api/methods#tag/Users/operation/users).
// * Pro or higher account plan with Zoom phone license
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:batch_users:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// POST /phone/users/batch
func (c *Client) BatchAddUsers(ctx context.Context, request OptBatchAddUsersReq) ([]BatchAddUsersCreatedItem, error) {
	res, err := c.sendBatchAddUsers(ctx, request)
	return res, err
}

func (c *Client) sendBatchAddUsers(ctx context.Context, request OptBatchAddUsersReq) (res []BatchAddUsersCreatedItem, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("batchAddUsers"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/users/batch"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "BatchAddUsers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/users/batch"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeBatchAddUsersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "BatchAddUsers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "BatchAddUsers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeBatchAddUsersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// BatchUpdateDeviceLineKeySetting invokes batchUpdateDeviceLineKeySetting operation.
//
// Use this API to batch update the Zoom Phone device [line key position](https://support.zoom.
// us/hc/en-us/articles/4402415568397-Customizing-keys-for-devices-with-multiple-users) information.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`,`phone:write`
// **Granular Scopes:** `phone:update:device_line_keys`,`phone:update:device_line_keys:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Heavy`.
//
// PATCH /phone/devices/{deviceId}/line_keys
func (c *Client) BatchUpdateDeviceLineKeySetting(ctx context.Context, request OptBatchUpdateDeviceLineKeySettingReq, params BatchUpdateDeviceLineKeySettingParams) error {
	_, err := c.sendBatchUpdateDeviceLineKeySetting(ctx, request, params)
	return err
}

func (c *Client) sendBatchUpdateDeviceLineKeySetting(ctx context.Context, request OptBatchUpdateDeviceLineKeySettingReq, params BatchUpdateDeviceLineKeySettingParams) (res *BatchUpdateDeviceLineKeySettingNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("batchUpdateDeviceLineKeySetting"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/devices/{deviceId}/line_keys"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "BatchUpdateDeviceLineKeySetting",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/devices/"
	{
		// Encode "deviceId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "deviceId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DeviceId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/line_keys"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeBatchUpdateDeviceLineKeySettingRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "BatchUpdateDeviceLineKeySetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "BatchUpdateDeviceLineKeySetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeBatchUpdateDeviceLineKeySettingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// BatchUpdateLineKeySetting invokes BatchUpdateLineKeySetting operation.
//
// Use this API to batch update the Zoom Phone [line key settings](https://support.zoom.
// us/hc/en-us/articles/360040587552) information.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`,`phone:write`
// **Granular Scopes:** `phone:update:line_keys`,`phone:update:line_keys:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// PATCH /phone/extension/{extensionId}/line_keys
func (c *Client) BatchUpdateLineKeySetting(ctx context.Context, request OptBatchUpdateLineKeySettingReq, params BatchUpdateLineKeySettingParams) error {
	_, err := c.sendBatchUpdateLineKeySetting(ctx, request, params)
	return err
}

func (c *Client) sendBatchUpdateLineKeySetting(ctx context.Context, request OptBatchUpdateLineKeySettingReq, params BatchUpdateLineKeySettingParams) (res *BatchUpdateLineKeySettingNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("BatchUpdateLineKeySetting"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/extension/{extensionId}/line_keys"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "BatchUpdateLineKeySetting",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/extension/"
	{
		// Encode "extensionId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "extensionId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ExtensionId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/line_keys"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeBatchUpdateLineKeySettingRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "BatchUpdateLineKeySetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "BatchUpdateLineKeySetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeBatchUpdateLineKeySettingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateASharedLineGroup invokes createASharedLineGroup operation.
//
// Creates a shared line group. A [shared line group](https://support.zoom.
// us/hc/en-us/articles/360038850792) allows Zoom Phone admins to share a phone number and extension
// with a group of phone users or common areas. This gives members of the shared line group access to
// the group's direct phone number and voicemail. **Prerequisites:**    * Pro or higher account with
// Zoom Phone license.* Account owner or admin privileges
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:shared_line_group:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// POST /phone/shared_line_groups
func (c *Client) CreateASharedLineGroup(ctx context.Context, request OptCreateASharedLineGroupReq) (*CreateASharedLineGroupCreated, error) {
	res, err := c.sendCreateASharedLineGroup(ctx, request)
	return res, err
}

func (c *Client) sendCreateASharedLineGroup(ctx context.Context, request OptCreateASharedLineGroupReq) (res *CreateASharedLineGroupCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createASharedLineGroup"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/shared_line_groups"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateASharedLineGroup",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/shared_line_groups"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateASharedLineGroupRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "CreateASharedLineGroup", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "CreateASharedLineGroup", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateASharedLineGroupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateCRPhoneNumbers invokes createCRPhoneNumbers operation.
//
// Use this API to add phone numbers to a carrier reseller (master) account. Up to 200 numbers at a
// time. If this API is called in MA mode, it also has functions of distribution.
// **Prerequisites:**
// * A Pro or higher account plan
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:carrier_number:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/carrier_reseller/numbers
func (c *Client) CreateCRPhoneNumbers(ctx context.Context, request []CreateCRPhoneNumbersReqItem) error {
	_, err := c.sendCreateCRPhoneNumbers(ctx, request)
	return err
}

func (c *Client) sendCreateCRPhoneNumbers(ctx context.Context, request []CreateCRPhoneNumbersReqItem) (res *CreateCRPhoneNumbersCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createCRPhoneNumbers"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/carrier_reseller/numbers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateCRPhoneNumbers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/carrier_reseller/numbers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateCRPhoneNumbersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "CreateCRPhoneNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "CreateCRPhoneNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateCRPhoneNumbersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateCallQueue invokes createCallQueue operation.
//
// [Creates a call queue](https://support.zoom.
// us/hc/en-us/articles/360021524831-Managing-Call-Queues#h_e81faeeb-9184-429a-aaea-df49ff5ff413).
// Call queues allow you to route incoming calls to a group of users. For instance, you can use call
// queues to route calls to various departments in your organization such as sales, engineering,
// billing, customer service, and so on.
// You can add phone users or common areas to call queues.
// **Prerequisites:**
// * Pro, Business, or Education account
// * Account owner or admin permissions
// * Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:call_queue:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/call_queues
func (c *Client) CreateCallQueue(ctx context.Context, request OptCreateCallQueueReq) (*CreateCallQueueCreated, error) {
	res, err := c.sendCreateCallQueue(ctx, request)
	return res, err
}

func (c *Client) sendCreateCallQueue(ctx context.Context, request OptCreateCallQueueReq) (res *CreateCallQueueCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createCallQueue"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/call_queues"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateCallQueue",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/call_queues"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateCallQueueRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "CreateCallQueue", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "CreateCallQueue", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateCallQueueResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateMonitoringGroup invokes createMonitoringGroup operation.
//
// Creates a [monitoring group](https://support.zoom.us/hc/en-us/articles/360044804711).
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:monitoring_group:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// POST /phone/monitoring_groups
func (c *Client) CreateMonitoringGroup(ctx context.Context, request OptCreateMonitoringGroupReq) (*CreateMonitoringGroupCreated, error) {
	res, err := c.sendCreateMonitoringGroup(ctx, request)
	return res, err
}

func (c *Client) sendCreateMonitoringGroup(ctx context.Context, request OptCreateMonitoringGroupReq) (res *CreateMonitoringGroupCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createMonitoringGroup"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/monitoring_groups"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateMonitoringGroup",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/monitoring_groups"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateMonitoringGroupRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "CreateMonitoringGroup", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "CreateMonitoringGroup", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateMonitoringGroupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreatePhoneSite invokes createPhoneSite operation.
//
// Creates a [site](https://support.zoom.us/hc/en-us/articles/360020809672) that allows you to
// organize the Zoom Phone users in your organization.
// **Prerequisites:**
// * Multiple sites must be [enabled](https://support.zoom.
// us/hc/en-us/articles/360020809672-Managing-Multiple-Sites#h_05c88e35-1593-491f-b1a8-b7139a75dc15).
// * Pro or a higher account with Zoom Phone enabled.
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:site:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// POST /phone/sites
func (c *Client) CreatePhoneSite(ctx context.Context, request OptCreatePhoneSiteReq) (*CreatePhoneSiteCreated, error) {
	res, err := c.sendCreatePhoneSite(ctx, request)
	return res, err
}

func (c *Client) sendCreatePhoneSite(ctx context.Context, request OptCreatePhoneSiteReq) (res *CreatePhoneSiteCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createPhoneSite"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/sites"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CreatePhoneSite",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/sites"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreatePhoneSiteRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "CreatePhoneSite", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "CreatePhoneSite", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreatePhoneSiteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DelRoleMembers invokes DelRoleMembers operation.
//
// Use this API to delete member(s) in a [role](https://support.zoom.
// us/hc/en-us/articles/360042099012-Using-Zoom-Phone-role-management).
// **Prerequisites:**
// * Business or Education account
// * Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:role_member:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/roles/{roleId}/members
func (c *Client) DelRoleMembers(ctx context.Context, params DelRoleMembersParams) error {
	_, err := c.sendDelRoleMembers(ctx, params)
	return err
}

func (c *Client) sendDelRoleMembers(ctx context.Context, params DelRoleMembersParams) (res *DelRoleMembersNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("DelRoleMembers"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/roles/{roleId}/members"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DelRoleMembers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/roles/"
	{
		// Encode "roleId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "roleId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "user_ids" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "user_ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.UserIds {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DelRoleMembers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DelRoleMembers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDelRoleMembersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteABlockedList invokes deleteABlockedList operation.
//
// A Zoom account owner or a user with admin privilege can block phone numbers for phone users in an
// account. Blocked numbers can be inbound (numbers will be blocked from calling in) and outbound
// (phone users in your account won't be able to dial those numbers).
// Use this API to delete a blocked list and therefore removing the associated number from the
// blocked list. The number will be unblocked after the deletion.
// **Prerequisites:**
// * Pro or higher account plan with Zoom phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:blocked_list:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/blocked_list/{blockedListId}
func (c *Client) DeleteABlockedList(ctx context.Context, params DeleteABlockedListParams) error {
	_, err := c.sendDeleteABlockedList(ctx, params)
	return err
}

func (c *Client) sendDeleteABlockedList(ctx context.Context, params DeleteABlockedListParams) (res *DeleteABlockedListNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteABlockedList"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/blocked_list/{blockedListId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteABlockedList",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/blocked_list/"
	{
		// Encode "blockedListId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "blockedListId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BlockedListId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteABlockedList", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteABlockedList", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteABlockedListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteACallQueue invokes deleteACallQueue operation.
//
// Call queues allow you to route incoming calls to a group of users. For instance, you can use call
// queues to route calls to various departments in your organization such as sales, engineering,
// billing, customer service etc.
// Use this API to delete a Call Queue.
// **Prerequisites:**
// * Pro, Business, or Education account
// * Account owner or admin permissions
// * Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:call_queue:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/call_queues/{callQueueId}
func (c *Client) DeleteACallQueue(ctx context.Context, params DeleteACallQueueParams) error {
	_, err := c.sendDeleteACallQueue(ctx, params)
	return err
}

func (c *Client) sendDeleteACallQueue(ctx context.Context, params DeleteACallQueueParams) (res *DeleteACallQueueNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteACallQueue"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/call_queues/{callQueueId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteACallQueue",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/call_queues/"
	{
		// Encode "callQueueId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "callQueueId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallQueueId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteACallQueue", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteACallQueue", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteACallQueueResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteADevice invokes deleteADevice operation.
//
// Remove a [desk phone device or ATA (Analog Telephone Adapter)](https://support.zoom.
// us/hc/en-us/articles/360021119092) from the Zoom Phone System Management.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// * Device must not have been assigned to a user.
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:device:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/devices/{deviceId}
func (c *Client) DeleteADevice(ctx context.Context, params DeleteADeviceParams) error {
	_, err := c.sendDeleteADevice(ctx, params)
	return err
}

func (c *Client) sendDeleteADevice(ctx context.Context, params DeleteADeviceParams) (res *DeleteADeviceNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteADevice"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/devices/{deviceId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteADevice",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/devices/"
	{
		// Encode "deviceId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "deviceId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DeviceId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteADevice", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteADevice", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteADeviceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteAExternalContact invokes deleteAExternalContact operation.
//
// Removes an external contact.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:external_contact:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/external_contacts/{externalContactId}
func (c *Client) DeleteAExternalContact(ctx context.Context, params DeleteAExternalContactParams) error {
	_, err := c.sendDeleteAExternalContact(ctx, params)
	return err
}

func (c *Client) sendDeleteAExternalContact(ctx context.Context, params DeleteAExternalContactParams) (res *DeleteAExternalContactNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteAExternalContact"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/external_contacts/{externalContactId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteAExternalContact",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/external_contacts/"
	{
		// Encode "externalContactId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "externalContactId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ExternalContactId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteAExternalContact", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteAExternalContact", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteAExternalContactResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteAMemberSLG invokes deleteAMemberSLG operation.
//
// Unassigns **a specific member** from a shared line group. Members of the [shared line
// group](https://support.zoom.us/hc/en-us/articles/360038850792) have access to the group's phone
// number and voicemail.
// **Prerequisites:**
// * Pro or higher account with Zoom Phone license.
// * A valid Shared Line Group
// * Account owner or admin privileges
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:shared_line_member:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/shared_line_groups/{sharedLineGroupId}/members/{memberId}
func (c *Client) DeleteAMemberSLG(ctx context.Context, params DeleteAMemberSLGParams) error {
	_, err := c.sendDeleteAMemberSLG(ctx, params)
	return err
}

func (c *Client) sendDeleteAMemberSLG(ctx context.Context, params DeleteAMemberSLGParams) (res *DeleteAMemberSLGNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteAMemberSLG"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/shared_line_groups/{sharedLineGroupId}/members/{memberId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteAMemberSLG",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/shared_line_groups/"
	{
		// Encode "sharedLineGroupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sharedLineGroupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SharedLineGroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members/"
	{
		// Encode "memberId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "memberId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.MemberId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteAMemberSLG", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteAMemberSLG", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteAMemberSLGResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteAPhoneNumberSLG invokes deleteAPhoneNumberSLG operation.
//
// Unassigns a specific phone number that was assigned to the [shared line group](https://support.
// zoom.us/hc/en-us/articles/360038850792-Setting-up-shared-line-groups).
// **Prerequisites:**
// * Pro or higher account with Zoom Phone license.
// * A valid shared line group
// * Account owner or admin privileges
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:shared_line_group_number:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// DELETE /phone/shared_line_groups/{sharedLineGroupId}/phone_numbers/{phoneNumberId}
func (c *Client) DeleteAPhoneNumberSLG(ctx context.Context, params DeleteAPhoneNumberSLGParams) error {
	_, err := c.sendDeleteAPhoneNumberSLG(ctx, params)
	return err
}

func (c *Client) sendDeleteAPhoneNumberSLG(ctx context.Context, params DeleteAPhoneNumberSLGParams) (res *DeleteAPhoneNumberSLGNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteAPhoneNumberSLG"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/shared_line_groups/{sharedLineGroupId}/phone_numbers/{phoneNumberId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteAPhoneNumberSLG",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/shared_line_groups/"
	{
		// Encode "sharedLineGroupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sharedLineGroupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SharedLineGroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/phone_numbers/"
	{
		// Encode "phoneNumberId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "phoneNumberId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PhoneNumberId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteAPhoneNumberSLG", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteAPhoneNumberSLG", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteAPhoneNumberSLGResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteASharedLineGroup invokes deleteASharedLineGroup operation.
//
// Deletes a shared line group. A [shared line group](https://support.zoom.
// us/hc/en-us/articles/360038850792) allows Zoom Phone admins to share a phone number and extension
// with a group of phone users or common areas.
// **Prerequisites:**
// * Pro or higher account with Zoom Phone license.
// * Account owner or admin privileges
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:shared_line_group:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/shared_line_groups/{sharedLineGroupId}
func (c *Client) DeleteASharedLineGroup(ctx context.Context, params DeleteASharedLineGroupParams) error {
	_, err := c.sendDeleteASharedLineGroup(ctx, params)
	return err
}

func (c *Client) sendDeleteASharedLineGroup(ctx context.Context, params DeleteASharedLineGroupParams) (res *DeleteASharedLineGroupNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteASharedLineGroup"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/shared_line_groups/{sharedLineGroupId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteASharedLineGroup",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/shared_line_groups/"
	{
		// Encode "sharedLineGroupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sharedLineGroupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SharedLineGroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteASharedLineGroup", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteASharedLineGroup", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteASharedLineGroupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteAccountLevelInboundBlockRules invokes DeleteAccountLevelInboundBlockRules operation.
//
// Deletes the account level blocked rule for inbound calls and messaging.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:inbound_block_rule:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// DELETE /phone/inbound_blocked/rules
func (c *Client) DeleteAccountLevelInboundBlockRules(ctx context.Context, params DeleteAccountLevelInboundBlockRulesParams) error {
	_, err := c.sendDeleteAccountLevelInboundBlockRules(ctx, params)
	return err
}

func (c *Client) sendDeleteAccountLevelInboundBlockRules(ctx context.Context, params DeleteAccountLevelInboundBlockRulesParams) (res *DeleteAccountLevelInboundBlockRulesNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("DeleteAccountLevelInboundBlockRules"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/inbound_blocked/rules"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteAccountLevelInboundBlockRules",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/inbound_blocked/rules"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "blocked_rule_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "blocked_rule_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.BlockedRuleID))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteAccountLevelInboundBlockRules", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteAccountLevelInboundBlockRules", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteAccountLevelInboundBlockRulesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteAccountLevelInboundBlockedStatistics invokes DeleteAccountLevelInboundBlockedStatistics operation.
//
// Deletes the statistic of extensions blocked rule for inbound calls and messaging. (e.g. Call Queue,
//
//	Auto Receptionist, Shared Line Group, Common Area, Zoom Room and User)
//
// **Prerequisites:**
// * Pro or higher account plan with Zoom phone license
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:extension_inbound_block_rule_stat:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// DELETE /phone/inbound_blocked/extension_rules/statistics
func (c *Client) DeleteAccountLevelInboundBlockedStatistics(ctx context.Context, params DeleteAccountLevelInboundBlockedStatisticsParams) error {
	_, err := c.sendDeleteAccountLevelInboundBlockedStatistics(ctx, params)
	return err
}

func (c *Client) sendDeleteAccountLevelInboundBlockedStatistics(ctx context.Context, params DeleteAccountLevelInboundBlockedStatisticsParams) (res *DeleteAccountLevelInboundBlockedStatisticsNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("DeleteAccountLevelInboundBlockedStatistics"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/inbound_blocked/extension_rules/statistics"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteAccountLevelInboundBlockedStatistics",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/inbound_blocked/extension_rules/statistics"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "blocked_statistic_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "blocked_statistic_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.BlockedStatisticID))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteAccountLevelInboundBlockedStatistics", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteAccountLevelInboundBlockedStatistics", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteAccountLevelInboundBlockedStatisticsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteAccountOutboundCallingExceptionRule invokes deleteAccountOutboundCallingExceptionRule operation.
//
// Deletes the account level outbound calling exception rule.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:outbound_calling_rule:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// DELETE /phone/outbound_calling/exception_rules/{exceptionRuleId}
func (c *Client) DeleteAccountOutboundCallingExceptionRule(ctx context.Context, params DeleteAccountOutboundCallingExceptionRuleParams) error {
	_, err := c.sendDeleteAccountOutboundCallingExceptionRule(ctx, params)
	return err
}

func (c *Client) sendDeleteAccountOutboundCallingExceptionRule(ctx context.Context, params DeleteAccountOutboundCallingExceptionRuleParams) (res *DeleteAccountOutboundCallingExceptionRuleNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteAccountOutboundCallingExceptionRule"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/outbound_calling/exception_rules/{exceptionRuleId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteAccountOutboundCallingExceptionRule",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/outbound_calling/exception_rules/"
	{
		// Encode "exceptionRuleId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "exceptionRuleId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ExceptionRuleId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteAccountOutboundCallingExceptionRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteAccountOutboundCallingExceptionRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteAccountOutboundCallingExceptionRuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteAnAlertSetting invokes DeleteAnAlertSetting operation.
//
// Deletes an [alert setting](https://support.zoom.us/hc/en-us/articles/7146944434445).
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions.
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:alert_setting:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// DELETE /phone/alert_settings/{alertSettingId}
func (c *Client) DeleteAnAlertSetting(ctx context.Context, params DeleteAnAlertSettingParams) error {
	_, err := c.sendDeleteAnAlertSetting(ctx, params)
	return err
}

func (c *Client) sendDeleteAnAlertSetting(ctx context.Context, params DeleteAnAlertSettingParams) (res *DeleteAnAlertSettingNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("DeleteAnAlertSetting"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/alert_settings/{alertSettingId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteAnAlertSetting",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/alert_settings/"
	{
		// Encode "alertSettingId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "alertSettingId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AlertSettingId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteAnAlertSetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteAnAlertSetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteAnAlertSettingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteAudioItem invokes DeleteAudioItem operation.
//
// Deletes an audio item. Only the admin or user can delete your audio.
// **Prerequisites:**
// * Business, or Education account
// * Zoom Phone license
// **Scopes:** `phone:write`,`phone:write:admin`
// **Granular Scopes:** `phone:delete:audio`,`phone:delete:audio:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// DELETE /phone/audios/{audioId}
func (c *Client) DeleteAudioItem(ctx context.Context, params DeleteAudioItemParams) error {
	_, err := c.sendDeleteAudioItem(ctx, params)
	return err
}

func (c *Client) sendDeleteAudioItem(ctx context.Context, params DeleteAudioItemParams) (res *DeleteAudioItemNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("DeleteAudioItem"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/audios/{audioId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteAudioItem",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/audios/"
	{
		// Encode "audioId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "audioId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AudioId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteAudioItem", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteAudioItem", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteAudioItemResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteAutoReceptionist invokes deleteAutoReceptionist operation.
//
// [Deletes a non-primary auto receptionist](https://support.zoom.
// us/hc/en-us/articles/360021121312-Managing-Auto-Receptionists-and-Interactive-Voice-Response-IVR-#h_1d5ffc56-6ba3-4ce5-9d86-4a1a1ee743f3).
// An auto receptionist answers calls with a personalized recording and routes calls to a phone user,
// call queue, common area (phone), or to a voicemail. An auto receptionist can also be set up so
// that it routes calls to an interactive voice response (IVR) system to allow callers to select the
// routing options.
// **Prerequisites:**
// * Pro or higher account with Zoom Phone license.
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:auto_receptionist:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/auto_receptionists/{autoReceptionistId}
func (c *Client) DeleteAutoReceptionist(ctx context.Context, params DeleteAutoReceptionistParams) error {
	_, err := c.sendDeleteAutoReceptionist(ctx, params)
	return err
}

func (c *Client) sendDeleteAutoReceptionist(ctx context.Context, params DeleteAutoReceptionistParams) (res *DeleteAutoReceptionistNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteAutoReceptionist"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/auto_receptionists/{autoReceptionistId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteAutoReceptionist",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/auto_receptionists/"
	{
		// Encode "autoReceptionistId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "autoReceptionistId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AutoReceptionistId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteAutoReceptionist", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteAutoReceptionist", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteAutoReceptionistResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteCRPhoneNumber invokes deleteCRPhoneNumber operation.
//
// Use this API to delete or unassign a phone number from a carrier reseller account.
// **Prerequisites:**
// * A Pro or higher account plan
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:carrier_number:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/carrier_reseller/numbers/{number}
func (c *Client) DeleteCRPhoneNumber(ctx context.Context, params DeleteCRPhoneNumberParams) error {
	_, err := c.sendDeleteCRPhoneNumber(ctx, params)
	return err
}

func (c *Client) sendDeleteCRPhoneNumber(ctx context.Context, params DeleteCRPhoneNumberParams) (res *DeleteCRPhoneNumberNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteCRPhoneNumber"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/carrier_reseller/numbers/{number}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteCRPhoneNumber",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/carrier_reseller/numbers/"
	{
		// Encode "number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Number))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteCRPhoneNumber", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteCRPhoneNumber", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteCRPhoneNumberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteCallHandling invokes deleteCallHandling operation.
//
// Deletes a Zoom Phone's call handling settings. Call handling settings let you control how your
// system routes calls during business, closed, or holiday hours. For more information, read our [API
// guide](https://marketplace.zoom.us/docs/guides/zoom-phone/call-handling/) or Zoom support article
// [Customizing call handling settings](https://support.zoom.
// us/hc/en-us/articles/360059966372-Customizing-call-handling-settings).
// **Applicable to user, call queue, auto receptionist, or shared line group call handling at this
// time.**
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone enabled
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:call_handling_setting:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// DELETE /phone/extension/{extensionId}/call_handling/settings/{settingType}
func (c *Client) DeleteCallHandling(ctx context.Context, params DeleteCallHandlingParams) error {
	_, err := c.sendDeleteCallHandling(ctx, params)
	return err
}

func (c *Client) sendDeleteCallHandling(ctx context.Context, params DeleteCallHandlingParams) (res *DeleteCallHandlingNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteCallHandling"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/extension/{extensionId}/call_handling/settings/{settingType}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteCallHandling",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/extension/"
	{
		// Encode "extensionId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "extensionId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ExtensionId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/call_handling/settings/"
	{
		// Encode "settingType" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "settingType",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SettingType))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "call_forwarding_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "call_forwarding_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CallForwardingID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "holiday_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "holiday_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.HolidayID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteCallHandling", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteCallHandling", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteCallHandlingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteCallLog invokes deleteCallLog operation.
//
// Deletes a user's [call log](https://support.zoom.
// us/hc/en-us/articles/360021114452-Viewing-and-identifying-logs). For user-level apps, pass [the
// `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of
// the `userId` parameter.
// **Prerequisites:**
// * User must belong to a Business or Enterprise account
// * User must have a Zoom Phone license
// **Scopes:** `phone:write`,`phone:write:admin`,`phone_call_log:write`,`phone_call_log:write:admin`
// **Granular Scopes:** `phone:delete:call_log`,`phone:delete:call_log:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/users/{userId}/call_logs/{callLogId}
func (c *Client) DeleteCallLog(ctx context.Context, params DeleteCallLogParams) error {
	_, err := c.sendDeleteCallLog(ctx, params)
	return err
}

func (c *Client) sendDeleteCallLog(ctx context.Context, params DeleteCallLogParams) (res *DeleteCallLogNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteCallLog"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/users/{userId}/call_logs/{callLogId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteCallLog",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/call_logs/"
	{
		// Encode "callLogId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "callLogId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallLogId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteCallLog", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteCallLog", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteCallLogResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteCallRecording invokes deleteCallRecording operation.
//
// Deletes a call recording.
// **Prerequisites:**
// * User must belong to a Business or Enterprise account
// * User must have a Zoom Phone license
// **Scopes:** `phone:write:admin`,`phone:write`,`phone_recording:write`,`phone_recording:write:admin`
// **Granular Scopes:** `phone:delete:call_recording`,`phone:delete:call_recording:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/recordings/{recordingId}
func (c *Client) DeleteCallRecording(ctx context.Context, params DeleteCallRecordingParams) error {
	_, err := c.sendDeleteCallRecording(ctx, params)
	return err
}

func (c *Client) sendDeleteCallRecording(ctx context.Context, params DeleteCallRecordingParams) (res *DeleteCallRecordingNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteCallRecording"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/recordings/{recordingId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteCallRecording",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/recordings/"
	{
		// Encode "recordingId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "recordingId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RecordingId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteCallRecording", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteCallRecording", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteCallRecordingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteCommonArea invokes deleteCommonArea operation.
//
// Use this API to remove the common area.
// **Note**: For use by customers who opted for `Common Area Optimization`
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license.
// * Account owner or admin permissions.
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:common_area:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/common_areas/{commonAreaId}
func (c *Client) DeleteCommonArea(ctx context.Context, params DeleteCommonAreaParams) error {
	_, err := c.sendDeleteCommonArea(ctx, params)
	return err
}

func (c *Client) sendDeleteCommonArea(ctx context.Context, params DeleteCommonAreaParams) (res *DeleteCommonAreaNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteCommonArea"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/common_areas/{commonAreaId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteCommonArea",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/common_areas/"
	{
		// Encode "commonAreaId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "commonAreaId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CommonAreaId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteCommonArea", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteCommonArea", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteCommonAreaResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteCommonAreaOutboundCallingExceptionRule invokes deleteCommonAreaOutboundCallingExceptionRule operation.
//
// Deletes the common area level outbound calling exception rule.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:common_area_outbound_calling_rule:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// DELETE /phone/common_areas/{commonAreaId}/outbound_calling/exception_rules/{exceptionRuleId}
func (c *Client) DeleteCommonAreaOutboundCallingExceptionRule(ctx context.Context, params DeleteCommonAreaOutboundCallingExceptionRuleParams) error {
	_, err := c.sendDeleteCommonAreaOutboundCallingExceptionRule(ctx, params)
	return err
}

func (c *Client) sendDeleteCommonAreaOutboundCallingExceptionRule(ctx context.Context, params DeleteCommonAreaOutboundCallingExceptionRuleParams) (res *DeleteCommonAreaOutboundCallingExceptionRuleNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteCommonAreaOutboundCallingExceptionRule"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/common_areas/{commonAreaId}/outbound_calling/exception_rules/{exceptionRuleId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteCommonAreaOutboundCallingExceptionRule",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/common_areas/"
	{
		// Encode "commonAreaId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "commonAreaId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CommonAreaId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/outbound_calling/exception_rules/"
	{
		// Encode "exceptionRuleId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "exceptionRuleId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ExceptionRuleId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteCommonAreaOutboundCallingExceptionRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteCommonAreaOutboundCallingExceptionRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteCommonAreaOutboundCallingExceptionRuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteCommonAreaSetting invokes deleteCommonAreaSetting operation.
//
// Use this API to remove the common area subsetting from desk phones.
// **Note**: For use by customers who opted for `Common Area Optimization`
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license.
// * Account owner or admin permissions.
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:common_area_setting:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/common_areas/{commonAreaId}/settings/{settingType}
func (c *Client) DeleteCommonAreaSetting(ctx context.Context, params DeleteCommonAreaSettingParams) error {
	_, err := c.sendDeleteCommonAreaSetting(ctx, params)
	return err
}

func (c *Client) sendDeleteCommonAreaSetting(ctx context.Context, params DeleteCommonAreaSettingParams) (res *DeleteCommonAreaSettingNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteCommonAreaSetting"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/common_areas/{commonAreaId}/settings/{settingType}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteCommonAreaSetting",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/common_areas/"
	{
		// Encode "commonAreaId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "commonAreaId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CommonAreaId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/settings/"
	{
		// Encode "settingType" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "settingType",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SettingType))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "device_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "device_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.DeviceID))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteCommonAreaSetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteCommonAreaSetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteCommonAreaSettingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteEmergencyAddress invokes deleteEmergencyAddress operation.
//
// Removes an emergency address.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:emergency_address:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Heavy`.
//
// DELETE /phone/emergency_addresses/{emergencyAddressId}
func (c *Client) DeleteEmergencyAddress(ctx context.Context, params DeleteEmergencyAddressParams) error {
	_, err := c.sendDeleteEmergencyAddress(ctx, params)
	return err
}

func (c *Client) sendDeleteEmergencyAddress(ctx context.Context, params DeleteEmergencyAddressParams) (res *DeleteEmergencyAddressNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteEmergencyAddress"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/emergency_addresses/{emergencyAddressId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteEmergencyAddress",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/emergency_addresses/"
	{
		// Encode "emergencyAddressId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "emergencyAddressId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EmergencyAddressId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteEmergencyAddress", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteEmergencyAddress", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteEmergencyAddressResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteExtensionFromADevice invokes deleteExtensionFromADevice operation.
//
// Use this API to unassign a specific assignee from the device.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions.
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:device_extension:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/devices/{deviceId}/extensions/{extensionId}
func (c *Client) DeleteExtensionFromADevice(ctx context.Context, params DeleteExtensionFromADeviceParams) error {
	_, err := c.sendDeleteExtensionFromADevice(ctx, params)
	return err
}

func (c *Client) sendDeleteExtensionFromADevice(ctx context.Context, params DeleteExtensionFromADeviceParams) (res *DeleteExtensionFromADeviceNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteExtensionFromADevice"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/devices/{deviceId}/extensions/{extensionId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteExtensionFromADevice",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/devices/"
	{
		// Encode "deviceId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "deviceId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DeviceId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/extensions/"
	{
		// Encode "extensionId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "extensionId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ExtensionId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteExtensionFromADevice", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteExtensionFromADevice", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteExtensionFromADeviceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteExtensiontLevelInboundBlockRules invokes DeleteExtensiontLevelInboundBlockRules operation.
//
// Deletes the given extension's blocked rule for inbound calls and messaging.
// Use this API to delete inbound blocked rule for the given Call Queue, Auto Receptionist, Shared
// Line Group, Common Area, Zoom Room or User.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// **Scopes:** `phone:write:admin`,`phone:write`
// **Granular Scopes:** `phone:delete:extension_inbound_block_rule:admin`,
// `phone:delete:extension_inbound_block_rule`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// DELETE /phone/extension/{extensionId}/inbound_blocked/rules
func (c *Client) DeleteExtensiontLevelInboundBlockRules(ctx context.Context, params DeleteExtensiontLevelInboundBlockRulesParams) error {
	_, err := c.sendDeleteExtensiontLevelInboundBlockRules(ctx, params)
	return err
}

func (c *Client) sendDeleteExtensiontLevelInboundBlockRules(ctx context.Context, params DeleteExtensiontLevelInboundBlockRulesParams) (res *DeleteExtensiontLevelInboundBlockRulesNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("DeleteExtensiontLevelInboundBlockRules"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/extension/{extensionId}/inbound_blocked/rules"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteExtensiontLevelInboundBlockRules",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/extension/"
	{
		// Encode "extensionId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "extensionId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ExtensionId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/inbound_blocked/rules"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "blocked_rule_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "blocked_rule_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.BlockedRuleID))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteExtensiontLevelInboundBlockRules", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteExtensiontLevelInboundBlockRules", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteExtensiontLevelInboundBlockRulesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteFirmwareUpdateRule invokes DeleteFirmwareUpdateRule operation.
//
// Use this API to delete the [firmware update rule](https://support.zoom.
// us/hc/en-us/articles/360054198852-Setting-up-firmware-update-rules).
// **Prerequisites:**
// * Business or Education account
// * Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:firmware_update_rule:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/firmware_update_rules/{ruleId}
func (c *Client) DeleteFirmwareUpdateRule(ctx context.Context, params DeleteFirmwareUpdateRuleParams) error {
	_, err := c.sendDeleteFirmwareUpdateRule(ctx, params)
	return err
}

func (c *Client) sendDeleteFirmwareUpdateRule(ctx context.Context, params DeleteFirmwareUpdateRuleParams) (res *DeleteFirmwareUpdateRuleNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("DeleteFirmwareUpdateRule"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/firmware_update_rules/{ruleId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteFirmwareUpdateRule",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/firmware_update_rules/"
	{
		// Encode "ruleId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ruleId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RuleId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "restart_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "restart_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.RestartType.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteFirmwareUpdateRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteFirmwareUpdateRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteFirmwareUpdateRuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteGCP invokes deleteGCP operation.
//
// Use this API to remove a [Group Call Pickup](https://support.zoom.
// us/hc/en-us/articles/360060107472-Setting-up-and-using-group-call-pickup) object.
// **Prerequisites:**
// * A Pro or higher account plan
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:call_pickup_group:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/group_call_pickup/{groupId}
func (c *Client) DeleteGCP(ctx context.Context, params DeleteGCPParams) error {
	_, err := c.sendDeleteGCP(ctx, params)
	return err
}

func (c *Client) sendDeleteGCP(ctx context.Context, params DeleteGCPParams) (res *DeleteGCPNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteGCP"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/group_call_pickup/{groupId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteGCP",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/group_call_pickup/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteGCP", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteGCP", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteGCPResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteLineKey invokes DeleteLineKey operation.
//
// Use this API to delete the Zoom Phone [line key settings](https://support.zoom.
// us/hc/en-us/articles/360040587552) information.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`,`phone:write`
// **Granular Scopes:** `phone:delete:line_keys`,`phone:delete:line_keys:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/extension/{extensionId}/line_keys/{lineKeyId}
func (c *Client) DeleteLineKey(ctx context.Context, params DeleteLineKeyParams) error {
	_, err := c.sendDeleteLineKey(ctx, params)
	return err
}

func (c *Client) sendDeleteLineKey(ctx context.Context, params DeleteLineKeyParams) (res *DeleteLineKeyNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("DeleteLineKey"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/extension/{extensionId}/line_keys/{lineKeyId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteLineKey",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/extension/"
	{
		// Encode "extensionId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "extensionId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ExtensionId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/line_keys/"
	{
		// Encode "lineKeyId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "lineKeyId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.LineKeyId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteLineKey", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteLineKey", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteLineKeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteLocation invokes deleteLocation operation.
//
// Removes an emergency location.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:emergency_location:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/locations/{locationId}
func (c *Client) DeleteLocation(ctx context.Context, params DeleteLocationParams) error {
	_, err := c.sendDeleteLocation(ctx, params)
	return err
}

func (c *Client) sendDeleteLocation(ctx context.Context, params DeleteLocationParams) (res *DeleteLocationNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteLocation"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/locations/{locationId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteLocation",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/locations/"
	{
		// Encode "locationId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "locationId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.LocationId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteLocation", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteLocation", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteLocationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteMembersOfSLG invokes deleteMembersOfSLG operation.
//
// Unassigns **all** existing members from a Shared Line Group.Members of the [shared line
// group](https://support.zoom.us/hc/en-us/articles/360038850792) have access to the group's phone
// number and voicemail.
// **Prerequisites:**
// * Pro or higher account with Zoom Phone license.
// * A valid Shared Line Group
// * Account owner or admin privileges
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:shared_line_member:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/shared_line_groups/{sharedLineGroupId}/members
func (c *Client) DeleteMembersOfSLG(ctx context.Context, params DeleteMembersOfSLGParams) error {
	_, err := c.sendDeleteMembersOfSLG(ctx, params)
	return err
}

func (c *Client) sendDeleteMembersOfSLG(ctx context.Context, params DeleteMembersOfSLGParams) (res *DeleteMembersOfSLGNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteMembersOfSLG"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/shared_line_groups/{sharedLineGroupId}/members"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteMembersOfSLG",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/shared_line_groups/"
	{
		// Encode "sharedLineGroupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sharedLineGroupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SharedLineGroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteMembersOfSLG", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteMembersOfSLG", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteMembersOfSLGResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteMonitoringGroup invokes deleteMonitoringGroup operation.
//
// Use this API to delete a [Monitoring Group](https://support.zoom.
// us/hc/en-us/articles/360044804711).
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:monitoring_group:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/monitoring_groups/{monitoringGroupId}
func (c *Client) DeleteMonitoringGroup(ctx context.Context, params DeleteMonitoringGroupParams) error {
	_, err := c.sendDeleteMonitoringGroup(ctx, params)
	return err
}

func (c *Client) sendDeleteMonitoringGroup(ctx context.Context, params DeleteMonitoringGroupParams) (res *DeleteMonitoringGroupNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteMonitoringGroup"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/monitoring_groups/{monitoringGroupId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteMonitoringGroup",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/monitoring_groups/"
	{
		// Encode "monitoringGroupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "monitoringGroupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.MonitoringGroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteMonitoringGroup", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteMonitoringGroup", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteMonitoringGroupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteOutboundCallerNumbers invokes deleteOutboundCallerNumbers operation.
//
// Deletes the `account-level` customized outbound caller ID phone numbers. Note that when multiple
// sites policy is enabled, users cannot manage the `account-level` configuration. The system will
// throw an exception.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license.
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:customized_number:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/outbound_caller_id/customized_numbers
func (c *Client) DeleteOutboundCallerNumbers(ctx context.Context, params DeleteOutboundCallerNumbersParams) error {
	_, err := c.sendDeleteOutboundCallerNumbers(ctx, params)
	return err
}

func (c *Client) sendDeleteOutboundCallerNumbers(ctx context.Context, params DeleteOutboundCallerNumbersParams) (res *DeleteOutboundCallerNumbersNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteOutboundCallerNumbers"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/outbound_caller_id/customized_numbers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteOutboundCallerNumbers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/outbound_caller_id/customized_numbers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "customize_ids" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "customize_ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.CustomizeIds != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.CustomizeIds {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteOutboundCallerNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteOutboundCallerNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteOutboundCallerNumbersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeletePeeringPhoneNumbers invokes deletePeeringPhoneNumbers operation.
//
// Removes phone numbers added to Zoom through the Provider Exchange.
// **Note**: Phone peering API and events are for partners who have completed the MoU to peer with
// Zoom. To become a peering provider/ carrier, submit your [request](https://docs.google.
// com/forms/d/e/1FAIpQLSewkY6ixVyKVNkWC-vgmejC16gigxsJWXji3dWzE3XlWtjsgg/viewform).
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`,`phone_peering:write:admin`
// **Granular Scopes:** `phone:delete:peering_number:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/peering/numbers
func (c *Client) DeletePeeringPhoneNumbers(ctx context.Context, request OptDeletePeeringPhoneNumbersReq) (*DeletePeeringPhoneNumbersOK, error) {
	res, err := c.sendDeletePeeringPhoneNumbers(ctx, request)
	return res, err
}

func (c *Client) sendDeletePeeringPhoneNumbers(ctx context.Context, request OptDeletePeeringPhoneNumbersReq) (res *DeletePeeringPhoneNumbersOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deletePeeringPhoneNumbers"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/peering/numbers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeletePeeringPhoneNumbers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/peering/numbers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeletePeeringPhoneNumbersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeletePeeringPhoneNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeletePeeringPhoneNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeletePeeringPhoneNumbersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeletePhoneNumbersSLG invokes deletePhoneNumbersSLG operation.
//
// Unassigns all the phone numbers that have been assigned to the [shared line group](https://support.
// zoom.us/hc/en-us/articles/360038850792-Setting-up-shared-line-groups).
// **Prerequisites:**
// * Pro or higher account with Zoom Phone license.
// * A valid Shared Line Group
// * Account owner or admin privileges
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:shared_line_group_number:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// DELETE /phone/shared_line_groups/{sharedLineGroupId}/phone_numbers
func (c *Client) DeletePhoneNumbersSLG(ctx context.Context, params DeletePhoneNumbersSLGParams) error {
	_, err := c.sendDeletePhoneNumbersSLG(ctx, params)
	return err
}

func (c *Client) sendDeletePhoneNumbersSLG(ctx context.Context, params DeletePhoneNumbersSLGParams) (res *DeletePhoneNumbersSLGNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deletePhoneNumbersSLG"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/shared_line_groups/{sharedLineGroupId}/phone_numbers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeletePhoneNumbersSLG",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/shared_line_groups/"
	{
		// Encode "sharedLineGroupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sharedLineGroupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SharedLineGroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/phone_numbers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeletePhoneNumbersSLG", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeletePhoneNumbersSLG", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeletePhoneNumbersSLGResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeletePhoneRole invokes DeletePhoneRole operation.
//
// Use this API to delete a phone [role](https://support.zoom.
// us/hc/en-us/articles/360042099012-Using-Zoom-Phone-role-management).
// **Prerequisites:**
// * Business, or Education account
// * Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:role:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/roles/{roleId}
func (c *Client) DeletePhoneRole(ctx context.Context, params DeletePhoneRoleParams) error {
	_, err := c.sendDeletePhoneRole(ctx, params)
	return err
}

func (c *Client) sendDeletePhoneRole(ctx context.Context, params DeletePhoneRoleParams) (res *DeletePhoneRoleNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("DeletePhoneRole"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/roles/{roleId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeletePhoneRole",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/roles/"
	{
		// Encode "roleId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "roleId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeletePhoneRole", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeletePhoneRole", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeletePhoneRoleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeletePhoneSite invokes deletePhoneSite operation.
//
// Use this API to delete a specific [site](https://support.zoom.us/hc/en-us/articles/360020809672)
// in a Zoom account. To delete a site, in the query parameter, you must provide the site ID of
// another site where the assets of current site (users, numbers and phones) can be transferred to.
// You cannot use this API to delete the main site.
// **Prerequisites:**
// * Account must have a Pro or a higher plan with Zoom Phone license.
// * [Multiple sites](https://support.zoom.us/hc/en-us/articles/360020809672-Managing-Multiple-Sites)
// must be enabled.
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:site:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/sites/{siteId}
func (c *Client) DeletePhoneSite(ctx context.Context, params DeletePhoneSiteParams) error {
	_, err := c.sendDeletePhoneSite(ctx, params)
	return err
}

func (c *Client) sendDeletePhoneSite(ctx context.Context, params DeletePhoneSiteParams) (res *DeletePhoneSiteNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deletePhoneSite"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/sites/{siteId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeletePhoneSite",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/sites/"
	{
		// Encode "siteId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "siteId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SiteId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "transfer_site_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "transfer_site_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.TransferSiteID))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeletePhoneSite", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeletePhoneSite", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeletePhoneSiteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeletePolicy invokes DeletePolicy operation.
//
// Removes the policy subsetting for a specific [auto receptionist](https://support.zoom.
// us/hc/en-us/articles/360021121312-Managing-Auto-Receptionists-and-Interactive-Voice-Response-IVR-)
// according to the `policyType`. For example, you can use this API to remove shared access members.
// **Prerequisites:**
// * Pro or higher account plan with Zoom Phone License
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:auto_receptionist_policy:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// DELETE /phone/auto_receptionists/{autoReceptionistId}/policies/{policyType}
func (c *Client) DeletePolicy(ctx context.Context, params DeletePolicyParams) error {
	_, err := c.sendDeletePolicy(ctx, params)
	return err
}

func (c *Client) sendDeletePolicy(ctx context.Context, params DeletePolicyParams) (res *DeletePolicyNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("DeletePolicy"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/auto_receptionists/{autoReceptionistId}/policies/{policyType}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeletePolicy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/auto_receptionists/"
	{
		// Encode "autoReceptionistId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "autoReceptionistId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AutoReceptionistId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/policies/"
	{
		// Encode "policyType" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "policyType",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PolicyType))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "shared_ids" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "shared_ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.SharedIds {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeletePolicy", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeletePolicy", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeletePolicyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteProvisionTemplate invokes deleteProvisionTemplate operation.
//
// Use this API to [delete a provision template](https://support.zoom.
// us/hc/en-us/articles/360035817952#h_7b34cd1d-5ae6-4a23-bd04-454a6ad8cb3e) in a Zoom account.
// **Prerequisites:**
// * A Pro or higher account plan
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:provision_template:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/provision_templates/{templateId}
func (c *Client) DeleteProvisionTemplate(ctx context.Context, params DeleteProvisionTemplateParams) error {
	_, err := c.sendDeleteProvisionTemplate(ctx, params)
	return err
}

func (c *Client) sendDeleteProvisionTemplate(ctx context.Context, params DeleteProvisionTemplateParams) (res *DeleteProvisionTemplateNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteProvisionTemplate"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/provision_templates/{templateId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteProvisionTemplate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/provision_templates/"
	{
		// Encode "templateId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "templateId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TemplateId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteProvisionTemplate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteProvisionTemplate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteProvisionTemplateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteRoutingRule invokes deleteRoutingRule operation.
//
// Deletes the directory backup routing rule.
// The directory backup routing rules are a series of predefined Regular Expressions. These rules are
// used to route outgoing calls. If a dialed number does not match a Zoom Phone user, and does not
// match a defined External Contact, these rules are tested next. If a dialed number does not match
// any rules, the call will be routed via the PSTN.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:routing_rule:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/routing_rules/{routingRuleId}
func (c *Client) DeleteRoutingRule(ctx context.Context, params DeleteRoutingRuleParams) error {
	_, err := c.sendDeleteRoutingRule(ctx, params)
	return err
}

func (c *Client) sendDeleteRoutingRule(ctx context.Context, params DeleteRoutingRuleParams) (res *DeleteRoutingRuleNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteRoutingRule"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/routing_rules/{routingRuleId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteRoutingRule",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/routing_rules/"
	{
		// Encode "routingRuleId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "routingRuleId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoutingRuleId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteRoutingRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteRoutingRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteRoutingRuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteSiteOutboundCallerNumbers invokes deleteSiteOutboundCallerNumbers operation.
//
// Use this API to remove the `site-level` customized outbound caller ID phone numbers.
// * Multiple sites must be [enabled](https://support.zoom.
// us/hc/en-us/articles/360020809672-Managing-Multiple-Sites#h_05c88e35-1593-491f-b1a8-b7139a75dc15).
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license.
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:site_customized_number:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/sites/{siteId}/outbound_caller_id/customized_numbers
func (c *Client) DeleteSiteOutboundCallerNumbers(ctx context.Context, params DeleteSiteOutboundCallerNumbersParams) error {
	_, err := c.sendDeleteSiteOutboundCallerNumbers(ctx, params)
	return err
}

func (c *Client) sendDeleteSiteOutboundCallerNumbers(ctx context.Context, params DeleteSiteOutboundCallerNumbersParams) (res *DeleteSiteOutboundCallerNumbersNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteSiteOutboundCallerNumbers"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/sites/{siteId}/outbound_caller_id/customized_numbers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteSiteOutboundCallerNumbers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/sites/"
	{
		// Encode "siteId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "siteId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SiteId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/outbound_caller_id/customized_numbers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "customize_ids" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "customize_ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.CustomizeIds != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.CustomizeIds {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteSiteOutboundCallerNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteSiteOutboundCallerNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteSiteOutboundCallerNumbersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteSiteOutboundCallingExceptionRule invokes deleteSiteOutboundCallingExceptionRule operation.
//
// Deletes the site level outbound calling exception rule.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:site_outbound_calling_rule:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// DELETE /phone/sites/{siteId}/outbound_calling/exception_rules/{exceptionRuleId}
func (c *Client) DeleteSiteOutboundCallingExceptionRule(ctx context.Context, params DeleteSiteOutboundCallingExceptionRuleParams) error {
	_, err := c.sendDeleteSiteOutboundCallingExceptionRule(ctx, params)
	return err
}

func (c *Client) sendDeleteSiteOutboundCallingExceptionRule(ctx context.Context, params DeleteSiteOutboundCallingExceptionRuleParams) (res *DeleteSiteOutboundCallingExceptionRuleNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteSiteOutboundCallingExceptionRule"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/sites/{siteId}/outbound_calling/exception_rules/{exceptionRuleId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteSiteOutboundCallingExceptionRule",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/sites/"
	{
		// Encode "siteId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "siteId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SiteId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/outbound_calling/exception_rules/"
	{
		// Encode "exceptionRuleId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "exceptionRuleId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ExceptionRuleId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteSiteOutboundCallingExceptionRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteSiteOutboundCallingExceptionRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteSiteOutboundCallingExceptionRuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteSiteSetting invokes deleteSiteSetting operation.
//
// Sites allow you to organize Zoom Phone users in your organization. Use this API to delete the site
// setting of a specific [site](https://support.zoom.us/hc/en-us/articles/360020809672).
// **Prerequisites:**
// * Account must have a Pro or a higher plan with Zoom Phone license.
// * Multiple sites must be [enabled](https://support.zoom.
// us/hc/en-us/articles/360020809672-Managing-Multiple-Sites#h_05c88e35-1593-491f-b1a8-b7139a75dc15).
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:site_setting:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/sites/{siteId}/settings/{settingType}
func (c *Client) DeleteSiteSetting(ctx context.Context, params DeleteSiteSettingParams) error {
	_, err := c.sendDeleteSiteSetting(ctx, params)
	return err
}

func (c *Client) sendDeleteSiteSetting(ctx context.Context, params DeleteSiteSettingParams) (res *DeleteSiteSettingNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteSiteSetting"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/sites/{siteId}/settings/{settingType}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteSiteSetting",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/sites/"
	{
		// Encode "siteId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "siteId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SiteId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/settings/"
	{
		// Encode "settingType" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "settingType",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SettingType))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "device_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "device_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DeviceType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "holiday_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "holiday_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.HolidayID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteSiteSetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteSiteSetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteSiteSettingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteUnassignedPhoneNumbers invokes deleteUnassignedPhoneNumbers operation.
//
// Deletes unassigned [phone numbers](https://support.zoom.
// us/hc/en-us/articles/360020808292-Managing-Phone-Numbers#h_38ba8b01-26e3-4b1b-a9b5-0717c00a7ca6).
// Up to 20 phone numbers can be removed in a single request.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// * The user must have been previously assigned a Zoom Phone number
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:number:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// DELETE /phone/numbers
func (c *Client) DeleteUnassignedPhoneNumbers(ctx context.Context, params DeleteUnassignedPhoneNumbersParams) error {
	_, err := c.sendDeleteUnassignedPhoneNumbers(ctx, params)
	return err
}

func (c *Client) sendDeleteUnassignedPhoneNumbers(ctx context.Context, params DeleteUnassignedPhoneNumbersParams) (res *DeleteUnassignedPhoneNumbersNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteUnassignedPhoneNumbers"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/numbers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteUnassignedPhoneNumbers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/numbers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "phone_numbers" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "phone_numbers",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.PhoneNumbers {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteUnassignedPhoneNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteUnassignedPhoneNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteUnassignedPhoneNumbersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteUserOutboundCallerNumbers invokes deleteUserOutboundCallerNumbers operation.
//
// Removes the users' customized outbound caller ID phone numbers.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license.
// **Scopes:** `phone:write:admin`,`phone:write`
// **Granular Scopes:** `phone:delete:user_customized_number`,
// `phone:delete:user_customized_number:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/users/{userId}/outbound_caller_id/customized_numbers
func (c *Client) DeleteUserOutboundCallerNumbers(ctx context.Context, params DeleteUserOutboundCallerNumbersParams) error {
	_, err := c.sendDeleteUserOutboundCallerNumbers(ctx, params)
	return err
}

func (c *Client) sendDeleteUserOutboundCallerNumbers(ctx context.Context, params DeleteUserOutboundCallerNumbersParams) (res *DeleteUserOutboundCallerNumbersNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteUserOutboundCallerNumbers"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/users/{userId}/outbound_caller_id/customized_numbers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteUserOutboundCallerNumbers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/outbound_caller_id/customized_numbers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "customize_ids" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "customize_ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.CustomizeIds != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.CustomizeIds {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteUserOutboundCallerNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteUserOutboundCallerNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteUserOutboundCallerNumbersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteUserOutboundCallingExceptionRule invokes deleteUserOutboundCallingExceptionRule operation.
//
// Deletes the user level outbound calling exception rule.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:user_outbound_calling_rule:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// DELETE /phone/users/{userId}/outbound_calling/exception_rules/{exceptionRuleId}
func (c *Client) DeleteUserOutboundCallingExceptionRule(ctx context.Context, params DeleteUserOutboundCallingExceptionRuleParams) error {
	_, err := c.sendDeleteUserOutboundCallingExceptionRule(ctx, params)
	return err
}

func (c *Client) sendDeleteUserOutboundCallingExceptionRule(ctx context.Context, params DeleteUserOutboundCallingExceptionRuleParams) (res *DeleteUserOutboundCallingExceptionRuleNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteUserOutboundCallingExceptionRule"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/users/{userId}/outbound_calling/exception_rules/{exceptionRuleId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteUserOutboundCallingExceptionRule",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/outbound_calling/exception_rules/"
	{
		// Encode "exceptionRuleId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "exceptionRuleId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ExceptionRuleId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteUserOutboundCallingExceptionRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteUserOutboundCallingExceptionRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteUserOutboundCallingExceptionRuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteUserSetting invokes deleteUserSetting operation.
//
// Removes the user setting according to the setting type, specifically for delegation, intercom and
// shared access for voicemail and call recordings. For user-level apps, pass [the `me`
// value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the
// `userId` parameter.
// To see the shared access settings in the Zoom web portal, go to **Admin &gt; Phone System
// Management &gt; Users &amp; Rooms** . Click **Users** and select **User Policy**. Go to
// **Voicemail, Automatic Call Recording and Ad Hoc Call Recording**.
// To view the delegation and intercom setting in your Zoom web portal, navigate to **Admin &gt;
// Phone System Management &gt; Users &amp; Rooms**. Click the **Users** tab and select **User
// Settings**
// **Prerequisites:**
// * A Business or Enterprise account
// **Scopes:** `phone:write:admin`,`phone:write`
// **Granular Scopes:** `phone:delete:shared_setting`,`phone:delete:shared_setting:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/users/{userId}/settings/{settingType}
func (c *Client) DeleteUserSetting(ctx context.Context, params DeleteUserSettingParams) error {
	_, err := c.sendDeleteUserSetting(ctx, params)
	return err
}

func (c *Client) sendDeleteUserSetting(ctx context.Context, params DeleteUserSettingParams) (res *DeleteUserSettingNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteUserSetting"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/users/{userId}/settings/{settingType}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteUserSetting",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/settings/"
	{
		// Encode "settingType" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "settingType",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SettingType))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "shared_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "shared_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SharedID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "assistant_extension_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "assistant_extension_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AssistantExtensionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "device_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "device_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DeviceID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "intercom_extension_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "intercom_extension_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IntercomExtensionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteUserSetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteUserSetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteUserSettingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteUsersFromDirectory invokes DeleteUsersFromDirectory operation.
//
// Use this API to delete users from the [directory](https://support.zoom.
// us/hc/en-us/articles/4404938949389-Using-a-dial-by-name-directory).
// **Prerequisites:**
// * Business or Education account
// * Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:directory:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/dial_by_name_directory/extensions
func (c *Client) DeleteUsersFromDirectory(ctx context.Context, params DeleteUsersFromDirectoryParams) error {
	_, err := c.sendDeleteUsersFromDirectory(ctx, params)
	return err
}

func (c *Client) sendDeleteUsersFromDirectory(ctx context.Context, params DeleteUsersFromDirectoryParams) (res *DeleteUsersFromDirectoryNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("DeleteUsersFromDirectory"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/dial_by_name_directory/extensions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteUsersFromDirectory",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/dial_by_name_directory/extensions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "site_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "site_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.SiteID))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "extension_ids" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "extension_ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.ExtensionIds != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.ExtensionIds {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteUsersFromDirectory", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteUsersFromDirectory", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteUsersFromDirectoryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteUsersFromDirectoryBySite invokes DeleteUsersFromDirectoryBySite operation.
//
// Use this API to delete users from a [directory](https://support.zoom.
// us/hc/en-us/articles/4404938949389-Using-a-dial-by-name-directory) of the specified site.
// **Prerequisites:**
// * Business or Education account
// * Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:directory:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/sites/{siteId}/dial_by_name_directory/extensions
func (c *Client) DeleteUsersFromDirectoryBySite(ctx context.Context, params DeleteUsersFromDirectoryBySiteParams) error {
	_, err := c.sendDeleteUsersFromDirectoryBySite(ctx, params)
	return err
}

func (c *Client) sendDeleteUsersFromDirectoryBySite(ctx context.Context, params DeleteUsersFromDirectoryBySiteParams) (res *DeleteUsersFromDirectoryBySiteNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("DeleteUsersFromDirectoryBySite"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/sites/{siteId}/dial_by_name_directory/extensions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteUsersFromDirectoryBySite",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/sites/"
	{
		// Encode "siteId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "siteId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SiteId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/dial_by_name_directory/extensions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "site_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "site_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SiteID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "extension_ids" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "extension_ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.ExtensionIds != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.ExtensionIds {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DeleteUsersFromDirectoryBySite", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DeleteUsersFromDirectoryBySite", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteUsersFromDirectoryBySiteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DuplicatePhoneRole invokes DuplicatePhoneRole operation.
//
// Use this API to duplicate a phone role.
// **Prerequisites:**
// * Business or Education account
// * Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:role:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /phone/roles
func (c *Client) DuplicatePhoneRole(ctx context.Context, request OptDuplicatePhoneRoleReq) (*DuplicatePhoneRoleCreated, error) {
	res, err := c.sendDuplicatePhoneRole(ctx, request)
	return res, err
}

func (c *Client) sendDuplicatePhoneRole(ctx context.Context, request OptDuplicatePhoneRoleReq) (res *DuplicatePhoneRoleCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("DuplicatePhoneRole"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/roles"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DuplicatePhoneRole",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/roles"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDuplicatePhoneRoleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DuplicatePhoneRole", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DuplicatePhoneRole", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDuplicatePhoneRoleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetABillingAccount invokes GetABillingAccount operation.
//
// A Zoom account owner or a user with admin privilege can use this API to get information about a
// billing account.
// **Prerequisites:**
// * Pro or higher account plan with Zoom phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:billing_account:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /phone/billing_accounts/{billingAccountId}
func (c *Client) GetABillingAccount(ctx context.Context, params GetABillingAccountParams) (*GetABillingAccountOK, error) {
	res, err := c.sendGetABillingAccount(ctx, params)
	return res, err
}

func (c *Client) sendGetABillingAccount(ctx context.Context, params GetABillingAccountParams) (res *GetABillingAccountOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetABillingAccount"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/billing_accounts/{billingAccountId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetABillingAccount",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/billing_accounts/"
	{
		// Encode "billingAccountId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "billingAccountId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BillingAccountId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetABillingAccount", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetABillingAccount", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetABillingAccountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetABlockedList invokes getABlockedList operation.
//
// A Zoom account owner or a user with admin privilege can block phone numbers for phone users in an
// account. Blocked numbers can be inbound (numbers will be blocked from calling in) and outbound
// (phone users in your account won't be able to dial those numbers). Blocked callers will hear a
// generic message stating that the person they are calling is not available.
// Use this API to get information about a specific blocked list.
// **Prerequisites:**
// * Pro or higher account plan with Zoom phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:blocked_list:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /phone/blocked_list/{blockedListId}
func (c *Client) GetABlockedList(ctx context.Context, params GetABlockedListParams) (*GetABlockedListOK, error) {
	res, err := c.sendGetABlockedList(ctx, params)
	return res, err
}

func (c *Client) sendGetABlockedList(ctx context.Context, params GetABlockedListParams) (res *GetABlockedListOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getABlockedList"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/blocked_list/{blockedListId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetABlockedList",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/blocked_list/"
	{
		// Encode "blockedListId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "blockedListId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BlockedListId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetABlockedList", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetABlockedList", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetABlockedListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetACallQueue invokes getACallQueue operation.
//
// Call queues allow you to route incoming calls to a group of users. For instance, you can use call
// queues to route calls to various departments in your organization such as sales, engineering,
// billing, customer service etc.
// Use this API to get information on a specific Call Queue.
// **Prerequisites:**
// * Pro, Business, or Education account
// * Account owner or admin permissions
// * Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:call_queue:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /phone/call_queues/{callQueueId}
func (c *Client) GetACallQueue(ctx context.Context, params GetACallQueueParams) (*GetACallQueueOK, error) {
	res, err := c.sendGetACallQueue(ctx, params)
	return res, err
}

func (c *Client) sendGetACallQueue(ctx context.Context, params GetACallQueueParams) (res *GetACallQueueOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getACallQueue"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/call_queues/{callQueueId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetACallQueue",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/call_queues/"
	{
		// Encode "callQueueId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "callQueueId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallQueueId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetACallQueue", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetACallQueue", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetACallQueueResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetACommonArea invokes getACommonArea operation.
//
// Use this API to get detailed information on the common area.
// **Note**: For use by customers who opted for `Common Area Optimization`
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:common_area:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// GET /phone/common_areas/{commonAreaId}
func (c *Client) GetACommonArea(ctx context.Context, params GetACommonAreaParams) (*GetACommonAreaOK, error) {
	res, err := c.sendGetACommonArea(ctx, params)
	return res, err
}

func (c *Client) sendGetACommonArea(ctx context.Context, params GetACommonAreaParams) (res *GetACommonAreaOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getACommonArea"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/common_areas/{commonAreaId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetACommonArea",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/common_areas/"
	{
		// Encode "commonAreaId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "commonAreaId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CommonAreaId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetACommonArea", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetACommonArea", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetACommonAreaResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetADevice invokes getADevice operation.
//
// Gets detailed information about a specific [desk phone device](https://support.zoom.
// us/hc/en-us/articles/360021119092).
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:device:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /phone/devices/{deviceId}
func (c *Client) GetADevice(ctx context.Context, params GetADeviceParams) (*GetADeviceOK, error) {
	res, err := c.sendGetADevice(ctx, params)
	return res, err
}

func (c *Client) sendGetADevice(ctx context.Context, params GetADeviceParams) (res *GetADeviceOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getADevice"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/devices/{deviceId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetADevice",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/devices/"
	{
		// Encode "deviceId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "deviceId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DeviceId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetADevice", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetADevice", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetADeviceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAExternalContact invokes getAExternalContact operation.
//
// Gets an external contact's information.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:external_contact:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /phone/external_contacts/{externalContactId}
func (c *Client) GetAExternalContact(ctx context.Context, params GetAExternalContactParams) (*GetAExternalContactOK, error) {
	res, err := c.sendGetAExternalContact(ctx, params)
	return res, err
}

func (c *Client) sendGetAExternalContact(ctx context.Context, params GetAExternalContactParams) (res *GetAExternalContactOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAExternalContact"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/external_contacts/{externalContactId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetAExternalContact",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/external_contacts/"
	{
		// Encode "externalContactId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "externalContactId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ExternalContactId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetAExternalContact", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetAExternalContact", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAExternalContactResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetASharedLineGroup invokes getASharedLineGroup operation.
//
// Lists all the shared line groups. A [shared line group](https://support.zoom.
// us/hc/en-us/articles/360038850792) allows Zoom Phone admins to share a phone number and extension
// with a group of phone users or common areas. This gives members of the shared line group access to
// the group's direct phone number and voicemail.
// **Prerequisites:**
// * Pro or higher account with Zoom Phone license.
// * Account owner or admin privileges
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:shared_line_group:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// GET /phone/shared_line_groups/{sharedLineGroupId}
func (c *Client) GetASharedLineGroup(ctx context.Context, params GetASharedLineGroupParams) (*GetASharedLineGroupOK, error) {
	res, err := c.sendGetASharedLineGroup(ctx, params)
	return res, err
}

func (c *Client) sendGetASharedLineGroup(ctx context.Context, params GetASharedLineGroupParams) (res *GetASharedLineGroupOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getASharedLineGroup"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/shared_line_groups/{sharedLineGroupId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetASharedLineGroup",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/shared_line_groups/"
	{
		// Encode "sharedLineGroupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sharedLineGroupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SharedLineGroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetASharedLineGroup", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetASharedLineGroup", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetASharedLineGroupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetASite invokes getASite operation.
//
// Returns information on a specific [site](https://support.zoom.us/hc/en-us/articles/360020809672).
// Sites allow you to organize Zoom Phone users in your organization.
// **Prerequisites:**
// * Account must have a Pro or a higher plan with Zoom Phone license.
// * Multiple sites must be [enabled](https://support.zoom.
// us/hc/en-us/articles/360020809672-Managing-Multiple-Sites#h_05c88e35-1593-491f-b1a8-b7139a75dc15).
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:site:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// GET /phone/sites/{siteId}
func (c *Client) GetASite(ctx context.Context, params GetASiteParams) (*GetASiteOK, error) {
	res, err := c.sendGetASite(ctx, params)
	return res, err
}

func (c *Client) sendGetASite(ctx context.Context, params GetASiteParams) (res *GetASiteOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getASite"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/sites/{siteId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetASite",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/sites/"
	{
		// Encode "siteId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "siteId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SiteId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetASite", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetASite", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetASiteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAccountOutboundCallingCountriesAndRegions invokes GetAccountOutboundCallingCountriesAndRegions operation.
//
// Returns the account level outbound calling countries and regions.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_outbound_calling_rules:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// GET /phone/outbound_calling/countries_regions
func (c *Client) GetAccountOutboundCallingCountriesAndRegions(ctx context.Context, params GetAccountOutboundCallingCountriesAndRegionsParams) (*GetAccountOutboundCallingCountriesAndRegionsOK, error) {
	res, err := c.sendGetAccountOutboundCallingCountriesAndRegions(ctx, params)
	return res, err
}

func (c *Client) sendGetAccountOutboundCallingCountriesAndRegions(ctx context.Context, params GetAccountOutboundCallingCountriesAndRegionsParams) (res *GetAccountOutboundCallingCountriesAndRegionsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetAccountOutboundCallingCountriesAndRegions"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/outbound_calling/countries_regions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetAccountOutboundCallingCountriesAndRegions",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/outbound_calling/countries_regions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetAccountOutboundCallingCountriesAndRegions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetAccountOutboundCallingCountriesAndRegions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAccountOutboundCallingCountriesAndRegionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAlertSettingDetails invokes GetAlertSettingDetails operation.
//
// Gets detailed information about a specific [Alert setting](https://support.zoom.
// us/hc/en-us/articles/7146944434445).
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:alert_setting:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// GET /phone/alert_settings/{alertSettingId}
func (c *Client) GetAlertSettingDetails(ctx context.Context, params GetAlertSettingDetailsParams) (*GetAlertSettingDetailsOK, error) {
	res, err := c.sendGetAlertSettingDetails(ctx, params)
	return res, err
}

func (c *Client) sendGetAlertSettingDetails(ctx context.Context, params GetAlertSettingDetailsParams) (res *GetAlertSettingDetailsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetAlertSettingDetails"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/alert_settings/{alertSettingId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetAlertSettingDetails",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/alert_settings/"
	{
		// Encode "alertSettingId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "alertSettingId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AlertSettingId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetAlertSettingDetails", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetAlertSettingDetails", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAlertSettingDetailsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAudioItem invokes GetAudioItem operation.
//
// Returns an audio item. Only the admin or user can access your audio.
// **Prerequisites:**
// * Business or Education account
// * Zoom Phone license
// **Scopes:** `phone:read`,`phone:read:admin`
// **Granular Scopes:** `phone:read:audio`,`phone:read:audio:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// GET /phone/audios/{audioId}
func (c *Client) GetAudioItem(ctx context.Context, params GetAudioItemParams) (*GetAudioItemOK, error) {
	res, err := c.sendGetAudioItem(ctx, params)
	return res, err
}

func (c *Client) sendGetAudioItem(ctx context.Context, params GetAudioItemParams) (res *GetAudioItemOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetAudioItem"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/audios/{audioId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetAudioItem",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/audios/"
	{
		// Encode "audioId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "audioId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AudioId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetAudioItem", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetAudioItem", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAudioItemResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAutoReceptionistDetail invokes getAutoReceptionistDetail operation.
//
// Returns information on a specific auto receptionist.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license.
// * Account owner or admin permissions.
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:auto_receptionist:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// GET /phone/auto_receptionists/{autoReceptionistId}
func (c *Client) GetAutoReceptionistDetail(ctx context.Context, params GetAutoReceptionistDetailParams) (*GetAutoReceptionistDetailOK, error) {
	res, err := c.sendGetAutoReceptionistDetail(ctx, params)
	return res, err
}

func (c *Client) sendGetAutoReceptionistDetail(ctx context.Context, params GetAutoReceptionistDetailParams) (res *GetAutoReceptionistDetailOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAutoReceptionistDetail"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/auto_receptionists/{autoReceptionistId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetAutoReceptionistDetail",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/auto_receptionists/"
	{
		// Encode "autoReceptionistId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "autoReceptionistId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AutoReceptionistId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetAutoReceptionistDetail", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetAutoReceptionistDetail", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAutoReceptionistDetailResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAutoReceptionistIVR invokes getAutoReceptionistIVR operation.
//
// Gets an [interactive voice response (IVR) system](https://support.zoom.
// us/hc/en-us/articles/360038601971) of the specified auto receptionist.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:auto_receptionist_ivr:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /phone/auto_receptionists/{autoReceptionistId}/ivr
func (c *Client) GetAutoReceptionistIVR(ctx context.Context, params GetAutoReceptionistIVRParams) (*GetAutoReceptionistIVROK, error) {
	res, err := c.sendGetAutoReceptionistIVR(ctx, params)
	return res, err
}

func (c *Client) sendGetAutoReceptionistIVR(ctx context.Context, params GetAutoReceptionistIVRParams) (res *GetAutoReceptionistIVROK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAutoReceptionistIVR"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/auto_receptionists/{autoReceptionistId}/ivr"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetAutoReceptionistIVR",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/auto_receptionists/"
	{
		// Encode "autoReceptionistId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "autoReceptionistId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AutoReceptionistId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/ivr"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "hours_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "hours_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.HoursType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "holiday_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "holiday_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.HolidayID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetAutoReceptionistIVR", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetAutoReceptionistIVR", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAutoReceptionistIVRResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAutoReceptionistsPolicy invokes getAutoReceptionistsPolicy operation.
//
// Returns the policy setting of a specific [auto receptionist](https://support.zoom.
// us/hc/en-us/articles/360021121312-Managing-Auto-Receptionists-and-Interactive-Voice-Response-IVR-).
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:auto_receptionist_policy:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /phone/auto_receptionists/{autoReceptionistId}/policies
func (c *Client) GetAutoReceptionistsPolicy(ctx context.Context, params GetAutoReceptionistsPolicyParams) (*GetAutoReceptionistsPolicyOK, error) {
	res, err := c.sendGetAutoReceptionistsPolicy(ctx, params)
	return res, err
}

func (c *Client) sendGetAutoReceptionistsPolicy(ctx context.Context, params GetAutoReceptionistsPolicyParams) (res *GetAutoReceptionistsPolicyOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAutoReceptionistsPolicy"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/auto_receptionists/{autoReceptionistId}/policies"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetAutoReceptionistsPolicy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/auto_receptionists/"
	{
		// Encode "autoReceptionistId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "autoReceptionistId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AutoReceptionistId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/policies"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetAutoReceptionistsPolicy", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetAutoReceptionistsPolicy", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAutoReceptionistsPolicyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCallChargesUsageReport invokes GetCallChargesUsageReport operation.
//
// Retrieves the **Phone Call Charges Report**.
// The **Call charges usage report** allows account owners and admins to view monthly Zoom phone call
// charges. Account owners and admins can also access this information when they log into their Zoom
// accounts and navigate to [Call Charges Usage Report](https://zoom.
// us/pbx/page/report/system#/report/phone-system/charge?page_size=15&amp;chargeRestrict=0&amp;by=1).
// **Prerequisites:**
// * Account must be enrollled in Pro or a higher plan
// * Account must be enrolled in a [Zoom Phone](https://zoom.us/pricing/zoom-phone) plan
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:call_charges:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `HEAVY`.
//
// GET /phone/reports/call_charges
func (c *Client) GetCallChargesUsageReport(ctx context.Context, params GetCallChargesUsageReportParams) (*GetCallChargesUsageReportOK, error) {
	res, err := c.sendGetCallChargesUsageReport(ctx, params)
	return res, err
}

func (c *Client) sendGetCallChargesUsageReport(ctx context.Context, params GetCallChargesUsageReportParams) (res *GetCallChargesUsageReportOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetCallChargesUsageReport"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/reports/call_charges"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetCallChargesUsageReport",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/reports/call_charges"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "from" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "from",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.From.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "to" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "to",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.To.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "billing_account_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "billing_account_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.BillingAccountID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "show_charges_only" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "show_charges_only",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ShowChargesOnly.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetCallChargesUsageReport", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetCallChargesUsageReport", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetCallChargesUsageReportResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCallHandling invokes getCallHandling operation.
//
// Returns information about a Zoom Phone's call handling settings. Call handling settings let you
// control how your system routes calls during business, closed, or holiday hours. For more
// information, read our [API guide](https://developers.zoom.us/docs/zoom-phone/call-handling/) or
// Zoom support article [Customizing call handling settings](https://support.zoom.
// us/hc/en-us/articles/360059966372-Customizing-call-handling-settings).**Applicable to user, call
// queue, auto receptionist, or shared line group call handling at this time.** **Prerequisites:** *
// Pro or a higher account with Zoom Phone enabled
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_call_handling_settings:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// GET /phone/extension/{extensionId}/call_handling/settings
func (c *Client) GetCallHandling(ctx context.Context, params GetCallHandlingParams) (*GetCallHandlingOK, error) {
	res, err := c.sendGetCallHandling(ctx, params)
	return res, err
}

func (c *Client) sendGetCallHandling(ctx context.Context, params GetCallHandlingParams) (res *GetCallHandlingOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getCallHandling"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/extension/{extensionId}/call_handling/settings"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetCallHandling",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/extension/"
	{
		// Encode "extensionId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "extensionId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ExtensionId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/call_handling/settings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetCallHandling", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetCallHandling", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetCallHandlingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCallLogDetails invokes getCallLogDetails operation.
//
// Returns information about a [call log](https://support.zoom.
// us/hc/en-us/articles/360021114452-Viewing-and-identifying-logs).
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`,`phone_call_log:read:admin`
// **Granular Scopes:** `phone:read:call_log:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /phone/call_logs/{callLogId}
func (c *Client) GetCallLogDetails(ctx context.Context, params GetCallLogDetailsParams) (*GetCallLogDetailsOK, error) {
	res, err := c.sendGetCallLogDetails(ctx, params)
	return res, err
}

func (c *Client) sendGetCallLogDetails(ctx context.Context, params GetCallLogDetailsParams) (res *GetCallLogDetailsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getCallLogDetails"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/call_logs/{callLogId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetCallLogDetails",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/call_logs/"
	{
		// Encode "callLogId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "callLogId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallLogId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetCallLogDetails", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetCallLogDetails", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetCallLogDetailsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCallLogMetricsDetails invokes getCallLogMetricsDetails operation.
//
// Returns call log details of a specific call.
// The call logs provide a record of all incoming and outgoing calls over Zoom Phone in an account.
// **Prerequisites:**
// * Business, or Education account
// * Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:call_log:admin`.
//
// GET /phone/metrics/call_logs/{call_id}
func (c *Client) GetCallLogMetricsDetails(ctx context.Context, params GetCallLogMetricsDetailsParams) (*GetCallLogMetricsDetailsOK, error) {
	res, err := c.sendGetCallLogMetricsDetails(ctx, params)
	return res, err
}

func (c *Client) sendGetCallLogMetricsDetails(ctx context.Context, params GetCallLogMetricsDetailsParams) (res *GetCallLogMetricsDetailsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getCallLogMetricsDetails"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/metrics/call_logs/{call_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetCallLogMetricsDetails",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/metrics/call_logs/"
	{
		// Encode "call_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetCallLogMetricsDetails", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetCallLogMetricsDetails", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetCallLogMetricsDetailsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCallPath invokes getCallPath operation.
//
// Returns information about a [call log](https://support.zoom.
// us/hc/en-us/articles/360021114452-Viewing-and-identifying-logs).
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`,`phone_call_log:read:admin`
// **Granular Scopes:** `phone:read:call_log:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// GET /phone/call_history/{callLogId}
func (c *Client) GetCallPath(ctx context.Context, params GetCallPathParams) (*GetCallPathOK, error) {
	res, err := c.sendGetCallPath(ctx, params)
	return res, err
}

func (c *Client) sendGetCallPath(ctx context.Context, params GetCallPathParams) (res *GetCallPathOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getCallPath"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/call_history/{callLogId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetCallPath",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/call_history/"
	{
		// Encode "callLogId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "callLogId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallLogId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetCallPath", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetCallPath", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetCallPathResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCallQoS invokes getCallQoS operation.
//
// Gets the call quality of service (QoS) data for a call made or received by a Zoom phone user in
// the account.
// **Prerequisites:**
// * Business, or Education account
// * Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:call_qos:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /phone/metrics/call_logs/{callId}/qos
func (c *Client) GetCallQoS(ctx context.Context, params GetCallQoSParams) (*GetCallQoSOK, error) {
	res, err := c.sendGetCallQoS(ctx, params)
	return res, err
}

func (c *Client) sendGetCallQoS(ctx context.Context, params GetCallQoSParams) (res *GetCallQoSOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getCallQoS"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/metrics/call_logs/{callId}/qos"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetCallQoS",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/metrics/call_logs/"
	{
		// Encode "callId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "callId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/qos"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetCallQoS", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetCallQoS", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetCallQoSResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCallQueueRecordings invokes getCallQueueRecordings operation.
//
// Use this API to view [call recordings](https://support.zoom.
// us/hc/en-us/articles/360038521091#h_cbc9f2a3-e06c-4daa-83d4-ddbceef9c77b) from the call queue.
// **Prerequisites:**
// * Pro or higher account with Zoom Phone license.
// * [Automatic call recordings](https://support.zoom.
// us/hc/en-us/articles/360033511872#h_fcb297bb-14e8-4094-91ca-dc61e1a18734) must be enabled in the
// Policy Settings for call queues.
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_call_queue_recordings:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /phone/call_queues/{callQueueId}/recordings
func (c *Client) GetCallQueueRecordings(ctx context.Context, params GetCallQueueRecordingsParams) (*GetCallQueueRecordingsOK, error) {
	res, err := c.sendGetCallQueueRecordings(ctx, params)
	return res, err
}

func (c *Client) sendGetCallQueueRecordings(ctx context.Context, params GetCallQueueRecordingsParams) (res *GetCallQueueRecordingsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getCallQueueRecordings"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/call_queues/{callQueueId}/recordings"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetCallQueueRecordings",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/call_queues/"
	{
		// Encode "callQueueId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "callQueueId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallQueueId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/recordings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "from" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "from",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.From.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "to" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "to",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.To.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetCallQueueRecordings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetCallQueueRecordings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetCallQueueRecordingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCommonAreaOutboundCallingCountriesAndRegions invokes GetCommonAreaOutboundCallingCountriesAndRegions operation.
//
// Returns the common area level outbound calling countries and regions.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:common_area_outbound_calling_rule:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// GET /phone/common_areas/{commonAreaId}/outbound_calling/countries_regions
func (c *Client) GetCommonAreaOutboundCallingCountriesAndRegions(ctx context.Context, params GetCommonAreaOutboundCallingCountriesAndRegionsParams) (*GetCommonAreaOutboundCallingCountriesAndRegionsOK, error) {
	res, err := c.sendGetCommonAreaOutboundCallingCountriesAndRegions(ctx, params)
	return res, err
}

func (c *Client) sendGetCommonAreaOutboundCallingCountriesAndRegions(ctx context.Context, params GetCommonAreaOutboundCallingCountriesAndRegionsParams) (res *GetCommonAreaOutboundCallingCountriesAndRegionsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetCommonAreaOutboundCallingCountriesAndRegions"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/common_areas/{commonAreaId}/outbound_calling/countries_regions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetCommonAreaOutboundCallingCountriesAndRegions",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/common_areas/"
	{
		// Encode "commonAreaId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "commonAreaId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CommonAreaId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/outbound_calling/countries_regions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetCommonAreaOutboundCallingCountriesAndRegions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetCommonAreaOutboundCallingCountriesAndRegions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetCommonAreaOutboundCallingCountriesAndRegionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCommonAreaSettings invokes getCommonAreaSettings operation.
//
// Use this API to get common area settings.
// **Note**: For use by customers who opted for `Common Area Optimization`
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license.
// * Account owner or admin permissions.
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_common_area_settings:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /phone/common_areas/{commonAreaId}/settings
func (c *Client) GetCommonAreaSettings(ctx context.Context, params GetCommonAreaSettingsParams) (*GetCommonAreaSettingsOK, error) {
	res, err := c.sendGetCommonAreaSettings(ctx, params)
	return res, err
}

func (c *Client) sendGetCommonAreaSettings(ctx context.Context, params GetCommonAreaSettingsParams) (res *GetCommonAreaSettingsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getCommonAreaSettings"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/common_areas/{commonAreaId}/settings"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetCommonAreaSettings",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/common_areas/"
	{
		// Encode "commonAreaId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "commonAreaId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CommonAreaId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/settings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetCommonAreaSettings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetCommonAreaSettings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetCommonAreaSettingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetEmergencyAddress invokes getEmergencyAddress operation.
//
// Gets the emergency address information.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:emergency_address:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /phone/emergency_addresses/{emergencyAddressId}
func (c *Client) GetEmergencyAddress(ctx context.Context, params GetEmergencyAddressParams) (*GetEmergencyAddressOK, error) {
	res, err := c.sendGetEmergencyAddress(ctx, params)
	return res, err
}

func (c *Client) sendGetEmergencyAddress(ctx context.Context, params GetEmergencyAddressParams) (res *GetEmergencyAddressOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getEmergencyAddress"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/emergency_addresses/{emergencyAddressId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetEmergencyAddress",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/emergency_addresses/"
	{
		// Encode "emergencyAddressId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "emergencyAddressId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EmergencyAddressId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetEmergencyAddress", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetEmergencyAddress", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetEmergencyAddressResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetFirmwareRuleDetail invokes GetFirmwareRuleDetail operation.
//
// Use this API to get the [firmware update rule](https://support.zoom.
// us/hc/en-us/articles/360054198852-Setting-up-firmware-update-rules) information.
// **Prerequisites:**
// * Business or Education account
// * Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:firmware_update_rule:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /phone/firmware_update_rules/{ruleId}
func (c *Client) GetFirmwareRuleDetail(ctx context.Context, params GetFirmwareRuleDetailParams) (*GetFirmwareRuleDetailOK, error) {
	res, err := c.sendGetFirmwareRuleDetail(ctx, params)
	return res, err
}

func (c *Client) sendGetFirmwareRuleDetail(ctx context.Context, params GetFirmwareRuleDetailParams) (res *GetFirmwareRuleDetailOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetFirmwareRuleDetail"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/firmware_update_rules/{ruleId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetFirmwareRuleDetail",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/firmware_update_rules/"
	{
		// Encode "ruleId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ruleId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RuleId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetFirmwareRuleDetail", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetFirmwareRuleDetail", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetFirmwareRuleDetailResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetGCP invokes GetGCP operation.
//
// Use this API to retrieve information on a specific [Group Call Pickup](https://support.zoom.
// us/hc/en-us/articles/360060107472-Setting-up-and-using-group-call-pickup) object in an account.
// **Prerequisites:**
// * A Pro or higher account plan
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:call_pickup_group:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /phone/group_call_pickup/{groupId}
func (c *Client) GetGCP(ctx context.Context, params GetGCPParams) (*GetGCPOK, error) {
	res, err := c.sendGetGCP(ctx, params)
	return res, err
}

func (c *Client) sendGetGCP(ctx context.Context, params GetGCPParams) (res *GetGCPOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetGCP"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/group_call_pickup/{groupId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetGCP",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/group_call_pickup/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetGCP", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetGCP", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetGCPResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetGroupPhoneSettings invokes getGroupPhoneSettings operation.
//
// Returns group phone settings.
// **Prerequisites:**
// * Account must have a Pro or a higher plan with Zoom Phone license.
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:group_setting:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// GET /phone/groups/{groupId}/settings
func (c *Client) GetGroupPhoneSettings(ctx context.Context, params GetGroupPhoneSettingsParams) (*GetGroupPhoneSettingsOK, error) {
	res, err := c.sendGetGroupPhoneSettings(ctx, params)
	return res, err
}

func (c *Client) sendGetGroupPhoneSettings(ctx context.Context, params GetGroupPhoneSettingsParams) (res *GetGroupPhoneSettingsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getGroupPhoneSettings"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/groups/{groupId}/settings"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetGroupPhoneSettings",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/settings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "setting_types" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "setting_types",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SettingTypes.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetGroupPhoneSettings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetGroupPhoneSettings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetGroupPhoneSettingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetLocation invokes getLocation operation.
//
// Returns an emergency service location's information.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:emergency_location:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /phone/locations/{locationId}
func (c *Client) GetLocation(ctx context.Context, params GetLocationParams) (*GetLocationOK, error) {
	res, err := c.sendGetLocation(ctx, params)
	return res, err
}

func (c *Client) sendGetLocation(ctx context.Context, params GetLocationParams) (res *GetLocationOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getLocation"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/locations/{locationId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetLocation",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/locations/"
	{
		// Encode "locationId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "locationId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.LocationId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetLocation", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetLocation", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetLocationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMonitoringGroupById invokes getMonitoringGroupById operation.
//
// Returns a [monitoring group](https://support.zoom.us/hc/en-us/articles/360044804711) for the
// specified ID.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:monitoring_group:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// GET /phone/monitoring_groups/{monitoringGroupId}
func (c *Client) GetMonitoringGroupById(ctx context.Context, params GetMonitoringGroupByIdParams) (*GetMonitoringGroupByIdOK, error) {
	res, err := c.sendGetMonitoringGroupById(ctx, params)
	return res, err
}

func (c *Client) sendGetMonitoringGroupById(ctx context.Context, params GetMonitoringGroupByIdParams) (res *GetMonitoringGroupByIdOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getMonitoringGroupById"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/monitoring_groups/{monitoringGroupId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetMonitoringGroupById",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/monitoring_groups/"
	{
		// Encode "monitoringGroupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "monitoringGroupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.MonitoringGroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetMonitoringGroupById", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetMonitoringGroupById", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetMonitoringGroupByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPSOperationLogs invokes getPSOperationLogs operation.
//
// Retrieves the phone system operation logs report.
// The phone system operation logs report allows account owners and admins to view monthly Zoom phone
// related admin operation details.
// Account owners and admins can also access this information by logging into their Zoom accounts and
// navigating to [Phone System Operation Logs](https://zoom.
// us/pbx/page/report/operations#/report/operation-logs).
// **Prerequisites:**
// * Account must be enrollled in Pro or a higher plan
// * Account must be enrolled in a [Zoom Phone](https://zoom.us/pricing/zoom-phone) plan
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:operation_logs:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `HEAVY`.
//
// GET /phone/reports/operationlogs
func (c *Client) GetPSOperationLogs(ctx context.Context, params GetPSOperationLogsParams) (*GetPSOperationLogsOK, error) {
	res, err := c.sendGetPSOperationLogs(ctx, params)
	return res, err
}

func (c *Client) sendGetPSOperationLogs(ctx context.Context, params GetPSOperationLogsParams) (res *GetPSOperationLogsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPSOperationLogs"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/reports/operationlogs"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetPSOperationLogs",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/reports/operationlogs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "from" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "from",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.From.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "to" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "to",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.To.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "category_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "category_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CategoryType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetPSOperationLogs", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetPSOperationLogs", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPSOperationLogsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPhoneNumberDetails invokes getPhoneNumberDetails operation.
//
// Returns information about an account's Zoom Phone number.
// **Prerequisites:**
// * A Pro or higher account plan
// * A Zoom phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:numbers:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// GET /phone/numbers/{phoneNumberId}
func (c *Client) GetPhoneNumberDetails(ctx context.Context, params GetPhoneNumberDetailsParams) (*GetPhoneNumberDetailsOK, error) {
	res, err := c.sendGetPhoneNumberDetails(ctx, params)
	return res, err
}

func (c *Client) sendGetPhoneNumberDetails(ctx context.Context, params GetPhoneNumberDetailsParams) (res *GetPhoneNumberDetailsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPhoneNumberDetails"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/numbers/{phoneNumberId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetPhoneNumberDetails",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/numbers/"
	{
		// Encode "phoneNumberId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "phoneNumberId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PhoneNumberId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetPhoneNumberDetails", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetPhoneNumberDetails", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPhoneNumberDetailsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPhoneRecordings invokes getPhoneRecordings operation.
//
// Returns an account's [call recordings](https://support.zoom.
// us/hc/en-us/articles/360038521091-Accessing-and-sharing-call-recordings).
// **Prerequisites:**
// * A Pro or higher account plan
// * A Zoom Phone license
// * Account owner or admin privileges
// **Scopes:** `phone:read:admin`,`phone_recording:read:admin`
// **Granular Scopes:** `phone:read:list_call_recordings:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// GET /phone/recordings
func (c *Client) GetPhoneRecordings(ctx context.Context, params GetPhoneRecordingsParams) (*GetPhoneRecordingsOK, error) {
	res, err := c.sendGetPhoneRecordings(ctx, params)
	return res, err
}

func (c *Client) sendGetPhoneRecordings(ctx context.Context, params GetPhoneRecordingsParams) (res *GetPhoneRecordingsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPhoneRecordings"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/recordings"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetPhoneRecordings",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/recordings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "from" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "from",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.From.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "to" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "to",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.To.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "owner_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "owner_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OwnerType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "recording_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "recording_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.RecordingType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "site_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "site_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SiteID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "query_date_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "query_date_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.QueryDateType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "group_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "group_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.GroupID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetPhoneRecordings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetPhoneRecordings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPhoneRecordingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPhoneRecordingsByCallIdOrCallLogId invokes getPhoneRecordingsByCallIdOrCallLogId operation.
//
// Returns an account's [call recording](https://support.zoom.
// us/hc/en-us/articles/360038521091-Accessing-and-sharing-call-recordings) by the recording's
// `callId` or `callLogId` ID.
// **Note**: This  API returns the `file_url` in the JSON query results.
// **Prerequisites:**
// * A Pro or higher account with Zoom Phone license
// * Account owner or admin privileges
// **Scopes:** `phone:read:admin`,`phone_recording:read`,`phone_recording:read:admin`
// **Granular Scopes:** `phone:read:call_recording`,`phone:read:call_recording:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// GET /phone/call_logs/{id}/recordings
func (c *Client) GetPhoneRecordingsByCallIdOrCallLogId(ctx context.Context, params GetPhoneRecordingsByCallIdOrCallLogIdParams) (*GetPhoneRecordingsByCallIdOrCallLogIdOK, error) {
	res, err := c.sendGetPhoneRecordingsByCallIdOrCallLogId(ctx, params)
	return res, err
}

func (c *Client) sendGetPhoneRecordingsByCallIdOrCallLogId(ctx context.Context, params GetPhoneRecordingsByCallIdOrCallLogIdParams) (res *GetPhoneRecordingsByCallIdOrCallLogIdOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPhoneRecordingsByCallIdOrCallLogId"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/call_logs/{id}/recordings"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetPhoneRecordingsByCallIdOrCallLogId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/call_logs/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/recordings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetPhoneRecordingsByCallIdOrCallLogId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetPhoneRecordingsByCallIdOrCallLogId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPhoneRecordingsByCallIdOrCallLogIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPhoneUserVoiceMails invokes GetPhoneUserVoiceMails operation.
//
// Retrieves a user's Zoom Phone voicemails in descending order. For user-level apps, pass [the `me`
// value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the
// `userId` parameter.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`,`phone:read`
// **Granular Scopes:** `phone:read:list_voicemails`,`phone:read:list_voicemails:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// GET /phone/users/{userId}/voice_mails/sync
func (c *Client) GetPhoneUserVoiceMails(ctx context.Context, params GetPhoneUserVoiceMailsParams) (*GetPhoneUserVoiceMailsOK, error) {
	res, err := c.sendGetPhoneUserVoiceMails(ctx, params)
	return res, err
}

func (c *Client) sendGetPhoneUserVoiceMails(ctx context.Context, params GetPhoneUserVoiceMailsParams) (res *GetPhoneUserVoiceMailsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetPhoneUserVoiceMails"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/users/{userId}/voice_mails/sync"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetPhoneUserVoiceMails",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/voice_mails/sync"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "sync_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sync_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.SyncType))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sync_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sync_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SyncToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "count" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "count",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Count.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetPhoneUserVoiceMails", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetPhoneUserVoiceMails", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPhoneUserVoiceMailsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPortedNumbersDetails invokes getPortedNumbersDetails operation.
//
// Use this API to get details on the ported numbers by specifying `order_id`.
// **Prerequisites:**
// * A Pro or higher account plan
// * A Zoom phone license
// **Scopes:** `phone:read:admin`,`phone_peering:read:admin`
// **Granular Scopes:** `phone:read:ported_number:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /phone/ported_numbers/orders/{orderId}
func (c *Client) GetPortedNumbersDetails(ctx context.Context, params GetPortedNumbersDetailsParams) (*GetPortedNumbersDetailsOK, error) {
	res, err := c.sendGetPortedNumbersDetails(ctx, params)
	return res, err
}

func (c *Client) sendGetPortedNumbersDetails(ctx context.Context, params GetPortedNumbersDetailsParams) (res *GetPortedNumbersDetailsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPortedNumbersDetails"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/ported_numbers/orders/{orderId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetPortedNumbersDetails",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/ported_numbers/orders/"
	{
		// Encode "orderId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "orderId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrderId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetPortedNumbersDetails", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetPortedNumbersDetails", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPortedNumbersDetailsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetProvisionTemplate invokes GetProvisionTemplate operation.
//
// Use this API to get a specific [provision template](https://support.zoom.
// us/hc/en-us/articles/360035817952).
// **Prerequisites:**
// * A Pro or higher account plan
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:provision_template:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /phone/provision_templates/{templateId}
func (c *Client) GetProvisionTemplate(ctx context.Context, params GetProvisionTemplateParams) (*GetProvisionTemplateOK, error) {
	res, err := c.sendGetProvisionTemplate(ctx, params)
	return res, err
}

func (c *Client) sendGetProvisionTemplate(ctx context.Context, params GetProvisionTemplateParams) (res *GetProvisionTemplateOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetProvisionTemplate"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/provision_templates/{templateId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetProvisionTemplate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/provision_templates/"
	{
		// Encode "templateId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "templateId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TemplateId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetProvisionTemplate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetProvisionTemplate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetProvisionTemplateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetRoleInformation invokes getRoleInformation operation.
//
// Use this API to get information on a phone [role](https://support.zoom.
// us/hc/en-us/articles/360042099012-Using-Zoom-Phone-role-management).
// **Prerequisites:**
// * Business, or Education account
// * Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:role:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /phone/roles/{roleId}
func (c *Client) GetRoleInformation(ctx context.Context, params GetRoleInformationParams) (*GetRoleInformationOK, error) {
	res, err := c.sendGetRoleInformation(ctx, params)
	return res, err
}

func (c *Client) sendGetRoleInformation(ctx context.Context, params GetRoleInformationParams) (res *GetRoleInformationOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getRoleInformation"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/roles/{roleId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetRoleInformation",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/roles/"
	{
		// Encode "roleId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "roleId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetRoleInformation", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetRoleInformation", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetRoleInformationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetRoutingRule invokes getRoutingRule operation.
//
// Returns the directory backup routing rule. The directory backup routing rules are a series of
// predefined Regular Expressions. These rules are used to route outgoing calls. If a dialed number
// does not match a Zoom Phone user, and does not match a defined External Contact, these rules are
// tested next. If a dialed number does not match any rules, the call will be routed via the PSTN.
// **Prerequisites:** * A Business or Enterprise account * A Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:routing_rule:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /phone/routing_rules/{routingRuleId}
func (c *Client) GetRoutingRule(ctx context.Context, params GetRoutingRuleParams) (*GetRoutingRuleOK, error) {
	res, err := c.sendGetRoutingRule(ctx, params)
	return res, err
}

func (c *Client) sendGetRoutingRule(ctx context.Context, params GetRoutingRuleParams) (res *GetRoutingRuleOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getRoutingRule"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/routing_rules/{routingRuleId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetRoutingRule",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/routing_rules/"
	{
		// Encode "routingRuleId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "routingRuleId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoutingRuleId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetRoutingRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetRoutingRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetRoutingRuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSMSCampaign invokes GetSMSCampaign operation.
//
// Use this API to get a specific SMS campaign.
// **Prerequisites:**
// * A Pro or higher account plan
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:sms_campaign:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /phone/sms_campaigns/{smsCampaignId}
func (c *Client) GetSMSCampaign(ctx context.Context, params GetSMSCampaignParams) (*GetSMSCampaignOK, error) {
	res, err := c.sendGetSMSCampaign(ctx, params)
	return res, err
}

func (c *Client) sendGetSMSCampaign(ctx context.Context, params GetSMSCampaignParams) (res *GetSMSCampaignOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetSMSCampaign"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/sms_campaigns/{smsCampaignId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetSMSCampaign",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/sms_campaigns/"
	{
		// Encode "smsCampaignId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "smsCampaignId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SmsCampaignId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetSMSCampaign", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetSMSCampaign", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetSMSCampaignResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSMSChargesUsageReport invokes GetSMSChargesUsageReport operation.
//
// Retrieves the **SMS/MMS Charges Report**.  The **SMS/MMS charges usage report** allows account
// owners and admins to view monthly Zoom phone call charges. Account owners and admins can also
// access this information by when they log into their Zoom accounts and navigate to [ SMS/MMS
// Charges Usage Report](https://zoom.
// us/pbx/page/report/system#/report/phone-system/charge?page_size=15&amp;chargeRestrict=0&amp;by=2).
//
//	**Prerequisites:**  * Account must be enrolled in Pro or a higher plan * Account must be enrolled
//
// in a [Zoom Phone](https://zoom.us/pricing/zoom-phone) plan
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:sms_charges:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `HEAVY`.
//
// GET /phone/reports/sms_charges
func (c *Client) GetSMSChargesUsageReport(ctx context.Context, params GetSMSChargesUsageReportParams) (*GetSMSChargesUsageReportOK, error) {
	res, err := c.sendGetSMSChargesUsageReport(ctx, params)
	return res, err
}

func (c *Client) sendGetSMSChargesUsageReport(ctx context.Context, params GetSMSChargesUsageReportParams) (res *GetSMSChargesUsageReportOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetSMSChargesUsageReport"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/reports/sms_charges"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetSMSChargesUsageReport",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/reports/sms_charges"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "from" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "from",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.From.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "to" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "to",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.To.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "show_charges_only" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "show_charges_only",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ShowChargesOnly.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetSMSChargesUsageReport", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetSMSChargesUsageReport", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetSMSChargesUsageReportResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSettingTemplate invokes getSettingTemplate operation.
//
// Returns information about an account's phone template.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:setting_template:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /phone/setting_templates/{templateId}
func (c *Client) GetSettingTemplate(ctx context.Context, params GetSettingTemplateParams) (*GetSettingTemplateOK, error) {
	res, err := c.sendGetSettingTemplate(ctx, params)
	return res, err
}

func (c *Client) sendGetSettingTemplate(ctx context.Context, params GetSettingTemplateParams) (res *GetSettingTemplateOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getSettingTemplate"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/setting_templates/{templateId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetSettingTemplate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/setting_templates/"
	{
		// Encode "templateId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "templateId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TemplateId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "custom_query_fields" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "custom_query_fields",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CustomQueryFields.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetSettingTemplate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetSettingTemplate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetSettingTemplateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSharedLineGroupPolicy invokes getSharedLineGroupPolicy operation.
//
// Returns the policy setting of a specific [shared line group](https://support.zoom.
// us/hc/en-us/articles/360038850792).
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:shared_line_group_policy:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// GET /phone/shared_line_groups/{sharedLineGroupId}/policies
func (c *Client) GetSharedLineGroupPolicy(ctx context.Context, params GetSharedLineGroupPolicyParams) (*GetSharedLineGroupPolicyOK, error) {
	res, err := c.sendGetSharedLineGroupPolicy(ctx, params)
	return res, err
}

func (c *Client) sendGetSharedLineGroupPolicy(ctx context.Context, params GetSharedLineGroupPolicyParams) (res *GetSharedLineGroupPolicyOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getSharedLineGroupPolicy"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/shared_line_groups/{sharedLineGroupId}/policies"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetSharedLineGroupPolicy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/shared_line_groups/"
	{
		// Encode "sharedLineGroupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sharedLineGroupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SharedLineGroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/policies"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetSharedLineGroupPolicy", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetSharedLineGroupPolicy", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetSharedLineGroupPolicyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSiteOutboundCallingCountriesAndRegions invokes GetSiteOutboundCallingCountriesAndRegions operation.
//
// Returns the site level outbound calling countries and regions.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:site_outbound_calling_rule:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// GET /phone/sites/{siteId}/outbound_calling/countries_regions
func (c *Client) GetSiteOutboundCallingCountriesAndRegions(ctx context.Context, params GetSiteOutboundCallingCountriesAndRegionsParams) (*GetSiteOutboundCallingCountriesAndRegionsOK, error) {
	res, err := c.sendGetSiteOutboundCallingCountriesAndRegions(ctx, params)
	return res, err
}

func (c *Client) sendGetSiteOutboundCallingCountriesAndRegions(ctx context.Context, params GetSiteOutboundCallingCountriesAndRegionsParams) (res *GetSiteOutboundCallingCountriesAndRegionsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetSiteOutboundCallingCountriesAndRegions"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/sites/{siteId}/outbound_calling/countries_regions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetSiteOutboundCallingCountriesAndRegions",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/sites/"
	{
		// Encode "siteId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "siteId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SiteId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/outbound_calling/countries_regions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetSiteOutboundCallingCountriesAndRegions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetSiteOutboundCallingCountriesAndRegions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetSiteOutboundCallingCountriesAndRegionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSiteSettingForType invokes getSiteSettingForType operation.
//
// Sites allow you to organize Zoom Phone users in your organization. Use this API to get site
// setting about a specific [site](https://support.zoom.us/hc/en-us/articles/360020809672) according
// to the setting type.
// **Prerequisites:**
// * Account must have a Pro or a higher plan with Zoom Phone license.
// * Multiple sites must be [enabled](https://support.zoom.
// us/hc/en-us/articles/360020809672-Managing-Multiple-Sites#h_05c88e35-1593-491f-b1a8-b7139a75dc15).
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:site_setting:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /phone/sites/{siteId}/settings/{settingType}
func (c *Client) GetSiteSettingForType(ctx context.Context, params GetSiteSettingForTypeParams) (*GetSiteSettingForTypeOK, error) {
	res, err := c.sendGetSiteSettingForType(ctx, params)
	return res, err
}

func (c *Client) sendGetSiteSettingForType(ctx context.Context, params GetSiteSettingForTypeParams) (res *GetSiteSettingForTypeOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getSiteSettingForType"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/sites/{siteId}/settings/{settingType}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetSiteSettingForType",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/sites/"
	{
		// Encode "siteId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "siteId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SiteId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/settings/"
	{
		// Encode "settingType" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "settingType",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SettingType))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetSiteSettingForType", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetSiteSettingForType", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetSiteSettingForTypeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSmsSessions invokes GetSmsSessions operation.
//
// Retrieves the user's SMS sessions in descending order. Mirrors the ZP client behavior with the
// most recent on top.
// **Prerequisites:**
// * Paid account
// * User-enabled Zoom phone
// **Scopes:** `phone:read:admin`,`phone:read`,`phone_sms:read:admin`,`phone_sms:read`
// **Granular Scopes:** `phone:read:sms_session`,`phone:read:sms_session:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /phone/users/{userId}/sms/sessions/sync
func (c *Client) GetSmsSessions(ctx context.Context, params GetSmsSessionsParams) (*GetSmsSessionsOK, error) {
	res, err := c.sendGetSmsSessions(ctx, params)
	return res, err
}

func (c *Client) sendGetSmsSessions(ctx context.Context, params GetSmsSessionsParams) (res *GetSmsSessionsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetSmsSessions"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/users/{userId}/sms/sessions/sync"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetSmsSessions",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/sms/sessions/sync"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "sync_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sync_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.SyncType))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sync_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sync_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SyncToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "count" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "count",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Count.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "session_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "session_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SessionType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetSmsSessions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetSmsSessions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetSmsSessionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUserOutboundCallingCountriesAndRegions invokes GetUserOutboundCallingCountriesAndRegions operation.
//
// Returns the user level outbound calling countries and regions.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:user_outbound_calling_rule:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// GET /phone/users/{userId}/outbound_calling/countries_regions
func (c *Client) GetUserOutboundCallingCountriesAndRegions(ctx context.Context, params GetUserOutboundCallingCountriesAndRegionsParams) (*GetUserOutboundCallingCountriesAndRegionsOK, error) {
	res, err := c.sendGetUserOutboundCallingCountriesAndRegions(ctx, params)
	return res, err
}

func (c *Client) sendGetUserOutboundCallingCountriesAndRegions(ctx context.Context, params GetUserOutboundCallingCountriesAndRegionsParams) (res *GetUserOutboundCallingCountriesAndRegionsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetUserOutboundCallingCountriesAndRegions"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/users/{userId}/outbound_calling/countries_regions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetUserOutboundCallingCountriesAndRegions",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/outbound_calling/countries_regions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetUserOutboundCallingCountriesAndRegions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetUserOutboundCallingCountriesAndRegions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetUserOutboundCallingCountriesAndRegionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVoicemailDetails invokes getVoicemailDetails operation.
//
// Use this API to return information about a [voicemail message](https://support.zoom.
// us/hc/en-us/articles/360021400211-Managing-voicemail-messages).
// **Prerequisites:**
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`,`phone:read`,`phone_voicemail:read:admin`,`phone_voicemail:read`
// **Granular Scopes:** `phone:read:voicemail`,`phone:read:voicemail:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /phone/voice_mails/{voicemailId}
func (c *Client) GetVoicemailDetails(ctx context.Context, params GetVoicemailDetailsParams) (*GetVoicemailDetailsOK, error) {
	res, err := c.sendGetVoicemailDetails(ctx, params)
	return res, err
}

func (c *Client) sendGetVoicemailDetails(ctx context.Context, params GetVoicemailDetailsParams) (res *GetVoicemailDetailsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getVoicemailDetails"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/voice_mails/{voicemailId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetVoicemailDetails",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/voice_mails/"
	{
		// Encode "voicemailId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "voicemailId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VoicemailId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetVoicemailDetails", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetVoicemailDetails", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetVoicemailDetailsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVoicemailDetailsByCallIdOrCallLogId invokes getVoicemailDetailsByCallIdOrCallLogId operation.
//
// Use this API to return detailed information on a voicemail associated with a call log ID. For
// user-level apps, pass [the `me` value](https://marketplace.zoom.
// us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
// **Prerequisites:**
// * User must belong to a Business or Enterprise account
// * User must have a Zoom Phone license
// **Scopes:** `phone:read`,`phone:read:admin`,`phone_voicemail:read`,`phone_voicemail:read:admin`
// **Granular Scopes:** `phone:read:voicemail`,`phone:read:voicemail:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /phone/users/{userId}/call_logs/{id}/voice_mail
func (c *Client) GetVoicemailDetailsByCallIdOrCallLogId(ctx context.Context, params GetVoicemailDetailsByCallIdOrCallLogIdParams) (*GetVoicemailDetailsByCallIdOrCallLogIdOK, error) {
	res, err := c.sendGetVoicemailDetailsByCallIdOrCallLogId(ctx, params)
	return res, err
}

func (c *Client) sendGetVoicemailDetailsByCallIdOrCallLogId(ctx context.Context, params GetVoicemailDetailsByCallIdOrCallLogIdParams) (res *GetVoicemailDetailsByCallIdOrCallLogIdOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getVoicemailDetailsByCallIdOrCallLogId"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/users/{userId}/call_logs/{id}/voice_mail"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetVoicemailDetailsByCallIdOrCallLogId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/phone/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/call_logs/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/voice_mail"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetVoicemailDetailsByCallIdOrCallLogId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetVoicemailDetailsByCallIdOrCallLogId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetVoicemailDetailsByCallIdOrCallLogIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetZoomRoom invokes getZoomRoom operation.
//
// Use this API to get a specific [Zoom Room](https://support.zoom.us/hc/en-us/articles/360025153711)
// in an account that has the Zoom Phone license assigned.
// **Prerequisites:**
// * A Pro or higher account plan
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:room:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /phone/rooms/{roomId}
func (c *Client) GetZoomRoom(ctx context.Context, params GetZoomRoomParams) (*GetZoomRoomOK, error) {
	res, err := c.sendGetZoomRoom(ctx, params)
	return res, err
}

func (c *Client) sendGetZoomRoom(ctx context.Context, params GetZoomRoomParams) (res *GetZoomRoomOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getZoomRoom"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/rooms/{roomId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetZoomRoom",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/rooms/"
	{
		// Encode "roomId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "roomId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoomId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetZoomRoom", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetZoomRoom", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetZoomRoomResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListAccountLevelInboundBlockRules invokes ListAccountLevelInboundBlockRules operation.
//
// Returns a list of account level inbound block rule for inbound calls and messaging.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_inbound_block_rules:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// GET /phone/inbound_blocked/rules
func (c *Client) ListAccountLevelInboundBlockRules(ctx context.Context, params ListAccountLevelInboundBlockRulesParams) (*ListAccountLevelInboundBlockRulesOK, error) {
	res, err := c.sendListAccountLevelInboundBlockRules(ctx, params)
	return res, err
}

func (c *Client) sendListAccountLevelInboundBlockRules(ctx context.Context, params ListAccountLevelInboundBlockRulesParams) (res *ListAccountLevelInboundBlockRulesOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ListAccountLevelInboundBlockRules"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/inbound_blocked/rules"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListAccountLevelInboundBlockRules",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/inbound_blocked/rules"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "keyword" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "keyword",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Keyword.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "match_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "match_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.MatchType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Status.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListAccountLevelInboundBlockRules", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListAccountLevelInboundBlockRules", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListAccountLevelInboundBlockRulesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListAccountLevelInboundBlockedStatistics invokes ListAccountLevelInboundBlockedStatistics operation.
//
// Returns the list of the statistics of the extensions blocked rule for inbound calls and messaging.
// (e.g. Call Queue, Auto Receptionist, Shared Line Group, Common Area, Zoom Room and User)
// **Prerequisites:**
// * Pro or higher account plan with Zoom phone license
// * Account owner or admin permissions
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_extension_inbound_block_rules_stat:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// GET /phone/inbound_blocked/extension_rules/statistics
func (c *Client) ListAccountLevelInboundBlockedStatistics(ctx context.Context, params ListAccountLevelInboundBlockedStatisticsParams) (*ListAccountLevelInboundBlockedStatisticsOK, error) {
	res, err := c.sendListAccountLevelInboundBlockedStatistics(ctx, params)
	return res, err
}

func (c *Client) sendListAccountLevelInboundBlockedStatistics(ctx context.Context, params ListAccountLevelInboundBlockedStatisticsParams) (res *ListAccountLevelInboundBlockedStatisticsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ListAccountLevelInboundBlockedStatistics"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/inbound_blocked/extension_rules/statistics"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListAccountLevelInboundBlockedStatistics",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/inbound_blocked/extension_rules/statistics"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "keyword" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "keyword",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Keyword.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "match_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "match_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.MatchType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListAccountLevelInboundBlockedStatistics", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListAccountLevelInboundBlockedStatistics", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListAccountLevelInboundBlockedStatisticsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListAccountOutboundCallingExceptionRule invokes listAccountOutboundCallingExceptionRule operation.
//
// Lists the account level outbound calling policy exception rules.
// **Prerequisite:**
// * Pro or higher account plan with Zoom phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_outbound_calling_rules:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// GET /phone/outbound_calling/exception_rules
func (c *Client) ListAccountOutboundCallingExceptionRule(ctx context.Context, params ListAccountOutboundCallingExceptionRuleParams) (*ListAccountOutboundCallingExceptionRuleOK, error) {
	res, err := c.sendListAccountOutboundCallingExceptionRule(ctx, params)
	return res, err
}

func (c *Client) sendListAccountOutboundCallingExceptionRule(ctx context.Context, params ListAccountOutboundCallingExceptionRuleParams) (res *ListAccountOutboundCallingExceptionRuleOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAccountOutboundCallingExceptionRule"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/outbound_calling/exception_rules"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListAccountOutboundCallingExceptionRule",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/outbound_calling/exception_rules"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "country" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "country",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Country.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "keyword" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "keyword",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Keyword.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "match_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "match_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.MatchType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Status.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListAccountOutboundCallingExceptionRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListAccountOutboundCallingExceptionRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListAccountOutboundCallingExceptionRuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListAccountPhoneNumbers invokes listAccountPhoneNumbers operation.
//
// Returns a list all Zoom Phone numbers in a Zoom account.
// **Prerequisites:**
// * A Pro or higher account plan
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_numbers:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// GET /phone/numbers
func (c *Client) ListAccountPhoneNumbers(ctx context.Context, params ListAccountPhoneNumbersParams) (*ListAccountPhoneNumbersOK, error) {
	res, err := c.sendListAccountPhoneNumbers(ctx, params)
	return res, err
}

func (c *Client) sendListAccountPhoneNumbers(ctx context.Context, params ListAccountPhoneNumbersParams) (res *ListAccountPhoneNumbersOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAccountPhoneNumbers"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/numbers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListAccountPhoneNumbers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/numbers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "extension_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "extension_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ExtensionType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "number_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "number_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NumberType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pending_numbers" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pending_numbers",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PendingNumbers.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "site_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "site_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SiteID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListAccountPhoneNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListAccountPhoneNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListAccountPhoneNumbersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListAccountProvisionTemplate invokes listAccountProvisionTemplate operation.
//
// Use this API to list all [provision templates](https://support.zoom.
// us/hc/en-us/articles/360035817952) in a Zoom account.
// **Prerequisites:**
// * A Pro or higher account plan
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_provision_templates:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /phone/provision_templates
func (c *Client) ListAccountProvisionTemplate(ctx context.Context, params ListAccountProvisionTemplateParams) (*ListAccountProvisionTemplateOK, error) {
	res, err := c.sendListAccountProvisionTemplate(ctx, params)
	return res, err
}

func (c *Client) sendListAccountProvisionTemplate(ctx context.Context, params ListAccountProvisionTemplateParams) (res *ListAccountProvisionTemplateOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAccountProvisionTemplate"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/provision_templates"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListAccountProvisionTemplate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/provision_templates"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListAccountProvisionTemplate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListAccountProvisionTemplate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListAccountProvisionTemplateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListAccountSMSCampaigns invokes listAccountSMSCampaigns operation.
//
// Use this API to list all SMS campaigns in a Zoom account.
// **Prerequisites:**
// * A Pro or higher account plan
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_sms_campaigns:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /phone/sms_campaigns
func (c *Client) ListAccountSMSCampaigns(ctx context.Context, params ListAccountSMSCampaignsParams) (*ListAccountSMSCampaignsOK, error) {
	res, err := c.sendListAccountSMSCampaigns(ctx, params)
	return res, err
}

func (c *Client) sendListAccountSMSCampaigns(ctx context.Context, params ListAccountSMSCampaignsParams) (res *ListAccountSMSCampaignsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAccountSMSCampaigns"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/sms_campaigns"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListAccountSMSCampaigns",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/sms_campaigns"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListAccountSMSCampaigns", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListAccountSMSCampaigns", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListAccountSMSCampaignsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListActivationCodes invokes listActivationCodes operation.
//
// Returns a list of activation code information of the common areas under an account.
// **Note**: This API serves customers who opted for `Common Area Optimization`.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_common_area_activation_codes:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`
// **Not supported in Gov cluster**.
//
// GET /phone/common_areas/activation_codes
func (c *Client) ListActivationCodes(ctx context.Context, params ListActivationCodesParams) (*ListActivationCodesOK, error) {
	res, err := c.sendListActivationCodes(ctx, params)
	return res, err
}

func (c *Client) sendListActivationCodes(ctx context.Context, params ListActivationCodesParams) (res *ListActivationCodesOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listActivationCodes"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/common_areas/activation_codes"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListActivationCodes",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/common_areas/activation_codes"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListActivationCodes", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListActivationCodes", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListActivationCodesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListAlertSettingsWithPagingQuery invokes ListAlertSettingsWithPagingQuery operation.
//
// Gets [alert settings](https://support.zoom.us/hc/en-us/articles/7146944434445) for an account with
// paging query.
// **Prerequisites**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_alert_settings:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// GET /phone/alert_settings
func (c *Client) ListAlertSettingsWithPagingQuery(ctx context.Context, params ListAlertSettingsWithPagingQueryParams) (*ListAlertSettingsWithPagingQueryOK, error) {
	res, err := c.sendListAlertSettingsWithPagingQuery(ctx, params)
	return res, err
}

func (c *Client) sendListAlertSettingsWithPagingQuery(ctx context.Context, params ListAlertSettingsWithPagingQueryParams) (res *ListAlertSettingsWithPagingQueryOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ListAlertSettingsWithPagingQuery"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/alert_settings"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListAlertSettingsWithPagingQuery",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/alert_settings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "module" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "module",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Module.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "rule" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "rule",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Rule.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Status.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListAlertSettingsWithPagingQuery", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListAlertSettingsWithPagingQuery", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListAlertSettingsWithPagingQueryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListAudioItems invokes ListAudioItems operation.
//
// Returns personal audios. Only the admin or user can query your audios and directly pass the `me`
// value instead of the `userId` parameter.
// **Prerequisites:**
// * Business or Education account
// * Zoom Phone license
// **Scopes:** `phone:read`,`phone:read:admin`
// **Granular Scopes:** `phone:read:list_audios`,`phone:read:list_audios:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// GET /phone/users/{userId}/audios
func (c *Client) ListAudioItems(ctx context.Context, params ListAudioItemsParams) (*ListAudioItemsOK, error) {
	res, err := c.sendListAudioItems(ctx, params)
	return res, err
}

func (c *Client) sendListAudioItems(ctx context.Context, params ListAudioItemsParams) (res *ListAudioItemsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ListAudioItems"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/users/{userId}/audios"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListAudioItems",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/audios"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListAudioItems", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListAudioItems", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListAudioItemsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListAutoReceptionists invokes listAutoReceptionists operation.
//
// Returns a list of auto receptionists.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license.
// * Account owner or admin permissions.
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_auto_receptionists:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /phone/auto_receptionists
func (c *Client) ListAutoReceptionists(ctx context.Context, params ListAutoReceptionistsParams) (*ListAutoReceptionistsOK, error) {
	res, err := c.sendListAutoReceptionists(ctx, params)
	return res, err
}

func (c *Client) sendListAutoReceptionists(ctx context.Context, params ListAutoReceptionistsParams) (res *ListAutoReceptionistsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAutoReceptionists"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/auto_receptionists"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListAutoReceptionists",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/auto_receptionists"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListAutoReceptionists", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListAutoReceptionists", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListAutoReceptionistsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListBYOCSIPTrunk invokes listBYOCSIPTrunk operation.
//
// Use this API to return a list of an account's assigned [BYOC (Bring Your Own Carrier) SIP (Session
// Initiation Protocol) trunks](https://zoom.us/docs/doc/Zoom-Bring%20Your%20Own%20Carrier.pdf).
// **Prerequisites:**
// * A Business or Enterprise account
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_sip_trunks:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /phone/sip_trunk/trunks
func (c *Client) ListBYOCSIPTrunk(ctx context.Context, params ListBYOCSIPTrunkParams) (*ListBYOCSIPTrunkOK, error) {
	res, err := c.sendListBYOCSIPTrunk(ctx, params)
	return res, err
}

func (c *Client) sendListBYOCSIPTrunk(ctx context.Context, params ListBYOCSIPTrunkParams) (res *ListBYOCSIPTrunkOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listBYOCSIPTrunk"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/sip_trunk/trunks"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListBYOCSIPTrunk",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/sip_trunk/trunks"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListBYOCSIPTrunk", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListBYOCSIPTrunk", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListBYOCSIPTrunkResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListBillingAccount invokes listBillingAccount operation.
//
// A Zoom account owner or a user with admin privileges can use this API to retrieve a list of
// billing accounts.
// **Prerequisites:**
// * Pro or higher account plan with Zoom phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_billing_accounts:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /phone/billing_accounts
func (c *Client) ListBillingAccount(ctx context.Context) (*ListBillingAccountOK, error) {
	res, err := c.sendListBillingAccount(ctx)
	return res, err
}

func (c *Client) sendListBillingAccount(ctx context.Context) (res *ListBillingAccountOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listBillingAccount"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/billing_accounts"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListBillingAccount",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/billing_accounts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListBillingAccount", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListBillingAccount", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListBillingAccountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListBlockedList invokes listBlockedList operation.
//
// A Zoom account owner or a user with admin privilege can block phone numbers for phone users in an
// account. Blocked numbers can be inbound (numbers will be blocked from calling in) and outbound
// (phone users in your account won't be able to dial those numbers). Blocked callers will hear a
// generic message stating that the person they are calling is not available.
// Use this API to list all the blocked lists in an acccount.
// **Prerequisites:**
// * Pro or higher account plan with Zoom phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_blocked_lists:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /phone/blocked_list
func (c *Client) ListBlockedList(ctx context.Context, params ListBlockedListParams) (*ListBlockedListOK, error) {
	res, err := c.sendListBlockedList(ctx, params)
	return res, err
}

func (c *Client) sendListBlockedList(ctx context.Context, params ListBlockedListParams) (res *ListBlockedListOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listBlockedList"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/blocked_list"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListBlockedList",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/blocked_list"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListBlockedList", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListBlockedList", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListBlockedListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListCRPhoneNumbers invokes listCRPhoneNumbers operation.
//
// Use this API to list phone numbers in a carrier reseller (master) account that can be pushed to
// its subaccounts.
// **Prerequisites:**
// * A Pro or higher account plan
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_carrier_numbers:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /phone/carrier_reseller/numbers
func (c *Client) ListCRPhoneNumbers(ctx context.Context, params ListCRPhoneNumbersParams) (*ListCRPhoneNumbersOK, error) {
	res, err := c.sendListCRPhoneNumbers(ctx, params)
	return res, err
}

func (c *Client) sendListCRPhoneNumbers(ctx context.Context, params ListCRPhoneNumbersParams) (res *ListCRPhoneNumbersOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCRPhoneNumbers"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/carrier_reseller/numbers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListCRPhoneNumbers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/carrier_reseller/numbers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "assigned_status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "assigned_status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AssignedStatus.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sub_account_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sub_account_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SubAccountID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "keyword" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "keyword",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Keyword.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListCRPhoneNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListCRPhoneNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListCRPhoneNumbersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListCallLogsMetrics invokes listCallLogsMetrics operation.
//
// Lists the monthly call logs metrics. You can use query parameters to filter the response by date,
// site and MOS(Mean Opinion Score) of the call.The call logs that provide a record of all incoming
// and outgoing calls over Zoom Phone in an account.
// **Prerequisites:**
// * Business, or Education account
// * Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_call_logs:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Heavy`.
//
// GET /phone/metrics/call_logs
func (c *Client) ListCallLogsMetrics(ctx context.Context, params ListCallLogsMetricsParams) (*ListCallLogsMetricsOK, error) {
	res, err := c.sendListCallLogsMetrics(ctx, params)
	return res, err
}

func (c *Client) sendListCallLogsMetrics(ctx context.Context, params ListCallLogsMetricsParams) (res *ListCallLogsMetricsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCallLogsMetrics"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/metrics/call_logs"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListCallLogsMetrics",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/metrics/call_logs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "from" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "from",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.From.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "to" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "to",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.To.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "site_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "site_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SiteID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "quality_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "quality_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.QualityType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListCallLogsMetrics", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListCallLogsMetrics", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListCallLogsMetricsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListCallQueueMembers invokes listCallQueueMembers operation.
//
// Lists the call queue members.
// **Prerequisites:**
// * Pro, Business, or Education account
// * Account owner or admin permissions
// * Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_call_queue_members:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /phone/call_queues/{callQueueId}/members
func (c *Client) ListCallQueueMembers(ctx context.Context, params ListCallQueueMembersParams) (*ListCallQueueMembersOK, error) {
	res, err := c.sendListCallQueueMembers(ctx, params)
	return res, err
}

func (c *Client) sendListCallQueueMembers(ctx context.Context, params ListCallQueueMembersParams) (res *ListCallQueueMembersOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCallQueueMembers"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/call_queues/{callQueueId}/members"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListCallQueueMembers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/call_queues/"
	{
		// Encode "callQueueId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "callQueueId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallQueueId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListCallQueueMembers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListCallQueueMembers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListCallQueueMembersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListCallQueues invokes listCallQueues operation.
//
// Call queues allow you to route incoming calls to a group of users. For instance, you can use call
// queues to route calls to various departments in your organization such as sales, engineering,
// billing, customer service etc.
// Use this API to list Call queues.
// **Prerequisites:**
// * Pro, Business, or Education account
// * Account owner or admin permissions
// * Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_call_queues:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /phone/call_queues
func (c *Client) ListCallQueues(ctx context.Context, params ListCallQueuesParams) (*ListCallQueuesOK, error) {
	res, err := c.sendListCallQueues(ctx, params)
	return res, err
}

func (c *Client) sendListCallQueues(ctx context.Context, params ListCallQueuesParams) (res *ListCallQueuesOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCallQueues"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/call_queues"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListCallQueues",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/call_queues"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "site_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "site_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SiteID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "cost_center" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cost_center",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CostCenter.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "department" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "department",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Department.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListCallQueues", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListCallQueues", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListCallQueuesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListCallingPlans invokes listCallingPlans operation.
//
// Use this API to return all of an account's Zoom Phone [calling plans](https://marketplace.zoom.
// us/docs/api-reference/other-references/plans#zoom-phone-calling-plans).
// **Prerequisites:**
// * A Pro or a higher account
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_calling_plans:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /phone/calling_plans
func (c *Client) ListCallingPlans(ctx context.Context) (*ListCallingPlansOK, error) {
	res, err := c.sendListCallingPlans(ctx)
	return res, err
}

func (c *Client) sendListCallingPlans(ctx context.Context) (res *ListCallingPlansOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCallingPlans"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/calling_plans"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListCallingPlans",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/calling_plans"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListCallingPlans", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListCallingPlans", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListCallingPlansResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListCarrierPeeringPhoneNumbers invokes listCarrierPeeringPhoneNumbers operation.
//
// Returns phone numbers pushed by the carrier to different customers.
// To become a peering provider/ carrier, submit your [request](https://docs.google.
// com/forms/d/e/1FAIpQLSewkY6ixVyKVNkWC-vgmejC16gigxsJWXji3dWzE3XlWtjsgg/viewform).
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`,`phone_peering:read:admin`
// **Granular Scopes:** `phone:read:list_peering_numbers:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /phone/carrier_peering/numbers
func (c *Client) ListCarrierPeeringPhoneNumbers(ctx context.Context, params ListCarrierPeeringPhoneNumbersParams) (*ListCarrierPeeringPhoneNumbersOK, error) {
	res, err := c.sendListCarrierPeeringPhoneNumbers(ctx, params)
	return res, err
}

func (c *Client) sendListCarrierPeeringPhoneNumbers(ctx context.Context, params ListCarrierPeeringPhoneNumbersParams) (res *ListCarrierPeeringPhoneNumbersOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCarrierPeeringPhoneNumbers"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/carrier_peering/numbers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListCarrierPeeringPhoneNumbers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/carrier_peering/numbers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "phone_number" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "phone_number",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PhoneNumber.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListCarrierPeeringPhoneNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListCarrierPeeringPhoneNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListCarrierPeeringPhoneNumbersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListCommonAreaOutboundCallingExceptionRule invokes listCommonAreaOutboundCallingExceptionRule operation.
//
// Lists the common area level outbound calling policy exception rules.
// **Prerequisite:**
// * Pro or higher account plan with Zoom phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:common_area_outbound_calling_rule:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// GET /phone/common_areas/{commonAreaId}/outbound_calling/exception_rules
func (c *Client) ListCommonAreaOutboundCallingExceptionRule(ctx context.Context, params ListCommonAreaOutboundCallingExceptionRuleParams) (*ListCommonAreaOutboundCallingExceptionRuleOK, error) {
	res, err := c.sendListCommonAreaOutboundCallingExceptionRule(ctx, params)
	return res, err
}

func (c *Client) sendListCommonAreaOutboundCallingExceptionRule(ctx context.Context, params ListCommonAreaOutboundCallingExceptionRuleParams) (res *ListCommonAreaOutboundCallingExceptionRuleOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCommonAreaOutboundCallingExceptionRule"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/common_areas/{commonAreaId}/outbound_calling/exception_rules"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListCommonAreaOutboundCallingExceptionRule",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/common_areas/"
	{
		// Encode "commonAreaId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "commonAreaId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CommonAreaId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/outbound_calling/exception_rules"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "country" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "country",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Country.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "keyword" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "keyword",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Keyword.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "match_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "match_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.MatchType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Status.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListCommonAreaOutboundCallingExceptionRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListCommonAreaOutboundCallingExceptionRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListCommonAreaOutboundCallingExceptionRuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListCommonAreas invokes listCommonAreas operation.
//
// Lists common areas under an account.
// **Note**: For use by customers who opted for `Common Area Optimization`
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:common_area:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// GET /phone/common_areas
func (c *Client) ListCommonAreas(ctx context.Context, params ListCommonAreasParams) (*ListCommonAreasOK, error) {
	res, err := c.sendListCommonAreas(ctx, params)
	return res, err
}

func (c *Client) sendListCommonAreas(ctx context.Context, params ListCommonAreasParams) (res *ListCommonAreasOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCommonAreas"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/common_areas"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListCommonAreas",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/common_areas"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListCommonAreas", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListCommonAreas", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListCommonAreasResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListCustomizeOutboundCallerNumbers invokes listCustomizeOutboundCallerNumbers operation.
//
// Retrieves phone numbers that can be used as the `account-level` customized outbound caller ID.
// Note that when multiple sites policy is enabled, users cannot manage the `account-level`
// configuration. The system will throw an exception.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license.
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_customized_number:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /phone/outbound_caller_id/customized_numbers
func (c *Client) ListCustomizeOutboundCallerNumbers(ctx context.Context, params ListCustomizeOutboundCallerNumbersParams) (*ListCustomizeOutboundCallerNumbersOK, error) {
	res, err := c.sendListCustomizeOutboundCallerNumbers(ctx, params)
	return res, err
}

func (c *Client) sendListCustomizeOutboundCallerNumbers(ctx context.Context, params ListCustomizeOutboundCallerNumbersParams) (res *ListCustomizeOutboundCallerNumbersOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCustomizeOutboundCallerNumbers"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/outbound_caller_id/customized_numbers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListCustomizeOutboundCallerNumbers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/outbound_caller_id/customized_numbers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "selected" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "selected",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Selected.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "site_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "site_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SiteID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "extension_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "extension_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ExtensionType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "keyword" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "keyword",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Keyword.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListCustomizeOutboundCallerNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListCustomizeOutboundCallerNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListCustomizeOutboundCallerNumbersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListDeviceLineKeySetting invokes listDeviceLineKeySetting operation.
//
// Use this API to get information on the Zoom Phone device [line keys](https://support.zoom.
// us/hc/en-us/articles/4402415568397-Customizing-keys-for-devices-with-multiple-users) settings and
// position.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`,`phone:read`
// **Granular Scopes:** `phone:read:device_line_keys`,`phone:read:device_line_keys:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Heavy`.
//
// GET /phone/devices/{deviceId}/line_keys
func (c *Client) ListDeviceLineKeySetting(ctx context.Context, params ListDeviceLineKeySettingParams) (*ListDeviceLineKeySettingOK, error) {
	res, err := c.sendListDeviceLineKeySetting(ctx, params)
	return res, err
}

func (c *Client) sendListDeviceLineKeySetting(ctx context.Context, params ListDeviceLineKeySettingParams) (res *ListDeviceLineKeySettingOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listDeviceLineKeySetting"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/devices/{deviceId}/line_keys"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListDeviceLineKeySetting",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/devices/"
	{
		// Encode "deviceId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "deviceId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DeviceId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/line_keys"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListDeviceLineKeySetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListDeviceLineKeySetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListDeviceLineKeySettingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListEmergencyAddresses invokes listEmergencyAddresses operation.
//
// Lists the emergency addresses.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_emergency_addresses:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /phone/emergency_addresses
func (c *Client) ListEmergencyAddresses(ctx context.Context, params ListEmergencyAddressesParams) (*ListEmergencyAddressesOK, error) {
	res, err := c.sendListEmergencyAddresses(ctx, params)
	return res, err
}

func (c *Client) sendListEmergencyAddresses(ctx context.Context, params ListEmergencyAddressesParams) (res *ListEmergencyAddressesOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listEmergencyAddresses"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/emergency_addresses"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListEmergencyAddresses",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/emergency_addresses"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "site_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "site_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SiteID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "user_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "user_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.UserID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "level" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "level",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Level.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Status.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "address_keyword" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "address_keyword",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AddressKeyword.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListEmergencyAddresses", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListEmergencyAddresses", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListEmergencyAddressesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListExtensionLevelInboundBlockRules invokes ListExtensionLevelInboundBlockRules operation.
//
// Returns a list of the given extension's block rule for inbound calls and messaging.
// it lists inbound block rule for the given Call Queue, Auto Receptionist, Shared Line Group, Common
// Area, Zoom Room, or User.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// **Scopes:** `phone:read:admin`,`phone:read`
// **Granular Scopes:** `phone:read:list_extension_inbound_block_rules:admin`,
// `phone:read:list_extension_inbound_block_rules`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// GET /phone/extension/{extensionId}/inbound_blocked/rules
func (c *Client) ListExtensionLevelInboundBlockRules(ctx context.Context, params ListExtensionLevelInboundBlockRulesParams) (*ListExtensionLevelInboundBlockRulesOK, error) {
	res, err := c.sendListExtensionLevelInboundBlockRules(ctx, params)
	return res, err
}

func (c *Client) sendListExtensionLevelInboundBlockRules(ctx context.Context, params ListExtensionLevelInboundBlockRulesParams) (res *ListExtensionLevelInboundBlockRulesOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ListExtensionLevelInboundBlockRules"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/extension/{extensionId}/inbound_blocked/rules"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListExtensionLevelInboundBlockRules",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/extension/"
	{
		// Encode "extensionId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "extensionId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ExtensionId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/inbound_blocked/rules"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "keyword" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "keyword",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Keyword.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "match_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "match_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.MatchType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListExtensionLevelInboundBlockRules", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListExtensionLevelInboundBlockRules", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListExtensionLevelInboundBlockRulesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListExternalContacts invokes listExternalContacts operation.
//
// Lists the external contacts.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_external_contacts:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /phone/external_contacts
func (c *Client) ListExternalContacts(ctx context.Context, params ListExternalContactsParams) (*ListExternalContactsOK, error) {
	res, err := c.sendListExternalContacts(ctx, params)
	return res, err
}

func (c *Client) sendListExternalContacts(ctx context.Context, params ListExternalContactsParams) (res *ListExternalContactsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listExternalContacts"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/external_contacts"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListExternalContacts",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/external_contacts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListExternalContacts", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListExternalContacts", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListExternalContactsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListFirmwareRules invokes ListFirmwareRules operation.
//
// Use this API to get [firmware update rules](https://support.zoom.
// us/hc/en-us/articles/360054198852-Setting-up-firmware-update-rules).
// **Prerequisites:**
// * Business or Education account
// * Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_firmware_update_rules:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /phone/firmware_update_rules
func (c *Client) ListFirmwareRules(ctx context.Context, params ListFirmwareRulesParams) (*ListFirmwareRulesOK, error) {
	res, err := c.sendListFirmwareRules(ctx, params)
	return res, err
}

func (c *Client) sendListFirmwareRules(ctx context.Context, params ListFirmwareRulesParams) (res *ListFirmwareRulesOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ListFirmwareRules"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/firmware_update_rules"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListFirmwareRules",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/firmware_update_rules"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "site_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "site_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SiteID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListFirmwareRules", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListFirmwareRules", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListFirmwareRulesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListFirmwares invokes ListFirmwares operation.
//
// Use this API to get updatable [firmwares](https://support.zoom.
// us/hc/en-us/articles/360054198852-Setting-up-firmware-update-rules).
// **Prerequisites:**
// * Business or Education account
// * Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_firmwares:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /phone/firmwares
func (c *Client) ListFirmwares(ctx context.Context, params ListFirmwaresParams) (*ListFirmwaresOK, error) {
	res, err := c.sendListFirmwares(ctx, params)
	return res, err
}

func (c *Client) sendListFirmwares(ctx context.Context, params ListFirmwaresParams) (res *ListFirmwaresOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ListFirmwares"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/firmwares"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListFirmwares",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/firmwares"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "is_update" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "is_update",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IsUpdate.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "site_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "site_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SiteID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListFirmwares", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListFirmwares", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListFirmwaresResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListGCP invokes listGCP operation.
//
// Use this API to retrieve a list of [Group Call Pickup](https://support.zoom.
// us/hc/en-us/articles/360060107472-Setting-up-and-using-group-call-pickup) objects in an account.
// **Prerequisites:**
// * A Pro or higher account plan
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_call_pickup_groups:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /phone/group_call_pickup
func (c *Client) ListGCP(ctx context.Context, params ListGCPParams) (*ListGCPOK, error) {
	res, err := c.sendListGCP(ctx, params)
	return res, err
}

func (c *Client) sendListGCP(ctx context.Context, params ListGCPParams) (res *ListGCPOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listGCP"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/group_call_pickup"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListGCP",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/group_call_pickup"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "site_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "site_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SiteID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListGCP", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListGCP", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListGCPResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListGCPMembers invokes listGCPMembers operation.
//
// Use this API to retrieve members of a [call pickup group](https://support.zoom.
// us/hc/en-us/articles/360060107472-Setting-up-and-using-group-call-pickup) in an account.
// **Prerequisites:**
// * A Pro or higher account plan
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:call_pickup_group_member:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /phone/group_call_pickup/{groupId}/members
func (c *Client) ListGCPMembers(ctx context.Context, params ListGCPMembersParams) (*ListGCPMembersOK, error) {
	res, err := c.sendListGCPMembers(ctx, params)
	return res, err
}

func (c *Client) sendListGCPMembers(ctx context.Context, params ListGCPMembersParams) (res *ListGCPMembersOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listGCPMembers"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/group_call_pickup/{groupId}/members"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListGCPMembers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/group_call_pickup/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "site_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "site_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SiteID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "extension_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "extension_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ExtensionType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListGCPMembers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListGCPMembers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListGCPMembersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListLineKeySetting invokes listLineKeySetting operation.
//
// Use this API to get the Zoom Phone [line key settings](https://support.zoom.
// us/hc/en-us/articles/360040587552) information.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`,`phone:read`
// **Granular Scopes:** `phone:read:line_keys`,`phone:read:line_keys:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /phone/extension/{extensionId}/line_keys
func (c *Client) ListLineKeySetting(ctx context.Context, params ListLineKeySettingParams) (*ListLineKeySettingOK, error) {
	res, err := c.sendListLineKeySetting(ctx, params)
	return res, err
}

func (c *Client) sendListLineKeySetting(ctx context.Context, params ListLineKeySettingParams) (res *ListLineKeySettingOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listLineKeySetting"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/extension/{extensionId}/line_keys"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListLineKeySetting",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/extension/"
	{
		// Encode "extensionId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "extensionId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ExtensionId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/line_keys"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListLineKeySetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListLineKeySetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListLineKeySettingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListLocations invokes listLocations operation.
//
// Returns emergency service locations.
// **Note**: When you enable [multiple sites](https://support.zoom.
// us/hc/en-us/articles/360020809672-Managing-multiple-sites), the `site_id` parameter is required.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_emergency_locations:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// GET /phone/locations
func (c *Client) ListLocations(ctx context.Context, params ListLocationsParams) (*ListLocationsOK, error) {
	res, err := c.sendListLocations(ctx, params)
	return res, err
}

func (c *Client) sendListLocations(ctx context.Context, params ListLocationsParams) (res *ListLocationsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listLocations"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/locations"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListLocations",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/locations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "site_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "site_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SiteID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListLocations", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListLocations", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListLocationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListMembers invokes listMembers operation.
//
// Use this API to return members list of a [Monitoring Group](https://support.zoom.
// us/hc/en-us/articles/360044804711).
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_monitoring_group_members:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /phone/monitoring_groups/{monitoringGroupId}/monitor_members
func (c *Client) ListMembers(ctx context.Context, params ListMembersParams) (*ListMembersOK, error) {
	res, err := c.sendListMembers(ctx, params)
	return res, err
}

func (c *Client) sendListMembers(ctx context.Context, params ListMembersParams) (res *ListMembersOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listMembers"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/monitoring_groups/{monitoringGroupId}/monitor_members"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListMembers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/monitoring_groups/"
	{
		// Encode "monitoringGroupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "monitoringGroupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.MonitoringGroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/monitor_members"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "member_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "member_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.MemberType))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListMembers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListMembers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListMembersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListMonitoringGroup invokes listMonitoringGroup operation.
//
// Returns an account's [monitoring group](https://support.zoom.us/hc/en-us/articles/360044804711)
// list.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_monitoring_groups:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// GET /phone/monitoring_groups
func (c *Client) ListMonitoringGroup(ctx context.Context, params ListMonitoringGroupParams) (*ListMonitoringGroupOK, error) {
	res, err := c.sendListMonitoringGroup(ctx, params)
	return res, err
}

func (c *Client) sendListMonitoringGroup(ctx context.Context, params ListMonitoringGroupParams) (res *ListMonitoringGroupOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listMonitoringGroup"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/monitoring_groups"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListMonitoringGroup",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/monitoring_groups"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "site_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "site_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SiteID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListMonitoringGroup", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListMonitoringGroup", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListMonitoringGroupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListPastCallMetrics invokes listPastCallMetrics operation.
//
// Returns all the call logs metrics of the account from the selected time period. The call logs
// provide a record of all incoming and outgoing calls over Zoom Phone in an account. You can use
// query parameters to filter the response by metrics of the call (such as date, phone number,
// extension number and quality type).
// **Prerequisites:**
// * Business, or Education account
// * Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_call_logs:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Heavy`.
//
// GET /phone/metrics/past_calls
func (c *Client) ListPastCallMetrics(ctx context.Context, params ListPastCallMetricsParams) (*ListPastCallMetricsOK, error) {
	res, err := c.sendListPastCallMetrics(ctx, params)
	return res, err
}

func (c *Client) sendListPastCallMetrics(ctx context.Context, params ListPastCallMetricsParams) (res *ListPastCallMetricsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listPastCallMetrics"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/metrics/past_calls"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListPastCallMetrics",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/metrics/past_calls"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "from" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "from",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.From.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "to" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "to",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.To.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "phone_number" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "phone_number",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PhoneNumber.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "extension_number" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "extension_number",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ExtensionNumber.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "quality_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "quality_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.QualityType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "department" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "department",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Department.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "cost_center" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cost_center",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CostCenter.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "directions" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "directions",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.Directions != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.Directions {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "durations" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "durations",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.Durations != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.Durations {
						if err := func() error {
							return e.EncodeValue(conv.IntToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "site_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "site_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SiteID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListPastCallMetrics", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListPastCallMetrics", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListPastCallMetricsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListPeeringPhoneNumbers invokes listPeeringPhoneNumbers operation.
//
// Returns phone numbers to Zoom through the Provider Exchange.
// **Note**: Phone peering API and events are for partners who have completed the MoU to peer with
// Zoom. To become a peering provider/ carrier, submit your [request](https://docs.google.
// com/forms/d/e/1FAIpQLSewkY6ixVyKVNkWC-vgmejC16gigxsJWXji3dWzE3XlWtjsgg/viewform).
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`,`phone_peering:read:admin`
// **Granular Scopes:** `phone:read:list_peering_numbers:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /phone/peering/numbers
func (c *Client) ListPeeringPhoneNumbers(ctx context.Context, params ListPeeringPhoneNumbersParams) (*ListPeeringPhoneNumbersOK, error) {
	res, err := c.sendListPeeringPhoneNumbers(ctx, params)
	return res, err
}

func (c *Client) sendListPeeringPhoneNumbers(ctx context.Context, params ListPeeringPhoneNumbersParams) (res *ListPeeringPhoneNumbersOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listPeeringPhoneNumbers"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/peering/numbers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListPeeringPhoneNumbers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/peering/numbers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "phone_number" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "phone_number",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PhoneNumber.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "carrier_code" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "carrier_code",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CarrierCode.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListPeeringPhoneNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListPeeringPhoneNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListPeeringPhoneNumbersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListPhoneDevices invokes listPhoneDevices operation.
//
// Lists all the [desk phone devices](https://support.zoom.us/hc/en-us/articles/360021119092) that
// are configured with Zoom Phone on an account.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_devices:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// GET /phone/devices
func (c *Client) ListPhoneDevices(ctx context.Context, params ListPhoneDevicesParams) (*ListPhoneDevicesOK, error) {
	res, err := c.sendListPhoneDevices(ctx, params)
	return res, err
}

func (c *Client) sendListPhoneDevices(ctx context.Context, params ListPhoneDevicesParams) (res *ListPhoneDevicesOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listPhoneDevices"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/devices"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListPhoneDevices",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/devices"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Type))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "assignee_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "assignee_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AssigneeType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "device_source" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "device_source",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DeviceSource.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "location_status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "location_status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.LocationStatus.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "site_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "site_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SiteID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "device_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "device_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DeviceType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "keyword" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "keyword",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Keyword.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListPhoneDevices", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListPhoneDevices", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListPhoneDevicesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListPhonePlans invokes listPhonePlans operation.
//
// Use this API to return all of an account's Zoom Phone [plan package](https://marketplace.zoom.
// us/docs/api-reference/other-references/plans#additional-zoom-phone-plans-and-codes), phone number
// usage and availability.
// **Prerequisites:**
// * A Pro or a higher account
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_calling_plans:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /phone/plans
func (c *Client) ListPhonePlans(ctx context.Context) (*ListPhonePlansOK, error) {
	res, err := c.sendListPhonePlans(ctx)
	return res, err
}

func (c *Client) sendListPhonePlans(ctx context.Context) (res *ListPhonePlansOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listPhonePlans"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/plans"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListPhonePlans",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/plans"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListPhonePlans", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListPhonePlans", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListPhonePlansResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListPhoneRoles invokes ListPhoneRoles operation.
//
// Use this API to get phone roles.
// **Prerequisites:**
// * Business or Education account
// * Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_roles:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /phone/roles
func (c *Client) ListPhoneRoles(ctx context.Context) (*ListPhoneRolesOK, error) {
	res, err := c.sendListPhoneRoles(ctx)
	return res, err
}

func (c *Client) sendListPhoneRoles(ctx context.Context) (res *ListPhoneRolesOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ListPhoneRoles"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/roles"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListPhoneRoles",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/roles"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListPhoneRoles", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListPhoneRoles", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListPhoneRolesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListPhoneSites invokes listPhoneSites operation.
//
// Sites allow you to organize Zoom Phone users in your organization. Use this API to list all the
// [sites](https://support.zoom.us/hc/en-us/articles/360020809672) that have been created for an
// account.
// **Prerequisites:**
// * Multiple Sites must be [enabled](https://support.zoom.
// us/hc/en-us/articles/360020809672-Managing-Multiple-Sites#h_05c88e35-1593-491f-b1a8-b7139a75dc15).
// * Pro or a higher account with Zoom Phone enabled.
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_sites:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /phone/sites
func (c *Client) ListPhoneSites(ctx context.Context, params ListPhoneSitesParams) (*ListPhoneSitesOK, error) {
	res, err := c.sendListPhoneSites(ctx, params)
	return res, err
}

func (c *Client) sendListPhoneSites(ctx context.Context, params ListPhoneSitesParams) (res *ListPhoneSitesOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listPhoneSites"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/sites"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListPhoneSites",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/sites"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListPhoneSites", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListPhoneSites", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListPhoneSitesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListPhoneUsers invokes listPhoneUsers operation.
//
// Returns a list of all of an account's users who are assigned a Zoom Phone license.
// **Prerequisites:**
// * A Pro or higher account plan
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_users:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// GET /phone/users
func (c *Client) ListPhoneUsers(ctx context.Context, params ListPhoneUsersParams) (*ListPhoneUsersOK, error) {
	res, err := c.sendListPhoneUsers(ctx, params)
	return res, err
}

func (c *Client) sendListPhoneUsers(ctx context.Context, params ListPhoneUsersParams) (res *ListPhoneUsersOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listPhoneUsers"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/users"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListPhoneUsers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/users"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "site_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "site_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SiteID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "calling_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "calling_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CallingType.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Status.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "department" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "department",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Department.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "cost_center" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cost_center",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CostCenter.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "keyword" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "keyword",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Keyword.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListPhoneUsers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListPhoneUsers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListPhoneUsersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListPortedNumbers invokes listPortedNumbers operation.
//
// Use this API to list ported numbers in a Zoom account.
// **Prerequisites:**
// * A Pro or higher account plan
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`,`phone_peering:read:admin`
// **Granular Scopes:** `phone:read:list_ported_numbers:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /phone/ported_numbers/orders
func (c *Client) ListPortedNumbers(ctx context.Context, params ListPortedNumbersParams) (*ListPortedNumbersOK, error) {
	res, err := c.sendListPortedNumbers(ctx, params)
	return res, err
}

func (c *Client) sendListPortedNumbers(ctx context.Context, params ListPortedNumbersParams) (res *ListPortedNumbersOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listPortedNumbers"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/ported_numbers/orders"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListPortedNumbers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/ported_numbers/orders"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListPortedNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListPortedNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListPortedNumbersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListRoleMembers invokes ListRoleMembers operation.
//
// Use this API to get members (not) in a [role](https://support.zoom.
// us/hc/en-us/articles/360042099012-Using-Zoom-Phone-role-management).
// **Prerequisites:**
// * Business or Education account
// * Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:role_member:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /phone/roles/{roleId}/members
func (c *Client) ListRoleMembers(ctx context.Context, params ListRoleMembersParams) (*ListRoleMembersOK, error) {
	res, err := c.sendListRoleMembers(ctx, params)
	return res, err
}

func (c *Client) sendListRoleMembers(ctx context.Context, params ListRoleMembersParams) (res *ListRoleMembersOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ListRoleMembers"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/roles/{roleId}/members"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListRoleMembers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/roles/"
	{
		// Encode "roleId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "roleId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "in_role" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "in_role",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.InRole.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListRoleMembers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListRoleMembers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListRoleMembersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListRoutingRule invokes listRoutingRule operation.
//
// Returns a list of directory backup routing rules. The directory backup routing rules are a series
// of predefined Regular Expressions. These rules are used to route outgoing calls. If a dialed
// number does not match a Zoom Phone user, and does not match a defined External Contact, these
// rules are tested next. If a dialed number does not match any rules, the call will be routed via
// the PSTN. **Prerequisites:** * A Business or Enterprise account * A Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_routing_rules:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /phone/routing_rules
func (c *Client) ListRoutingRule(ctx context.Context, params ListRoutingRuleParams) ([]ListRoutingRuleOKItem, error) {
	res, err := c.sendListRoutingRule(ctx, params)
	return res, err
}

func (c *Client) sendListRoutingRule(ctx context.Context, params ListRoutingRuleParams) (res []ListRoutingRuleOKItem, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listRoutingRule"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/routing_rules"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListRoutingRule",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/routing_rules"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "site_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "site_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SiteID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListRoutingRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListRoutingRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListRoutingRuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListSettingTemplates invokes listSettingTemplates operation.
//
// Gets a list of all the created phone template settings.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_setting_templates:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /phone/setting_templates
func (c *Client) ListSettingTemplates(ctx context.Context, params ListSettingTemplatesParams) (*ListSettingTemplatesOK, error) {
	res, err := c.sendListSettingTemplates(ctx, params)
	return res, err
}

func (c *Client) sendListSettingTemplates(ctx context.Context, params ListSettingTemplatesParams) (res *ListSettingTemplatesOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listSettingTemplates"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/setting_templates"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListSettingTemplates",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/setting_templates"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "site_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "site_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SiteID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListSettingTemplates", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListSettingTemplates", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListSettingTemplatesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListSharedLineAppearances invokes listSharedLineAppearances operation.
//
// Use this API to list [shared line appearance](https://support.zoom.
// us/hc/en-us/articles/4406753208461-Enabling-or-disabling-shared-lines-privacy-mode) instances.
// **Prerequisites:**
// * Pro or higher account with Zoom Phone license
// * Account owner or admin privileges
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_shared_line_appearances:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /phone/shared_line_appearances
func (c *Client) ListSharedLineAppearances(ctx context.Context, params ListSharedLineAppearancesParams) (*ListSharedLineAppearancesOK, error) {
	res, err := c.sendListSharedLineAppearances(ctx, params)
	return res, err
}

func (c *Client) sendListSharedLineAppearances(ctx context.Context, params ListSharedLineAppearancesParams) (res *ListSharedLineAppearancesOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listSharedLineAppearances"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/shared_line_appearances"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListSharedLineAppearances",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/shared_line_appearances"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListSharedLineAppearances", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListSharedLineAppearances", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListSharedLineAppearancesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListSharedLineGroups invokes listSharedLineGroups operation.
//
// Lists all the shared line groups. A [shared line group](https://support.zoom.
// us/hc/en-us/articles/360038850792) allows Zoom Phone admins to share a phone number and extension
// with a group of phone users or common areas. This capability gives members of the shared line
// group access to the group's direct phone number and voicemail.
// **Prerequisites:**
// * Pro or higher account with Zoom Phone license.
// * Account owner or admin privileges
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_shared_line_groups:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /phone/shared_line_groups
func (c *Client) ListSharedLineGroups(ctx context.Context, params ListSharedLineGroupsParams) (*ListSharedLineGroupsOK, error) {
	res, err := c.sendListSharedLineGroups(ctx, params)
	return res, err
}

func (c *Client) sendListSharedLineGroups(ctx context.Context, params ListSharedLineGroupsParams) (res *ListSharedLineGroupsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listSharedLineGroups"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/shared_line_groups"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListSharedLineGroups",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/shared_line_groups"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListSharedLineGroups", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListSharedLineGroups", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListSharedLineGroupsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListSipGroups invokes listSipGroups operation.
//
// Use this API to list SIP (Session Initiation Protocol) groups.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_sip_groups:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /phone/sip_groups
func (c *Client) ListSipGroups(ctx context.Context, params ListSipGroupsParams) (*ListSipGroupsOK, error) {
	res, err := c.sendListSipGroups(ctx, params)
	return res, err
}

func (c *Client) sendListSipGroups(ctx context.Context, params ListSipGroupsParams) (res *ListSipGroupsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listSipGroups"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/sip_groups"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListSipGroups",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/sip_groups"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListSipGroups", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListSipGroups", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListSipGroupsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListSiteCustomizeOutboundCallerNumbers invokes listSiteCustomizeOutboundCallerNumbers operation.
//
// Use this API to retrieve phone numbers that can be used as the `site-level` customized outbound
// caller ID.
// * Multiple sites must be [enabled](https://support.zoom.
// us/hc/en-us/articles/360020809672-Managing-Multiple-Sites#h_05c88e35-1593-491f-b1a8-b7139a75dc15).
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license.
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_site_customized_number:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /phone/sites/{siteId}/outbound_caller_id/customized_numbers
func (c *Client) ListSiteCustomizeOutboundCallerNumbers(ctx context.Context, params ListSiteCustomizeOutboundCallerNumbersParams) (*ListSiteCustomizeOutboundCallerNumbersOK, error) {
	res, err := c.sendListSiteCustomizeOutboundCallerNumbers(ctx, params)
	return res, err
}

func (c *Client) sendListSiteCustomizeOutboundCallerNumbers(ctx context.Context, params ListSiteCustomizeOutboundCallerNumbersParams) (res *ListSiteCustomizeOutboundCallerNumbersOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listSiteCustomizeOutboundCallerNumbers"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/sites/{siteId}/outbound_caller_id/customized_numbers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListSiteCustomizeOutboundCallerNumbers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/sites/"
	{
		// Encode "siteId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "siteId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SiteId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/outbound_caller_id/customized_numbers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "selected" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "selected",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Selected.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "site_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "site_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SiteID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "extension_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "extension_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ExtensionType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "keyword" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "keyword",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Keyword.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListSiteCustomizeOutboundCallerNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListSiteCustomizeOutboundCallerNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListSiteCustomizeOutboundCallerNumbersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListSiteOutboundCallingExceptionRule invokes listSiteOutboundCallingExceptionRule operation.
//
// Lists site level outbound calling policy exception rules.*
// **Prerequisite:**
// * Pro or higher account plan with Zoom phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:site_outbound_calling_rule:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// GET /phone/sites/{siteId}/outbound_calling/exception_rules
func (c *Client) ListSiteOutboundCallingExceptionRule(ctx context.Context, params ListSiteOutboundCallingExceptionRuleParams) (*ListSiteOutboundCallingExceptionRuleOK, error) {
	res, err := c.sendListSiteOutboundCallingExceptionRule(ctx, params)
	return res, err
}

func (c *Client) sendListSiteOutboundCallingExceptionRule(ctx context.Context, params ListSiteOutboundCallingExceptionRuleParams) (res *ListSiteOutboundCallingExceptionRuleOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listSiteOutboundCallingExceptionRule"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/sites/{siteId}/outbound_calling/exception_rules"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListSiteOutboundCallingExceptionRule",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/sites/"
	{
		// Encode "siteId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "siteId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SiteId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/outbound_calling/exception_rules"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "country" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "country",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Country.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "keyword" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "keyword",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Keyword.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "match_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "match_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.MatchType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Status.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListSiteOutboundCallingExceptionRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListSiteOutboundCallingExceptionRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListSiteOutboundCallingExceptionRuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListTrackedLocations invokes listTrackedLocations operation.
//
// Lists the tracked locations.
// **Prerequisites:**
// * Pro or higher account plan with Zoom phone license
// * Account owner or admin permissions
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_tracked_locations:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /phone/metrics/location_tracking
func (c *Client) ListTrackedLocations(ctx context.Context, params ListTrackedLocationsParams) (*ListTrackedLocationsOK, error) {
	res, err := c.sendListTrackedLocations(ctx, params)
	return res, err
}

func (c *Client) sendListTrackedLocations(ctx context.Context, params ListTrackedLocationsParams) (res *ListTrackedLocationsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listTrackedLocations"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/metrics/location_tracking"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListTrackedLocations",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/metrics/location_tracking"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "site_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "site_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SiteID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "location_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "location_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.LocationType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "keyword" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "keyword",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Keyword.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListTrackedLocations", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListTrackedLocations", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListTrackedLocationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListUnassignedZoomRooms invokes listUnassignedZoomRooms operation.
//
// Use this API to retrieve [Zoom Rooms](https://support.zoom.us/hc/en-us/articles/360025153711) that
// are not assigned a Zoom Phone.
// **Prerequisites:**
// * A Pro or higher account plan
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_rooms:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /phone/rooms/unassigned
func (c *Client) ListUnassignedZoomRooms(ctx context.Context, params ListUnassignedZoomRoomsParams) (*ListUnassignedZoomRoomsOK, error) {
	res, err := c.sendListUnassignedZoomRooms(ctx, params)
	return res, err
}

func (c *Client) sendListUnassignedZoomRooms(ctx context.Context, params ListUnassignedZoomRoomsParams) (res *ListUnassignedZoomRoomsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listUnassignedZoomRooms"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/rooms/unassigned"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListUnassignedZoomRooms",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/rooms/unassigned"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "keyword" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "keyword",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Keyword.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListUnassignedZoomRooms", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListUnassignedZoomRooms", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListUnassignedZoomRoomsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListUserCustomizeOutboundCallerNumbers invokes listUserCustomizeOutboundCallerNumbers operation.
//
// Retrieves phone numbers that can be the `user-level` customized outbound caller ID.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license.
// **Scopes:** `phone:read:admin`,`phone:read`
// **Granular Scopes:** `phone:read:list_user_customized_number`,
// `phone:read:list_user_customized_number:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /phone/users/{userId}/outbound_caller_id/customized_numbers
func (c *Client) ListUserCustomizeOutboundCallerNumbers(ctx context.Context, params ListUserCustomizeOutboundCallerNumbersParams) (*ListUserCustomizeOutboundCallerNumbersOK, error) {
	res, err := c.sendListUserCustomizeOutboundCallerNumbers(ctx, params)
	return res, err
}

func (c *Client) sendListUserCustomizeOutboundCallerNumbers(ctx context.Context, params ListUserCustomizeOutboundCallerNumbersParams) (res *ListUserCustomizeOutboundCallerNumbersOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listUserCustomizeOutboundCallerNumbers"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/users/{userId}/outbound_caller_id/customized_numbers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListUserCustomizeOutboundCallerNumbers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/outbound_caller_id/customized_numbers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "selected" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "selected",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Selected.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "site_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "site_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SiteID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "extension_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "extension_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ExtensionType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "keyword" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "keyword",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Keyword.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListUserCustomizeOutboundCallerNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListUserCustomizeOutboundCallerNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListUserCustomizeOutboundCallerNumbersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListUserOutboundCallingExceptionRule invokes listUserOutboundCallingExceptionRule operation.
//
// Lists the user level outbound calling policy exception rules.
// **Prerequisite:**
// * Pro or higher account plan with Zoom phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:user_outbound_calling_rule:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// GET /phone/users/{userId}/outbound_calling/exception_rules
func (c *Client) ListUserOutboundCallingExceptionRule(ctx context.Context, params ListUserOutboundCallingExceptionRuleParams) (*ListUserOutboundCallingExceptionRuleOK, error) {
	res, err := c.sendListUserOutboundCallingExceptionRule(ctx, params)
	return res, err
}

func (c *Client) sendListUserOutboundCallingExceptionRule(ctx context.Context, params ListUserOutboundCallingExceptionRuleParams) (res *ListUserOutboundCallingExceptionRuleOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listUserOutboundCallingExceptionRule"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/users/{userId}/outbound_calling/exception_rules"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListUserOutboundCallingExceptionRule",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/outbound_calling/exception_rules"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "country" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "country",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Country.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "keyword" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "keyword",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Keyword.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "match_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "match_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.MatchType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Status.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListUserOutboundCallingExceptionRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListUserOutboundCallingExceptionRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListUserOutboundCallingExceptionRuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListUsersFromDirectory invokes ListUsersFromDirectory operation.
//
// Use this API to get users that are in or not in a [directory](https://support.zoom.
// us/hc/en-us/articles/4404938949389-Using-a-dial-by-name-directory).
// **Prerequisites:**
// * Business or Education account
// * Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:directory:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /phone/dial_by_name_directory/extensions
func (c *Client) ListUsersFromDirectory(ctx context.Context, params ListUsersFromDirectoryParams) (*ListUsersFromDirectoryOK, error) {
	res, err := c.sendListUsersFromDirectory(ctx, params)
	return res, err
}

func (c *Client) sendListUsersFromDirectory(ctx context.Context, params ListUsersFromDirectoryParams) (res *ListUsersFromDirectoryOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ListUsersFromDirectory"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/dial_by_name_directory/extensions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListUsersFromDirectory",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/dial_by_name_directory/extensions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "in_directory" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "in_directory",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.InDirectory.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "site_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "site_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.SiteID))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListUsersFromDirectory", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListUsersFromDirectory", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListUsersFromDirectoryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListUsersFromDirectoryBySite invokes ListUsersFromDirectoryBySite operation.
//
// Use this API to get users that are in or not in a [directory](https://support.zoom.
// us/hc/en-us/articles/4404938949389-Using-a-dial-by-name-directory) of the specified site.
// **Prerequisites:**
// * Business or Education account
// * Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:directory:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /phone/sites/{siteId}/dial_by_name_directory/extensions
func (c *Client) ListUsersFromDirectoryBySite(ctx context.Context, params ListUsersFromDirectoryBySiteParams) (*ListUsersFromDirectoryBySiteOK, error) {
	res, err := c.sendListUsersFromDirectoryBySite(ctx, params)
	return res, err
}

func (c *Client) sendListUsersFromDirectoryBySite(ctx context.Context, params ListUsersFromDirectoryBySiteParams) (res *ListUsersFromDirectoryBySiteOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ListUsersFromDirectoryBySite"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/sites/{siteId}/dial_by_name_directory/extensions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListUsersFromDirectoryBySite",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/sites/"
	{
		// Encode "siteId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "siteId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SiteId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/dial_by_name_directory/extensions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "in_directory" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "in_directory",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.InDirectory.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "site_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "site_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SiteID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListUsersFromDirectoryBySite", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListUsersFromDirectoryBySite", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListUsersFromDirectoryBySiteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListZoomPhoneAccountSettings invokes listZoomPhoneAccountSettings operation.
//
// Returns an account's Zoom phone settings.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_account_settings:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// GET /phone/account_settings
func (c *Client) ListZoomPhoneAccountSettings(ctx context.Context, params ListZoomPhoneAccountSettingsParams) (*ListZoomPhoneAccountSettingsOK, error) {
	res, err := c.sendListZoomPhoneAccountSettings(ctx, params)
	return res, err
}

func (c *Client) sendListZoomPhoneAccountSettings(ctx context.Context, params ListZoomPhoneAccountSettingsParams) (res *ListZoomPhoneAccountSettingsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listZoomPhoneAccountSettings"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/account_settings"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListZoomPhoneAccountSettings",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/account_settings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "setting_types" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "setting_types",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SettingTypes.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListZoomPhoneAccountSettings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListZoomPhoneAccountSettings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListZoomPhoneAccountSettingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListZoomRooms invokes listZoomRooms operation.
//
// Retrieves a list of [Zoom Rooms](https://support.zoom.us/hc/en-us/articles/360025153711) under the
// account that has the Zoom Phone license assigned.**Prerequisites:** * A Pro or higher account plan
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:list_rooms:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// GET /phone/rooms
func (c *Client) ListZoomRooms(ctx context.Context, params ListZoomRoomsParams) (*ListZoomRoomsOK, error) {
	res, err := c.sendListZoomRooms(ctx, params)
	return res, err
}

func (c *Client) sendListZoomRooms(ctx context.Context, params ListZoomRoomsParams) (res *ListZoomRoomsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listZoomRooms"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/rooms"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListZoomRooms",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/rooms"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "site_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "site_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SiteID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "calling_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "calling_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CallingType.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "keyword" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "keyword",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Keyword.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListZoomRooms", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListZoomRooms", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListZoomRoomsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MarkPhoneNumberAsBlockedForAllExtensions invokes MarkPhoneNumberAsBlockedForAllExtensions operation.
//
// Promotes and applies the phone number blocked from the extension level blocked rule to the account
// level blocked rule. This action is contingent on the statistics of extensions blocked rule. All
// extensions under the current account block this phone number.
// **Prerequisites:**
// * Pro or higher account plan with Zoom phone license
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:inbound_blocked_for_all:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// PATCH /phone/inbound_blocked/extension_rules/statistics/blocked_for_all
func (c *Client) MarkPhoneNumberAsBlockedForAllExtensions(ctx context.Context, request OptMarkPhoneNumberAsBlockedForAllExtensionsReq) error {
	_, err := c.sendMarkPhoneNumberAsBlockedForAllExtensions(ctx, request)
	return err
}

func (c *Client) sendMarkPhoneNumberAsBlockedForAllExtensions(ctx context.Context, request OptMarkPhoneNumberAsBlockedForAllExtensionsReq) (res *MarkPhoneNumberAsBlockedForAllExtensionsNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("MarkPhoneNumberAsBlockedForAllExtensions"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/inbound_blocked/extension_rules/statistics/blocked_for_all"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "MarkPhoneNumberAsBlockedForAllExtensions",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/inbound_blocked/extension_rules/statistics/blocked_for_all"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeMarkPhoneNumberAsBlockedForAllExtensionsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "MarkPhoneNumberAsBlockedForAllExtensions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "MarkPhoneNumberAsBlockedForAllExtensions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMarkPhoneNumberAsBlockedForAllExtensionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PhoneDownloadRecordingTranscript invokes phoneDownloadRecordingTranscript operation.
//
// Downloads the phone recording transcript.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:read`,`phone:read:admin`,`phone_recording:read`,`phone_recording:read:admin`
// **Granular Scopes:** `phone:read:recording_transcript`,`phone:read:recording_transcript:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /phone/recording_transcript/download/{recordingId}
func (c *Client) PhoneDownloadRecordingTranscript(ctx context.Context, params PhoneDownloadRecordingTranscriptParams) error {
	_, err := c.sendPhoneDownloadRecordingTranscript(ctx, params)
	return err
}

func (c *Client) sendPhoneDownloadRecordingTranscript(ctx context.Context, params PhoneDownloadRecordingTranscriptParams) (res *PhoneDownloadRecordingTranscriptOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("phoneDownloadRecordingTranscript"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/recording_transcript/download/{recordingId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PhoneDownloadRecordingTranscript",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/recording_transcript/download/"
	{
		// Encode "recordingId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "recordingId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RecordingId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "PhoneDownloadRecordingTranscript", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "PhoneDownloadRecordingTranscript", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePhoneDownloadRecordingTranscriptResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PhoneSetting invokes phoneSetting operation.
//
// Returns an account's settings.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`
// **Granular Scopes:** `phone:read:settings:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /phone/settings
func (c *Client) PhoneSetting(ctx context.Context) (*PhoneSettingOK, error) {
	res, err := c.sendPhoneSetting(ctx)
	return res, err
}

func (c *Client) sendPhoneSetting(ctx context.Context) (res *PhoneSettingOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("phoneSetting"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/settings"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PhoneSetting",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/settings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "PhoneSetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "PhoneSetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePhoneSettingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PhoneUser invokes phoneUser operation.
//
// Returns a user's [Zoom phone](https://support.zoom.
// us/hc/en-us/articles/360001297663-Quickstart-Guide-for-Zoom-Phone-Administrators) profile. For
// user-level apps, pass [the `me` value](https://marketplace.zoom.
// us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`,`phone:read`
// **Granular Scopes:** `phone:read:user`,`phone:read:user:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// GET /phone/users/{userId}
func (c *Client) PhoneUser(ctx context.Context, params PhoneUserParams) (*PhoneUserOK, error) {
	res, err := c.sendPhoneUser(ctx, params)
	return res, err
}

func (c *Client) sendPhoneUser(ctx context.Context, params PhoneUserParams) (res *PhoneUserOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("phoneUser"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/users/{userId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PhoneUser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "PhoneUser", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "PhoneUser", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePhoneUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PhoneUserCallLogs invokes phoneUserCallLogs operation.
//
// Returns a user's [Zoom phone](https://support.zoom.
// us/hc/en-us/articles/360001297663-Quickstart-Guide-for-Zoom-Phone-Administrators) call logs. For
// user-level apps, pass [the `me` value](https://marketplace.zoom.
// us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:read`,`phone:read:admin`,`phone_call_log:read`,`phone_call_log:read:admin`
// **Granular Scopes:** `phone:read:list_call_logs`,`phone:read:list_call_logs:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// GET /phone/users/{userId}/call_logs
func (c *Client) PhoneUserCallLogs(ctx context.Context, params PhoneUserCallLogsParams) (*PhoneUserCallLogsOK, error) {
	res, err := c.sendPhoneUserCallLogs(ctx, params)
	return res, err
}

func (c *Client) sendPhoneUserCallLogs(ctx context.Context, params PhoneUserCallLogsParams) (res *PhoneUserCallLogsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("phoneUserCallLogs"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/users/{userId}/call_logs"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PhoneUserCallLogs",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/call_logs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "from" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "from",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.From.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "to" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "to",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.To.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "phone_number" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "phone_number",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PhoneNumber.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "time_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "time_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.TimeType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "PhoneUserCallLogs", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "PhoneUserCallLogs", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePhoneUserCallLogsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PhoneUserRecordings invokes phoneUserRecordings operation.
//
// Gets a user's [Zoom Phone recordings](https://support.zoom.
// us/hc/en-us/articles/360021336671-Viewing-Call-History-and-Recordings). For user-level apps, pass
// [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead
// of the `userId` parameter.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone_recording:read:admin`,`phone_recording:read`,`phone:read`,`phone:read:admin`
// **Granular Scopes:** `phone:read:list_recordings`,`phone:read:list_recordings:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /phone/users/{userId}/recordings
func (c *Client) PhoneUserRecordings(ctx context.Context, params PhoneUserRecordingsParams) (*PhoneUserRecordingsOK, error) {
	res, err := c.sendPhoneUserRecordings(ctx, params)
	return res, err
}

func (c *Client) sendPhoneUserRecordings(ctx context.Context, params PhoneUserRecordingsParams) (res *PhoneUserRecordingsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("phoneUserRecordings"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/users/{userId}/recordings"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PhoneUserRecordings",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/recordings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "from" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "from",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.From.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "to" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "to",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.To.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "PhoneUserRecordings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "PhoneUserRecordings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePhoneUserRecordingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PhoneUserSettings invokes phoneUserSettings operation.
//
// Gets the Zoom Phone [profile settings](https://support.zoom.
// us/hc/en-us/articles/360021325712-Configuring-Settings) of a user. For user-level apps, pass [the
// `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of
// the `userId` parameter.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`,`phone:read`
// **Granular Scopes:** `phone:read:user_setting:admin`,`phone:read:user_setting`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /phone/users/{userId}/settings
func (c *Client) PhoneUserSettings(ctx context.Context, params PhoneUserSettingsParams) (*PhoneUserSettingsOK, error) {
	res, err := c.sendPhoneUserSettings(ctx, params)
	return res, err
}

func (c *Client) sendPhoneUserSettings(ctx context.Context, params PhoneUserSettingsParams) (res *PhoneUserSettingsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("phoneUserSettings"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/users/{userId}/settings"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PhoneUserSettings",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/settings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "PhoneUserSettings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "PhoneUserSettings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePhoneUserSettingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PhoneUserVoiceMails invokes phoneUserVoiceMails operation.
//
// Use this API to get a user's Zoom Phone voicemails. For user-level apps, pass [the `me`
// value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the
// `userId` parameter.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:read`,`phone:read:admin`,`phone_voicemail:read:admin`,`phone_voicemail:read`
// **Granular Scopes:** `phone:read:list_voicemails`,`phone:read:list_voicemails:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /phone/users/{userId}/voice_mails
func (c *Client) PhoneUserVoiceMails(ctx context.Context, params PhoneUserVoiceMailsParams) (*PhoneUserVoiceMailsOK, error) {
	res, err := c.sendPhoneUserVoiceMails(ctx, params)
	return res, err
}

func (c *Client) sendPhoneUserVoiceMails(ctx context.Context, params PhoneUserVoiceMailsParams) (res *PhoneUserVoiceMailsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("phoneUserVoiceMails"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/users/{userId}/voice_mails"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PhoneUserVoiceMails",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/voice_mails"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Status.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "from" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "from",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.From.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "to" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "to",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.To.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "PhoneUserVoiceMails", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "PhoneUserVoiceMails", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePhoneUserVoiceMailsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RebootPhoneDevice invokes rebootPhoneDevice operation.
//
// Use this API to reboot an online zero-touch or assisted-provisioning device. You can only send one
// request every second.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions.
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:reboot_device:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Heavy`.
//
// POST /phone/devices/{deviceId}/reboot
func (c *Client) RebootPhoneDevice(ctx context.Context, params RebootPhoneDeviceParams) error {
	_, err := c.sendRebootPhoneDevice(ctx, params)
	return err
}

func (c *Client) sendRebootPhoneDevice(ctx context.Context, params RebootPhoneDeviceParams) (res *RebootPhoneDeviceAccepted, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("rebootPhoneDevice"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/devices/{deviceId}/reboot"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "RebootPhoneDevice",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/devices/"
	{
		// Encode "deviceId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "deviceId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DeviceId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/reboot"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "RebootPhoneDevice", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "RebootPhoneDevice", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRebootPhoneDeviceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RemoveCQPolicySubSetting invokes removeCQPolicySubSetting operation.
//
// Use this API to remove the policy sub-setting for a specific [call queue](https://support.zoom.
// us/hc/en-us/articles/360021524831) according to the `policyType`. For example, you can use this
// API to remove shared access members.
// **Prerequisites:**
// * Pro or higher account with Zoom Phone license.
// * Account owner or admin privileges
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:call_queue_policy:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/call_queues/{callQueueId}/policies/{policyType}
func (c *Client) RemoveCQPolicySubSetting(ctx context.Context, params RemoveCQPolicySubSettingParams) error {
	_, err := c.sendRemoveCQPolicySubSetting(ctx, params)
	return err
}

func (c *Client) sendRemoveCQPolicySubSetting(ctx context.Context, params RemoveCQPolicySubSettingParams) (res *RemoveCQPolicySubSettingNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("removeCQPolicySubSetting"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/call_queues/{callQueueId}/policies/{policyType}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "RemoveCQPolicySubSetting",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/call_queues/"
	{
		// Encode "callQueueId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "callQueueId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallQueueId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/policies/"
	{
		// Encode "policyType" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "policyType",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PolicyType))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "shared_ids" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "shared_ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.SharedIds {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "RemoveCQPolicySubSetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "RemoveCQPolicySubSetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRemoveCQPolicySubSettingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RemoveGCPMembers invokes removeGCPMembers operation.
//
// Use this API to remove member from the [Group Call Pickup](https://support.zoom.
// us/hc/en-us/articles/360060107472-Setting-up-and-using-group-call-pickup) object.
// **Prerequisites:**
// * A Pro or higher account plan
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:call_pickup_group_member:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/group_call_pickup/{groupId}/members/{extensionId}
func (c *Client) RemoveGCPMembers(ctx context.Context, params RemoveGCPMembersParams) error {
	_, err := c.sendRemoveGCPMembers(ctx, params)
	return err
}

func (c *Client) sendRemoveGCPMembers(ctx context.Context, params RemoveGCPMembersParams) (res *RemoveGCPMembersNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("removeGCPMembers"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/group_call_pickup/{groupId}/members/{extensionId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "RemoveGCPMembers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/group_call_pickup/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members/"
	{
		// Encode "extensionId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "extensionId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ExtensionId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "RemoveGCPMembers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "RemoveGCPMembers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRemoveGCPMembersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RemoveMember invokes removeMember operation.
//
// Use this API to remove a member from a [Monitoring Group](https://support.zoom.
// us/hc/en-us/articles/360044804711).
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:monitoring_group_member:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/monitoring_groups/{monitoringGroupId}/monitor_members/{memberExtensionId}
func (c *Client) RemoveMember(ctx context.Context, params RemoveMemberParams) error {
	_, err := c.sendRemoveMember(ctx, params)
	return err
}

func (c *Client) sendRemoveMember(ctx context.Context, params RemoveMemberParams) (res *RemoveMemberNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("removeMember"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/monitoring_groups/{monitoringGroupId}/monitor_members/{memberExtensionId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "RemoveMember",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/monitoring_groups/"
	{
		// Encode "monitoringGroupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "monitoringGroupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.MonitoringGroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/monitor_members/"
	{
		// Encode "memberExtensionId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "memberExtensionId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.MemberExtensionId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "member_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "member_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.MemberType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "RemoveMember", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "RemoveMember", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRemoveMemberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RemoveMembers invokes removeMembers operation.
//
// Use this API to remove all monitor or monitored members from a [Monitoring Group](https://support.
// zoom.us/hc/en-us/articles/360044804711).
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:monitoring_group_member:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/monitoring_groups/{monitoringGroupId}/monitor_members
func (c *Client) RemoveMembers(ctx context.Context, params RemoveMembersParams) error {
	_, err := c.sendRemoveMembers(ctx, params)
	return err
}

func (c *Client) sendRemoveMembers(ctx context.Context, params RemoveMembersParams) (res *RemoveMembersNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("removeMembers"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/monitoring_groups/{monitoringGroupId}/monitor_members"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "RemoveMembers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/monitoring_groups/"
	{
		// Encode "monitoringGroupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "monitoringGroupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.MonitoringGroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/monitor_members"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "member_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "member_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.MemberType))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "RemoveMembers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "RemoveMembers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRemoveMembersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RemoveSLGPolicySubSetting invokes removeSLGPolicySubSetting operation.
//
// Removes the policy sub-setting for a specific [shared line group](https://support.zoom.
// us/hc/en-us/articles/360038850792) according to the `policyType`. For example, you can use this
// API to remove shared access members. **Prerequisites:** * Pro or higher account with Zoom Phone
// license.* Account owner or admin privileges
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:shared_line_group_policy:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// DELETE /phone/shared_line_groups/{slgId}/policies/{policyType}
func (c *Client) RemoveSLGPolicySubSetting(ctx context.Context, params RemoveSLGPolicySubSettingParams) error {
	_, err := c.sendRemoveSLGPolicySubSetting(ctx, params)
	return err
}

func (c *Client) sendRemoveSLGPolicySubSetting(ctx context.Context, params RemoveSLGPolicySubSettingParams) (res *RemoveSLGPolicySubSettingNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("removeSLGPolicySubSetting"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/shared_line_groups/{slgId}/policies/{policyType}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "RemoveSLGPolicySubSetting",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/shared_line_groups/"
	{
		// Encode "slgId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "slgId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SlgId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/policies/"
	{
		// Encode "policyType" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "policyType",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PolicyType))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "shared_ids" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "shared_ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.SharedIds {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "RemoveSLGPolicySubSetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "RemoveSLGPolicySubSetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRemoveSLGPolicySubSettingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RemoveZoomRoom invokes RemoveZoomRoom operation.
//
// Use this API to remove [Zoom Room](https://support.zoom.
// us/hc/en-us/articles/360025153711#h_140e30ba-5a88-40b9-b799-16883fa0a037) from a Zoom Phone
// account.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:room:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/rooms/{roomId}
func (c *Client) RemoveZoomRoom(ctx context.Context, params RemoveZoomRoomParams) error {
	_, err := c.sendRemoveZoomRoom(ctx, params)
	return err
}

func (c *Client) sendRemoveZoomRoom(ctx context.Context, params RemoveZoomRoomParams) (res *RemoveZoomRoomNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("RemoveZoomRoom"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/rooms/{roomId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "RemoveZoomRoom",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/rooms/"
	{
		// Encode "roomId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "roomId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoomId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "RemoveZoomRoom", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "RemoveZoomRoom", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRemoveZoomRoomResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SmsByMessageId invokes smsByMessageId operation.
//
// Gets details about a specific message in an SMS session.
// **Prerequisites**
// * Paid account
// * User-enabled Zoom phone
// **Scopes:** `phone:read:admin`,`phone:read`,`phone_sms:read`,`phone_sms:read:admin`
// **Granular Scopes:** `phone:read:sms_message`,`phone:read:sms_message:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// GET /phone/sms/sessions/{sessionId}/messages/{messageId}
func (c *Client) SmsByMessageId(ctx context.Context, params SmsByMessageIdParams) (*SmsByMessageIdOK, error) {
	res, err := c.sendSmsByMessageId(ctx, params)
	return res, err
}

func (c *Client) sendSmsByMessageId(ctx context.Context, params SmsByMessageIdParams) (res *SmsByMessageIdOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("smsByMessageId"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/sms/sessions/{sessionId}/messages/{messageId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SmsByMessageId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/sms/sessions/"
	{
		// Encode "sessionId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sessionId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SessionId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/messages/"
	{
		// Encode "messageId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "messageId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.MessageId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "SmsByMessageId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "SmsByMessageId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSmsByMessageIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SmsSessionDetails invokes smsSessionDetails operation.
//
// Get details about an SMS session.
// **Prerequisites**
// * Paid account
// * User-enabled Zoom phone
// **Scopes:** `phone:read:admin`,`phone:read`,`phone_sms:read`,`phone_sms:read:admin`
// **Granular Scopes:** `phone:read:sms_session`,`phone:read:sms_session:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /phone/sms/sessions/{sessionId}
func (c *Client) SmsSessionDetails(ctx context.Context, params SmsSessionDetailsParams) (*SmsSessionDetailsOK, error) {
	res, err := c.sendSmsSessionDetails(ctx, params)
	return res, err
}

func (c *Client) sendSmsSessionDetails(ctx context.Context, params SmsSessionDetailsParams) (res *SmsSessionDetailsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("smsSessionDetails"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/sms/sessions/{sessionId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SmsSessionDetails",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/sms/sessions/"
	{
		// Encode "sessionId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sessionId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SessionId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "from" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "from",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.From.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "to" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "to",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.To.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "SmsSessionDetails", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "SmsSessionDetails", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSmsSessionDetailsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SmsSessionSync invokes smsSessionSync operation.
//
// Use this API to sync SMS messages in a session.
// **Prerequisites**
// * Paid account
// * User-enabled Zoom phone
// **Scopes:** `phone:read:admin`,`phone:read`,`phone_sms:read`,`phone_sms:read:admin`
// **Granular Scopes:** `phone:read:sms_session`,`phone:read:sms_session:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /phone/sms/sessions/{sessionId}/sync
func (c *Client) SmsSessionSync(ctx context.Context, params SmsSessionSyncParams) (*SmsSessionSyncOK, error) {
	res, err := c.sendSmsSessionSync(ctx, params)
	return res, err
}

func (c *Client) sendSmsSessionSync(ctx context.Context, params SmsSessionSyncParams) (res *SmsSessionSyncOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("smsSessionSync"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/sms/sessions/{sessionId}/sync"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SmsSessionSync",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/sms/sessions/"
	{
		// Encode "sessionId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sessionId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SessionId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/sync"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "sync_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sync_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SyncType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "count" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "count",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Count.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sync_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sync_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SyncToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "SmsSessionSync", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "SmsSessionSync", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSmsSessionSyncResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SyncPhoneDevice invokes syncPhoneDevice operation.
//
// Use this API to resync all online zero-touch or assisted-provisioning devices in an account or a
// site. Only allows sending one request every 15 minutes.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:write:sync_device:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Heavy`.
//
// POST /phone/devices/sync
func (c *Client) SyncPhoneDevice(ctx context.Context, request OptSyncPhoneDeviceReq) error {
	_, err := c.sendSyncPhoneDevice(ctx, request)
	return err
}

func (c *Client) sendSyncPhoneDevice(ctx context.Context, request OptSyncPhoneDeviceReq) (res *SyncPhoneDeviceNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("syncPhoneDevice"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/phone/devices/sync"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SyncPhoneDevice",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/devices/sync"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSyncPhoneDeviceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "SyncPhoneDevice", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "SyncPhoneDevice", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSyncPhoneDeviceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SyncUserCallLogs invokes syncUserCallLogs operation.
//
// Syncs a user's [Zoom phone](https://support.zoom.
// us/hc/en-us/articles/360001297663-Quickstart-Guide-for-Zoom-Phone-Administrators) call logs. For
// user-level apps, pass [the `me` value](https://marketplace.zoom.
// us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:read:admin`,`phone:read`
// **Granular Scopes:** `phone:read:list_call_logs`,`phone:read:list_call_logs:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// GET /phone/users/{userId}/call_logs/sync
func (c *Client) SyncUserCallLogs(ctx context.Context, params SyncUserCallLogsParams) (*SyncUserCallLogsOK, error) {
	res, err := c.sendSyncUserCallLogs(ctx, params)
	return res, err
}

func (c *Client) sendSyncUserCallLogs(ctx context.Context, params SyncUserCallLogsParams) (res *SyncUserCallLogsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("syncUserCallLogs"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/users/{userId}/call_logs/sync"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SyncUserCallLogs",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/call_logs/sync"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "sync_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sync_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SyncType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "count" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "count",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Count.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sync_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sync_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SyncToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "SyncUserCallLogs", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "SyncUserCallLogs", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSyncUserCallLogsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UnAssignPhoneNumCallQueue invokes unAssignPhoneNumCallQueue operation.
//
// After assigning a phone number, you can unbind it if you don't want it to be assigned to a [Call
// Queue](https://support.zoom.us/hc/en-us/articles/360021524831-Managing-Call-Queues). Use this API
// to unbind a phone number from a Call Queue. After successful unbinding, the number will appear in
// the [Unassigned tab](https://zoom.us/signin#/numbers/unassigned).
// **Prerequisites:**
// * Pro or higher account palan
// * Account owner or admin permissions
// * Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:call_queue_number:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/call_queues/{callQueueId}/phone_numbers/{phoneNumberId}
func (c *Client) UnAssignPhoneNumCallQueue(ctx context.Context, params UnAssignPhoneNumCallQueueParams) error {
	_, err := c.sendUnAssignPhoneNumCallQueue(ctx, params)
	return err
}

func (c *Client) sendUnAssignPhoneNumCallQueue(ctx context.Context, params UnAssignPhoneNumCallQueueParams) (res *UnAssignPhoneNumCallQueueNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("unAssignPhoneNumCallQueue"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/call_queues/{callQueueId}/phone_numbers/{phoneNumberId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UnAssignPhoneNumCallQueue",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/call_queues/"
	{
		// Encode "callQueueId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "callQueueId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallQueueId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/phone_numbers/"
	{
		// Encode "phoneNumberId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "phoneNumberId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PhoneNumberId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UnAssignPhoneNumCallQueue", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UnAssignPhoneNumCallQueue", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUnAssignPhoneNumCallQueueResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UnassignAPhoneNumAutoReceptionist invokes unassignAPhoneNumAutoReceptionist operation.
//
// Unassigns a specific phone number that was previously assigned to an [auto
// receptionist](https://support.zoom.
// us/hc/en-us/articles/360021121312-Managing-Auto-Receptionists-and-Interactive-Voice-Response-IVR-).
// **Prerequisites:**
// * Pro or higher account plan with Zoom Phone License
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:auto_receptionist_number:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/auto_receptionists/{autoReceptionistId}/phone_numbers/{phoneNumberId}
func (c *Client) UnassignAPhoneNumAutoReceptionist(ctx context.Context, params UnassignAPhoneNumAutoReceptionistParams) error {
	_, err := c.sendUnassignAPhoneNumAutoReceptionist(ctx, params)
	return err
}

func (c *Client) sendUnassignAPhoneNumAutoReceptionist(ctx context.Context, params UnassignAPhoneNumAutoReceptionistParams) (res *UnassignAPhoneNumAutoReceptionistNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("unassignAPhoneNumAutoReceptionist"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/auto_receptionists/{autoReceptionistId}/phone_numbers/{phoneNumberId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UnassignAPhoneNumAutoReceptionist",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/auto_receptionists/"
	{
		// Encode "autoReceptionistId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "autoReceptionistId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AutoReceptionistId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/phone_numbers/"
	{
		// Encode "phoneNumberId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "phoneNumberId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PhoneNumberId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UnassignAPhoneNumAutoReceptionist", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UnassignAPhoneNumAutoReceptionist", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUnassignAPhoneNumAutoReceptionistResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UnassignAPhoneNumCallQueue invokes unassignAPhoneNumCallQueue operation.
//
// Use this API to unbind all phone numbers that are assigned to a [Call Queue](https://support.zoom.
// us/hc/en-us/articles/360021524831-Managing-Call-Queues) After successful unbinding, the numbers
// will appear in the [Unassigned tab](https://zoom.us/signin#/numbers/unassigned).
// If you only need to unassign a specific phone number, use the Unassign a Phone Number API instead.
// **Prerequisites:**
// * Pro or higher account palan
// * Account owner or admin permissions
// * Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:call_queue_number:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/call_queues/{callQueueId}/phone_numbers
func (c *Client) UnassignAPhoneNumCallQueue(ctx context.Context, params UnassignAPhoneNumCallQueueParams) error {
	_, err := c.sendUnassignAPhoneNumCallQueue(ctx, params)
	return err
}

func (c *Client) sendUnassignAPhoneNumCallQueue(ctx context.Context, params UnassignAPhoneNumCallQueueParams) (res *UnassignAPhoneNumCallQueueNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("unassignAPhoneNumCallQueue"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/call_queues/{callQueueId}/phone_numbers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UnassignAPhoneNumCallQueue",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/call_queues/"
	{
		// Encode "callQueueId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "callQueueId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallQueueId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/phone_numbers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UnassignAPhoneNumCallQueue", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UnassignAPhoneNumCallQueue", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUnassignAPhoneNumCallQueueResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UnassignAllMembers invokes unassignAllMembers operation.
//
// Removes all members from a call queue who were previously assigned to that call queue. The members
// could be phone users or [common areas](https://support.zoom.us/hc/articles/4481136653709).
// **Prerequisites:**
// * Pro or higher account plan.
// * Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:call_queue_member:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/call_queues/{callQueueId}/members
func (c *Client) UnassignAllMembers(ctx context.Context, params UnassignAllMembersParams) error {
	_, err := c.sendUnassignAllMembers(ctx, params)
	return err
}

func (c *Client) sendUnassignAllMembers(ctx context.Context, params UnassignAllMembersParams) (res *UnassignAllMembersNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("unassignAllMembers"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/call_queues/{callQueueId}/members"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UnassignAllMembers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/call_queues/"
	{
		// Encode "callQueueId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "callQueueId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallQueueId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UnassignAllMembers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UnassignAllMembers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUnassignAllMembersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UnassignAllPhoneNumsAutoReceptionist invokes unassignAllPhoneNumsAutoReceptionist operation.
//
// Unassigns all phone numbers that were previously assigned to an [auto
// receptionist](https://support.zoom.
// us/hc/en-us/articles/360021121312-Managing-Auto-Receptionists-and-Interactive-Voice-Response-IVR-).
// **Prerequisites:**
// * Pro or higher account plan with Zoom Phone License
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:auto_receptionist_number:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// DELETE /phone/auto_receptionists/{autoReceptionistId}/phone_numbers
func (c *Client) UnassignAllPhoneNumsAutoReceptionist(ctx context.Context, params UnassignAllPhoneNumsAutoReceptionistParams) error {
	_, err := c.sendUnassignAllPhoneNumsAutoReceptionist(ctx, params)
	return err
}

func (c *Client) sendUnassignAllPhoneNumsAutoReceptionist(ctx context.Context, params UnassignAllPhoneNumsAutoReceptionistParams) (res *UnassignAllPhoneNumsAutoReceptionistNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("unassignAllPhoneNumsAutoReceptionist"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/auto_receptionists/{autoReceptionistId}/phone_numbers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UnassignAllPhoneNumsAutoReceptionist",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/auto_receptionists/"
	{
		// Encode "autoReceptionistId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "autoReceptionistId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AutoReceptionistId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/phone_numbers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UnassignAllPhoneNumsAutoReceptionist", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UnassignAllPhoneNumsAutoReceptionist", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUnassignAllPhoneNumsAutoReceptionistResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UnassignCallingPlan invokes unassignCallingPlan operation.
//
// Unassigns a a [Zoom Phone](https://support.zoom.us/hc/en-us/categories/360001370051) user's
// [calling plan](https://marketplace.zoom.
// us/docs/api-reference/other-references/plans#zoom-phone-calling-plans). For user-level apps, pass
// [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead
// of the `userId` parameter.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:write`,`phone:write:admin`
// **Granular Scopes:** `phone:delete:users_calling_plan`,`phone:delete:users_calling_plan:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/users/{userId}/calling_plans/{type}
func (c *Client) UnassignCallingPlan(ctx context.Context, params UnassignCallingPlanParams) error {
	_, err := c.sendUnassignCallingPlan(ctx, params)
	return err
}

func (c *Client) sendUnassignCallingPlan(ctx context.Context, params UnassignCallingPlanParams) (res *UnassignCallingPlanNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("unassignCallingPlan"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/users/{userId}/calling_plans/{type}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UnassignCallingPlan",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/calling_plans/"
	{
		// Encode "type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Type))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "billing_account_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "billing_account_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.BillingAccountID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UnassignCallingPlan", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UnassignCallingPlan", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUnassignCallingPlanResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UnassignCallingPlanFromRoom invokes unassignCallingPlanFromRoom operation.
//
// Use this API to unassign a [calling plan](https://marketplace.zoom.
// us/docs/api-reference/other-references/plans#zoom-phone-calling-plans) from a [Zoom
// Room](https://support.zoom.
// us/hc/en-us/articles/360025153711#h_140e30ba-5a88-40b9-b799-16883fa0a037).
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:room_calling_plan:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/rooms/{roomId}/calling_plans/{type}
func (c *Client) UnassignCallingPlanFromRoom(ctx context.Context, params UnassignCallingPlanFromRoomParams) error {
	_, err := c.sendUnassignCallingPlanFromRoom(ctx, params)
	return err
}

func (c *Client) sendUnassignCallingPlanFromRoom(ctx context.Context, params UnassignCallingPlanFromRoomParams) (res *UnassignCallingPlanFromRoomNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("unassignCallingPlanFromRoom"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/rooms/{roomId}/calling_plans/{type}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UnassignCallingPlanFromRoom",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/rooms/"
	{
		// Encode "roomId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "roomId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoomId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/calling_plans/"
	{
		// Encode "type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.Type))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "billing_account_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "billing_account_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.BillingAccountID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UnassignCallingPlanFromRoom", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UnassignCallingPlanFromRoom", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUnassignCallingPlanFromRoomResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UnassignCallingPlansFromCommonArea invokes unassignCallingPlansFromCommonArea operation.
//
// Use this API to unassign a calling plan from the common area.
// **Note**: For use by customers who opted for `Common Area Optimization`
// **Prerequisites:**
// * A Pro or higher account with a Zoom Phone license
// * An account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:common_area_calling_plan:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/common_areas/{commonAreaId}/calling_plans/{type}
func (c *Client) UnassignCallingPlansFromCommonArea(ctx context.Context, params UnassignCallingPlansFromCommonAreaParams) error {
	_, err := c.sendUnassignCallingPlansFromCommonArea(ctx, params)
	return err
}

func (c *Client) sendUnassignCallingPlansFromCommonArea(ctx context.Context, params UnassignCallingPlansFromCommonAreaParams) (res *UnassignCallingPlansFromCommonAreaNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("unassignCallingPlansFromCommonArea"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/common_areas/{commonAreaId}/calling_plans/{type}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UnassignCallingPlansFromCommonArea",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/common_areas/"
	{
		// Encode "commonAreaId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "commonAreaId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CommonAreaId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/calling_plans/"
	{
		// Encode "type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Type))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "billing_account_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "billing_account_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.BillingAccountID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UnassignCallingPlansFromCommonArea", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UnassignCallingPlansFromCommonArea", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUnassignCallingPlansFromCommonAreaResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UnassignCampaignPhoneNumber invokes unassignCampaignPhoneNumber operation.
//
// Use this API to [unassign a phone number from the SMS campaign](https://support.zoom.
// us/hc/en-us/articles/5016496738445-SMS-MMS-10DLC-Compliance-for-Zoom-Phone-and-Zoom-Contact-Center#h_01FYVVSPVM8MZN4Y9EW5690QHH).
// Remove the assigned phone number from the campaign.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// * The campaign must have been previously assigned a Zoom Phone number
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:sms_campaign_number:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/sms_campaigns/{smsCampaignId}/phone_numbers/{phoneNumberId}
func (c *Client) UnassignCampaignPhoneNumber(ctx context.Context, params UnassignCampaignPhoneNumberParams) error {
	_, err := c.sendUnassignCampaignPhoneNumber(ctx, params)
	return err
}

func (c *Client) sendUnassignCampaignPhoneNumber(ctx context.Context, params UnassignCampaignPhoneNumberParams) (res *UnassignCampaignPhoneNumberNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("unassignCampaignPhoneNumber"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/sms_campaigns/{smsCampaignId}/phone_numbers/{phoneNumberId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UnassignCampaignPhoneNumber",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/sms_campaigns/"
	{
		// Encode "smsCampaignId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "smsCampaignId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SmsCampaignId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/phone_numbers/"
	{
		// Encode "phoneNumberId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "phoneNumberId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PhoneNumberId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UnassignCampaignPhoneNumber", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UnassignCampaignPhoneNumber", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUnassignCampaignPhoneNumberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UnassignMemberFromCallQueue invokes unassignMemberFromCallQueue operation.
//
// Removes a member who was previously added to a call queue. The member could be a phone user or
// common area. Note that you cannot use this API to unassign a call queue manager.
// **Prerequisites:**
// * Pro or higher account plan.
// * Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:call_queue_member:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/call_queues/{callQueueId}/members/{memberId}
func (c *Client) UnassignMemberFromCallQueue(ctx context.Context, params UnassignMemberFromCallQueueParams) error {
	_, err := c.sendUnassignMemberFromCallQueue(ctx, params)
	return err
}

func (c *Client) sendUnassignMemberFromCallQueue(ctx context.Context, params UnassignMemberFromCallQueueParams) (res *UnassignMemberFromCallQueueNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("unassignMemberFromCallQueue"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/call_queues/{callQueueId}/members/{memberId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UnassignMemberFromCallQueue",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/call_queues/"
	{
		// Encode "callQueueId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "callQueueId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallQueueId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members/"
	{
		// Encode "memberId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "memberId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.MemberId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UnassignMemberFromCallQueue", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UnassignMemberFromCallQueue", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUnassignMemberFromCallQueueResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UnassignPhoneNumber invokes UnassignPhoneNumber operation.
//
// Unassigns Zoom Phone user's [phone number](https://support.zoom.
// us/hc/en-us/articles/360020808292-Managing-Phone-Numbers#h_38ba8b01-26e3-4b1b-a9b5-0717c00a7ca6).
// After assigning a phone number, you can remove it if you do not want it to be assigned to anyone.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// * The user must have been previously assigned a Zoom Phone number
// **Scopes:** `phone:write`,`phone:write:admin`
// **Granular Scopes:** `phone:delete:user_number`,`phone:delete:user_number:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/users/{userId}/phone_numbers/{phoneNumberId}
func (c *Client) UnassignPhoneNumber(ctx context.Context, params UnassignPhoneNumberParams) error {
	_, err := c.sendUnassignPhoneNumber(ctx, params)
	return err
}

func (c *Client) sendUnassignPhoneNumber(ctx context.Context, params UnassignPhoneNumberParams) (res *UnassignPhoneNumberNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("UnassignPhoneNumber"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/users/{userId}/phone_numbers/{phoneNumberId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UnassignPhoneNumber",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/phone_numbers/"
	{
		// Encode "phoneNumberId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "phoneNumberId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PhoneNumberId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UnassignPhoneNumber", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UnassignPhoneNumber", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUnassignPhoneNumberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UnassignPhoneNumberFromZoomRoom invokes UnassignPhoneNumberFromZoomRoom operation.
//
// Use this API to unassign a [phone number](https://support.zoom.
// us/hc/en-us/articles/360020808292-Managing-Phone-Numbers#h_38ba8b01-26e3-4b1b-a9b5-0717c00a7ca6)
// from a [Zoom Room](https://support.zoom.
// us/hc/en-us/articles/360025153711#h_140e30ba-5a88-40b9-b799-16883fa0a037).
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// * The Zoom Room must have been previously assigned a Zoom Phone number
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:room_phone_number:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/rooms/{roomId}/phone_numbers/{phoneNumberId}
func (c *Client) UnassignPhoneNumberFromZoomRoom(ctx context.Context, params UnassignPhoneNumberFromZoomRoomParams) error {
	_, err := c.sendUnassignPhoneNumberFromZoomRoom(ctx, params)
	return err
}

func (c *Client) sendUnassignPhoneNumberFromZoomRoom(ctx context.Context, params UnassignPhoneNumberFromZoomRoomParams) (res *UnassignPhoneNumberFromZoomRoomNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("UnassignPhoneNumberFromZoomRoom"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/rooms/{roomId}/phone_numbers/{phoneNumberId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UnassignPhoneNumberFromZoomRoom",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/rooms/"
	{
		// Encode "roomId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "roomId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoomId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/phone_numbers/"
	{
		// Encode "phoneNumberId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "phoneNumberId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PhoneNumberId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UnassignPhoneNumberFromZoomRoom", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UnassignPhoneNumberFromZoomRoom", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUnassignPhoneNumberFromZoomRoomResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UnassignPhoneNumbersFromCommonArea invokes unassignPhoneNumbersFromCommonArea operation.
//
// Use this API to unassign a phone number from a common area.
// **Note**: For use by customers who opted for `Common Area Optimization`
// **Prerequisites:**
// * A Pro or a higher account with a Zoom Phone license
// * An account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:delete:common_area_number:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /phone/common_areas/{commonAreaId}/phone_numbers/{phoneNumberId}
func (c *Client) UnassignPhoneNumbersFromCommonArea(ctx context.Context, params UnassignPhoneNumbersFromCommonAreaParams) error {
	_, err := c.sendUnassignPhoneNumbersFromCommonArea(ctx, params)
	return err
}

func (c *Client) sendUnassignPhoneNumbersFromCommonArea(ctx context.Context, params UnassignPhoneNumbersFromCommonAreaParams) (res *UnassignPhoneNumbersFromCommonAreaNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("unassignPhoneNumbersFromCommonArea"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/phone/common_areas/{commonAreaId}/phone_numbers/{phoneNumberId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UnassignPhoneNumbersFromCommonArea",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/common_areas/"
	{
		// Encode "commonAreaId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "commonAreaId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CommonAreaId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/phone_numbers/"
	{
		// Encode "phoneNumberId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "phoneNumberId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PhoneNumberId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UnassignPhoneNumbersFromCommonArea", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UnassignPhoneNumbersFromCommonArea", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUnassignPhoneNumbersFromCommonAreaResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateADevice invokes updateADevice operation.
//
// Updates the information of a [desk phone device](https://support.zoom.
// us/hc/en-us/articles/360021119092).
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license* Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:device:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// PATCH /phone/devices/{deviceId}
func (c *Client) UpdateADevice(ctx context.Context, request OptUpdateADeviceReq, params UpdateADeviceParams) error {
	_, err := c.sendUpdateADevice(ctx, request, params)
	return err
}

func (c *Client) sendUpdateADevice(ctx context.Context, request OptUpdateADeviceReq, params UpdateADeviceParams) (res *UpdateADeviceNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateADevice"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/devices/{deviceId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateADevice",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/devices/"
	{
		// Encode "deviceId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "deviceId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DeviceId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateADeviceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateADevice", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateADevice", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateADeviceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateAccountLevelInboundBlockRule invokes UpdateAccountLevelInboundBlockRule operation.
//
// Updates the account level block rule for inbound calls and messaging.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:inbound_block_rule:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// PATCH /phone/inbound_blocked/rules/{blockedRuleId}
func (c *Client) UpdateAccountLevelInboundBlockRule(ctx context.Context, request OptUpdateAccountLevelInboundBlockRuleReq, params UpdateAccountLevelInboundBlockRuleParams) error {
	_, err := c.sendUpdateAccountLevelInboundBlockRule(ctx, request, params)
	return err
}

func (c *Client) sendUpdateAccountLevelInboundBlockRule(ctx context.Context, request OptUpdateAccountLevelInboundBlockRuleReq, params UpdateAccountLevelInboundBlockRuleParams) (res *UpdateAccountLevelInboundBlockRuleNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("UpdateAccountLevelInboundBlockRule"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/inbound_blocked/rules/{blockedRuleId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateAccountLevelInboundBlockRule",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/inbound_blocked/rules/"
	{
		// Encode "blockedRuleId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "blockedRuleId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BlockedRuleId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateAccountLevelInboundBlockRuleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateAccountLevelInboundBlockRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateAccountLevelInboundBlockRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateAccountLevelInboundBlockRuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateAccountOutboundCallingCountriesOrRegions invokes UpdateAccountOutboundCallingCountriesOrRegions operation.
//
// Updates the account level outbound calling policy country or region.
// **Prerequisite:**
// * Account must have a Pro or a higher plan with a Zoom Phone license.
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:outbound_calling_rule:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// PATCH /phone/outbound_calling/countries_regions
func (c *Client) UpdateAccountOutboundCallingCountriesOrRegions(ctx context.Context, request OptUpdateAccountOutboundCallingCountriesOrRegionsReq) error {
	_, err := c.sendUpdateAccountOutboundCallingCountriesOrRegions(ctx, request)
	return err
}

func (c *Client) sendUpdateAccountOutboundCallingCountriesOrRegions(ctx context.Context, request OptUpdateAccountOutboundCallingCountriesOrRegionsReq) (res *UpdateAccountOutboundCallingCountriesOrRegionsNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("UpdateAccountOutboundCallingCountriesOrRegions"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/outbound_calling/countries_regions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateAccountOutboundCallingCountriesOrRegions",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/outbound_calling/countries_regions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateAccountOutboundCallingCountriesOrRegionsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateAccountOutboundCallingCountriesOrRegions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateAccountOutboundCallingCountriesOrRegions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateAccountOutboundCallingCountriesOrRegionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateAccountOutboundCallingExceptionRule invokes UpdateAccountOutboundCallingExceptionRule operation.
//
// Updates the account level outbound calling policy for the country region exception rule.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:outbound_calling_rule:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// PATCH /phone/outbound_calling/exception_rules/{exceptionRuleId}
func (c *Client) UpdateAccountOutboundCallingExceptionRule(ctx context.Context, request OptUpdateAccountOutboundCallingExceptionRuleReq, params UpdateAccountOutboundCallingExceptionRuleParams) error {
	_, err := c.sendUpdateAccountOutboundCallingExceptionRule(ctx, request, params)
	return err
}

func (c *Client) sendUpdateAccountOutboundCallingExceptionRule(ctx context.Context, request OptUpdateAccountOutboundCallingExceptionRuleReq, params UpdateAccountOutboundCallingExceptionRuleParams) (res *UpdateAccountOutboundCallingExceptionRuleNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("UpdateAccountOutboundCallingExceptionRule"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/outbound_calling/exception_rules/{exceptionRuleId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateAccountOutboundCallingExceptionRule",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/outbound_calling/exception_rules/"
	{
		// Encode "exceptionRuleId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "exceptionRuleId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ExceptionRuleId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateAccountOutboundCallingExceptionRuleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateAccountOutboundCallingExceptionRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateAccountOutboundCallingExceptionRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateAccountOutboundCallingExceptionRuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateAnAlertSetting invokes UpdateAnAlertSetting operation.
//
// Updates information of an [Alert setting](https://support.zoom.us/hc/en-us/articles/7146944434445).
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:patch:alert_setting:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// PATCH /phone/alert_settings/{alertSettingId}
func (c *Client) UpdateAnAlertSetting(ctx context.Context, request OptUpdateAnAlertSettingReq, params UpdateAnAlertSettingParams) error {
	_, err := c.sendUpdateAnAlertSetting(ctx, request, params)
	return err
}

func (c *Client) sendUpdateAnAlertSetting(ctx context.Context, request OptUpdateAnAlertSettingReq, params UpdateAnAlertSettingParams) (res *UpdateAnAlertSettingNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("UpdateAnAlertSetting"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/alert_settings/{alertSettingId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateAnAlertSetting",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/alert_settings/"
	{
		// Encode "alertSettingId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "alertSettingId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AlertSettingId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateAnAlertSettingRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateAnAlertSetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateAnAlertSetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateAnAlertSettingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateAudioItem invokes UpdateAudioItem operation.
//
// Updates an audio item. Only the admin or user can update your audio.
// **Prerequisites:**
// * Business or Education account
// * Zoom Phone license
// **Scopes:** `phone:write`,`phone:write:admin`
// **Granular Scopes:** `phone:update:audio`,`phone:update:audio:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// PATCH /phone/audios/{audioId}
func (c *Client) UpdateAudioItem(ctx context.Context, request OptUpdateAudioItemReq, params UpdateAudioItemParams) error {
	_, err := c.sendUpdateAudioItem(ctx, request, params)
	return err
}

func (c *Client) sendUpdateAudioItem(ctx context.Context, request OptUpdateAudioItemReq, params UpdateAudioItemParams) (res *UpdateAudioItemNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("UpdateAudioItem"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/audios/{audioId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateAudioItem",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/audios/"
	{
		// Encode "audioId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "audioId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AudioId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateAudioItemRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateAudioItem", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateAudioItem", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateAudioItemResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateAutoDeleteField invokes UpdateAutoDeleteField operation.
//
// Updates the auto delete field for recording. It only updates if you enable the **Auto Delete Data
// After Retention Duration** setting in the account settings for recordings.
// **Prerequisites:**
// * User must belong to a Business or Enterprise account
// * User must have a Zoom Phone license.
// **Scopes:** `phone:write:admin`,`phone:write`,`phone_recording:write`,`phone_recording:write:admin`
// **Granular Scopes:** `phone:update:call_recording`,`phone:update:call_recording:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// PATCH /phone/recordings/{recordingId}
func (c *Client) UpdateAutoDeleteField(ctx context.Context, request OptUpdateAutoDeleteFieldReq, params UpdateAutoDeleteFieldParams) error {
	_, err := c.sendUpdateAutoDeleteField(ctx, request, params)
	return err
}

func (c *Client) sendUpdateAutoDeleteField(ctx context.Context, request OptUpdateAutoDeleteFieldReq, params UpdateAutoDeleteFieldParams) (res *UpdateAutoDeleteFieldNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("UpdateAutoDeleteField"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/recordings/{recordingId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateAutoDeleteField",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/recordings/"
	{
		// Encode "recordingId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "recordingId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RecordingId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateAutoDeleteFieldRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateAutoDeleteField", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateAutoDeleteField", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateAutoDeleteFieldResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateAutoReceptionist invokes updateAutoReceptionist operation.
//
// [Changes information](https://support.zoom.
// us/hc/en-us/articles/360021121312-Managing-Auto-Receptionists-and-Interactive-Voice-Response-IVR-#h_1d5ffc56-6ba3-4ce5-9d86-4a1a1ee743f3) such as the display name and the extension number assigned to the main auto receptionist.
// An auto receptionist answers calls with a personalized recording. And it routes calls to a phone
// user, call queue, common area, or voicemail. An auto receptionist can also be set up so that it
// routes calls to an interactive voice response (IVR) system to allow callers to select the routing
// options.
// **Prerequisites:**
// * Pro or higher account with Zoom Phone license.
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:auto_receptionist:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// PATCH /phone/auto_receptionists/{autoReceptionistId}
func (c *Client) UpdateAutoReceptionist(ctx context.Context, request OptUpdateAutoReceptionistReq, params UpdateAutoReceptionistParams) error {
	_, err := c.sendUpdateAutoReceptionist(ctx, request, params)
	return err
}

func (c *Client) sendUpdateAutoReceptionist(ctx context.Context, request OptUpdateAutoReceptionistReq, params UpdateAutoReceptionistParams) (res *UpdateAutoReceptionistNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateAutoReceptionist"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/auto_receptionists/{autoReceptionistId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateAutoReceptionist",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/auto_receptionists/"
	{
		// Encode "autoReceptionistId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "autoReceptionistId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AutoReceptionistId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateAutoReceptionistRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateAutoReceptionist", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateAutoReceptionist", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateAutoReceptionistResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateAutoReceptionistIVR invokes updateAutoReceptionistIVR operation.
//
// Updates the [interactive voice response (IVR) system](https://support.zoom.
// us/hc/en-us/articles/360038601971) of the specified auto receptionist.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:auto_receptionist_ivr:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// PATCH /phone/auto_receptionists/{autoReceptionistId}/ivr
func (c *Client) UpdateAutoReceptionistIVR(ctx context.Context, request OptUpdateAutoReceptionistIVRReq, params UpdateAutoReceptionistIVRParams) error {
	_, err := c.sendUpdateAutoReceptionistIVR(ctx, request, params)
	return err
}

func (c *Client) sendUpdateAutoReceptionistIVR(ctx context.Context, request OptUpdateAutoReceptionistIVRReq, params UpdateAutoReceptionistIVRParams) (res *UpdateAutoReceptionistIVRNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateAutoReceptionistIVR"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/auto_receptionists/{autoReceptionistId}/ivr"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateAutoReceptionistIVR",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/auto_receptionists/"
	{
		// Encode "autoReceptionistId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "autoReceptionistId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AutoReceptionistId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/ivr"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateAutoReceptionistIVRRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateAutoReceptionistIVR", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateAutoReceptionistIVR", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateAutoReceptionistIVRResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateAutoReceptionistPolicy invokes updateAutoReceptionistPolicy operation.
//
// Updates the policy setting of a specific [auto receptionist](https://support.zoom.
// us/hc/en-us/articles/360021121312-Managing-Auto-Receptionists-and-Interactive-Voice-Response-IVR-).
// **Prerequisites:**
// * Pro or higher account plan with Zoom Phone License
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:auto_receptionist_policy:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// PATCH /phone/auto_receptionists/{autoReceptionistId}/policies
func (c *Client) UpdateAutoReceptionistPolicy(ctx context.Context, request OptUpdateAutoReceptionistPolicyReq, params UpdateAutoReceptionistPolicyParams) error {
	_, err := c.sendUpdateAutoReceptionistPolicy(ctx, request, params)
	return err
}

func (c *Client) sendUpdateAutoReceptionistPolicy(ctx context.Context, request OptUpdateAutoReceptionistPolicyReq, params UpdateAutoReceptionistPolicyParams) (res *UpdateAutoReceptionistPolicyNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateAutoReceptionistPolicy"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/auto_receptionists/{autoReceptionistId}/policies"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateAutoReceptionistPolicy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/auto_receptionists/"
	{
		// Encode "autoReceptionistId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "autoReceptionistId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AutoReceptionistId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/policies"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateAutoReceptionistPolicyRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateAutoReceptionistPolicy", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateAutoReceptionistPolicy", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateAutoReceptionistPolicyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateCQPolicySubSetting invokes updateCQPolicySubSetting operation.
//
// Use this API to update the policy sub-setting for a specific [call queue](https://support.zoom.
// us/hc/en-us/articles/360021524831) according to the `policyType`. For example, you can use this
// API to update shared access members.
// **Prerequisites:**
// * Pro or higher account with Zoom Phone license.
// * Account owner or admin privileges
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:call_queue_policy:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// PATCH /phone/call_queues/{callQueueId}/policies/{policyType}
func (c *Client) UpdateCQPolicySubSetting(ctx context.Context, request OptUpdateCQPolicySubSettingReq, params UpdateCQPolicySubSettingParams) error {
	_, err := c.sendUpdateCQPolicySubSetting(ctx, request, params)
	return err
}

func (c *Client) sendUpdateCQPolicySubSetting(ctx context.Context, request OptUpdateCQPolicySubSettingReq, params UpdateCQPolicySubSettingParams) (res *UpdateCQPolicySubSettingNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateCQPolicySubSetting"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/call_queues/{callQueueId}/policies/{policyType}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateCQPolicySubSetting",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/call_queues/"
	{
		// Encode "callQueueId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "callQueueId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallQueueId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/policies/"
	{
		// Encode "policyType" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "policyType",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PolicyType))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateCQPolicySubSettingRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateCQPolicySubSetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateCQPolicySubSetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateCQPolicySubSettingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateCallHandling invokes updateCallHandling operation.
//
// Updates a Zoom Phone's call handling setting.
// Call handling settings allow you to control how your system routes calls during business, closed,
// or holiday hours. For more information, read our [Call Handling API guide](https://developers.zoom.
// us/docs/zoom-phone/call-handling/) or Zoom support article [Customizing call handling
// settings](https://support.zoom.
// us/hc/en-us/articles/360059966372-Customizing-call-handling-settings).
// **Applicable to user, call queue, auto receptionist, or shared line group call handling at this
// time.**
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone enabled
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:call_handling_setting:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// PATCH /phone/extension/{extensionId}/call_handling/settings/{settingType}
func (c *Client) UpdateCallHandling(ctx context.Context, request OptUpdateCallHandlingReq, params UpdateCallHandlingParams) error {
	_, err := c.sendUpdateCallHandling(ctx, request, params)
	return err
}

func (c *Client) sendUpdateCallHandling(ctx context.Context, request OptUpdateCallHandlingReq, params UpdateCallHandlingParams) (res *UpdateCallHandlingNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateCallHandling"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/extension/{extensionId}/call_handling/settings/{settingType}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateCallHandling",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/extension/"
	{
		// Encode "extensionId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "extensionId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ExtensionId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/call_handling/settings/"
	{
		// Encode "settingType" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "settingType",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SettingType))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateCallHandlingRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateCallHandling", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateCallHandling", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateCallHandlingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateCallQueue invokes updateCallQueue operation.
//
// Call queues allow you to route incoming calls to a group of users. For instance, you can use call
// queues to route calls to various departments in your organization such as sales, engineering,
// billing, customer service etc.
// Use this API to update information of a specific Call Queue.
// **Prerequisites:**
// * Pro, Business, or Education account
// * Account owner or admin permissions
// * Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:call_queue:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// PATCH /phone/call_queues/{callQueueId}
func (c *Client) UpdateCallQueue(ctx context.Context, request OptUpdateCallQueueReq, params UpdateCallQueueParams) error {
	_, err := c.sendUpdateCallQueue(ctx, request, params)
	return err
}

func (c *Client) sendUpdateCallQueue(ctx context.Context, request OptUpdateCallQueueReq, params UpdateCallQueueParams) (res *UpdateCallQueueNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateCallQueue"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/call_queues/{callQueueId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateCallQueue",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/call_queues/"
	{
		// Encode "callQueueId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "callQueueId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallQueueId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateCallQueueRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateCallQueue", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateCallQueue", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateCallQueueResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateCallingPlan invokes updateCallingPlan operation.
//
// Switches [calling plans](https://marketplace.zoom.
// us/docs/api-reference/other-references/plans#zoom-phone-calling-plans) of a [Zoom
// Phone](https://support.zoom.us/hc/en-us/categories/360001370051-Zoom-Phone) user. For user-level
// apps, pass [the `me` value](https://marketplace.zoom.
// us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`,`phone:write`
// **Granular Scopes:** `phone:update:calling_plan`,`phone:update:calling_plan:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// PUT /phone/users/{userId}/calling_plans
func (c *Client) UpdateCallingPlan(ctx context.Context, request OptUpdateCallingPlanReq, params UpdateCallingPlanParams) error {
	_, err := c.sendUpdateCallingPlan(ctx, request, params)
	return err
}

func (c *Client) sendUpdateCallingPlan(ctx context.Context, request OptUpdateCallingPlanReq, params UpdateCallingPlanParams) (res *UpdateCallingPlanNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateCallingPlan"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/phone/users/{userId}/calling_plans"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateCallingPlan",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/calling_plans"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateCallingPlanRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateCallingPlan", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateCallingPlan", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateCallingPlanResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateCommonArea invokes updateCommonArea operation.
//
// Use this API to update the common area information.
// **Note**: For use by customers who opted for `Common Area Optimization`
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:common_area:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// PATCH /phone/common_areas/{commonAreaId}
func (c *Client) UpdateCommonArea(ctx context.Context, request OptUpdateCommonAreaReq, params UpdateCommonAreaParams) error {
	_, err := c.sendUpdateCommonArea(ctx, request, params)
	return err
}

func (c *Client) sendUpdateCommonArea(ctx context.Context, request OptUpdateCommonAreaReq, params UpdateCommonAreaParams) (res *UpdateCommonAreaNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateCommonArea"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/common_areas/{commonAreaId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateCommonArea",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/common_areas/"
	{
		// Encode "commonAreaId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "commonAreaId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CommonAreaId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateCommonAreaRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateCommonArea", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateCommonArea", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateCommonAreaResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateCommonAreaOutboundCallingCountriesOrRegions invokes UpdateCommonAreaOutboundCallingCountriesOrRegions operation.
//
// Updates the common area level outbound calling policy country or region.
// **Prerequisite:**
// * Account must have a Pro or a higher plan with a Zoom Phone license.
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:common_area_outbound_calling_rule:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// PATCH /phone/common_areas/{commonAreaId}/outbound_calling/countries_regions
func (c *Client) UpdateCommonAreaOutboundCallingCountriesOrRegions(ctx context.Context, request OptUpdateCommonAreaOutboundCallingCountriesOrRegionsReq, params UpdateCommonAreaOutboundCallingCountriesOrRegionsParams) error {
	_, err := c.sendUpdateCommonAreaOutboundCallingCountriesOrRegions(ctx, request, params)
	return err
}

func (c *Client) sendUpdateCommonAreaOutboundCallingCountriesOrRegions(ctx context.Context, request OptUpdateCommonAreaOutboundCallingCountriesOrRegionsReq, params UpdateCommonAreaOutboundCallingCountriesOrRegionsParams) (res *UpdateCommonAreaOutboundCallingCountriesOrRegionsNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("UpdateCommonAreaOutboundCallingCountriesOrRegions"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/common_areas/{commonAreaId}/outbound_calling/countries_regions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateCommonAreaOutboundCallingCountriesOrRegions",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/common_areas/"
	{
		// Encode "commonAreaId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "commonAreaId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CommonAreaId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/outbound_calling/countries_regions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateCommonAreaOutboundCallingCountriesOrRegionsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateCommonAreaOutboundCallingCountriesOrRegions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateCommonAreaOutboundCallingCountriesOrRegions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateCommonAreaOutboundCallingCountriesOrRegionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateCommonAreaOutboundCallingExceptionRule invokes UpdateCommonAreaOutboundCallingExceptionRule operation.
//
// Updates the common area level outbound calling policy for the country region exception rule.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:common_area_outbound_calling_rule:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// PATCH /phone/common_areas/{commonAreaId}/outbound_calling/exception_rules/{exceptionRuleId}
func (c *Client) UpdateCommonAreaOutboundCallingExceptionRule(ctx context.Context, request OptUpdateCommonAreaOutboundCallingExceptionRuleReq, params UpdateCommonAreaOutboundCallingExceptionRuleParams) error {
	_, err := c.sendUpdateCommonAreaOutboundCallingExceptionRule(ctx, request, params)
	return err
}

func (c *Client) sendUpdateCommonAreaOutboundCallingExceptionRule(ctx context.Context, request OptUpdateCommonAreaOutboundCallingExceptionRuleReq, params UpdateCommonAreaOutboundCallingExceptionRuleParams) (res *UpdateCommonAreaOutboundCallingExceptionRuleNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("UpdateCommonAreaOutboundCallingExceptionRule"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/common_areas/{commonAreaId}/outbound_calling/exception_rules/{exceptionRuleId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateCommonAreaOutboundCallingExceptionRule",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/common_areas/"
	{
		// Encode "commonAreaId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "commonAreaId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CommonAreaId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/outbound_calling/exception_rules/"
	{
		// Encode "exceptionRuleId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "exceptionRuleId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ExceptionRuleId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateCommonAreaOutboundCallingExceptionRuleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateCommonAreaOutboundCallingExceptionRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateCommonAreaOutboundCallingExceptionRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateCommonAreaOutboundCallingExceptionRuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateCommonAreaSetting invokes UpdateCommonAreaSetting operation.
//
// Use this API to update the common area setting according to the setting type, specifically for
// desk phones.
// **Note**: For use by customers who opted for `Common Area Optimization`
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license.
// * Account owner or admin permissions.
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:common_area_setting:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// PATCH /phone/common_areas/{commonAreaId}/settings/{settingType}
func (c *Client) UpdateCommonAreaSetting(ctx context.Context, request OptUpdateCommonAreaSettingReq, params UpdateCommonAreaSettingParams) error {
	_, err := c.sendUpdateCommonAreaSetting(ctx, request, params)
	return err
}

func (c *Client) sendUpdateCommonAreaSetting(ctx context.Context, request OptUpdateCommonAreaSettingReq, params UpdateCommonAreaSettingParams) (res *UpdateCommonAreaSettingNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("UpdateCommonAreaSetting"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/common_areas/{commonAreaId}/settings/{settingType}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateCommonAreaSetting",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/common_areas/"
	{
		// Encode "commonAreaId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "commonAreaId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CommonAreaId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/settings/"
	{
		// Encode "settingType" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "settingType",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SettingType))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateCommonAreaSettingRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateCommonAreaSetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateCommonAreaSetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateCommonAreaSettingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateEmergencyAddress invokes updateEmergencyAddress operation.
//
// Updates an emergency address information. If the address provided is not an exact match, the
// system generated corrected address will be used.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:emergency_address:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// PATCH /phone/emergency_addresses/{emergencyAddressId}
func (c *Client) UpdateEmergencyAddress(ctx context.Context, request OptUpdateEmergencyAddressReq, params UpdateEmergencyAddressParams) (*UpdateEmergencyAddressOK, error) {
	res, err := c.sendUpdateEmergencyAddress(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateEmergencyAddress(ctx context.Context, request OptUpdateEmergencyAddressReq, params UpdateEmergencyAddressParams) (res *UpdateEmergencyAddressOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateEmergencyAddress"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/emergency_addresses/{emergencyAddressId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateEmergencyAddress",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/emergency_addresses/"
	{
		// Encode "emergencyAddressId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "emergencyAddressId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EmergencyAddressId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateEmergencyAddressRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateEmergencyAddress", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateEmergencyAddress", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateEmergencyAddressResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateExternalContact invokes updateExternalContact operation.
//
// Updates an external contact's information.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:external_contact:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// PATCH /phone/external_contacts/{externalContactId}
func (c *Client) UpdateExternalContact(ctx context.Context, request OptUpdateExternalContactReq, params UpdateExternalContactParams) error {
	_, err := c.sendUpdateExternalContact(ctx, request, params)
	return err
}

func (c *Client) sendUpdateExternalContact(ctx context.Context, request OptUpdateExternalContactReq, params UpdateExternalContactParams) (res *UpdateExternalContactNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateExternalContact"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/external_contacts/{externalContactId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateExternalContact",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/external_contacts/"
	{
		// Encode "externalContactId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "externalContactId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ExternalContactId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateExternalContactRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateExternalContact", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateExternalContact", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateExternalContactResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateFirmwareRule invokes UpdateFirmwareRule operation.
//
// Use this API to update a specific [firmware update rule](https://support.zoom.
// us/hc/en-us/articles/360054198852-Setting-up-firmware-update-rules).
// **Prerequisites:**
// * Business, or Education account
// * Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:firmware_update_rule:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// PATCH /phone/firmware_update_rules/{ruleId}
func (c *Client) UpdateFirmwareRule(ctx context.Context, request OptUpdateFirmwareRuleReq, params UpdateFirmwareRuleParams) error {
	_, err := c.sendUpdateFirmwareRule(ctx, request, params)
	return err
}

func (c *Client) sendUpdateFirmwareRule(ctx context.Context, request OptUpdateFirmwareRuleReq, params UpdateFirmwareRuleParams) (res *UpdateFirmwareRuleNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("UpdateFirmwareRule"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/firmware_update_rules/{ruleId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateFirmwareRule",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/firmware_update_rules/"
	{
		// Encode "ruleId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ruleId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RuleId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateFirmwareRuleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateFirmwareRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateFirmwareRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateFirmwareRuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateGCP invokes updateGCP operation.
//
// Use this API to update a specific [Group Call Pickup](https://support.zoom.
// us/hc/en-us/articles/360060107472-Setting-up-and-using-group-call-pickup) object information.
// **Prerequisites:**
// * A Pro or higher account plan
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:call_pickup_group:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// PATCH /phone/group_call_pickup/{groupId}
func (c *Client) UpdateGCP(ctx context.Context, request OptUpdateGCPReq, params UpdateGCPParams) error {
	_, err := c.sendUpdateGCP(ctx, request, params)
	return err
}

func (c *Client) sendUpdateGCP(ctx context.Context, request OptUpdateGCPReq, params UpdateGCPParams) (res *UpdateGCPNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateGCP"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/group_call_pickup/{groupId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateGCP",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/group_call_pickup/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateGCPRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateGCP", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateGCP", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateGCPResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateLocation invokes updateLocation operation.
//
// Updates an emergency location's information.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:emergency_location:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// PATCH /phone/locations/{locationId}
func (c *Client) UpdateLocation(ctx context.Context, request OptUpdateLocationReq, params UpdateLocationParams) error {
	_, err := c.sendUpdateLocation(ctx, request, params)
	return err
}

func (c *Client) sendUpdateLocation(ctx context.Context, request OptUpdateLocationReq, params UpdateLocationParams) (res *UpdateLocationNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateLocation"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/locations/{locationId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateLocation",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/locations/"
	{
		// Encode "locationId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "locationId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.LocationId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateLocationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateLocation", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateLocation", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateLocationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateMonitoringGroup invokes updateMonitoringGroup operation.
//
// Use this API to update a [Monitoring Group](https://support.zoom.
// us/hc/en-us/articles/360044804711).
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:monitoring_group:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// PATCH /phone/monitoring_groups/{monitoringGroupId}
func (c *Client) UpdateMonitoringGroup(ctx context.Context, request OptUpdateMonitoringGroupReq, params UpdateMonitoringGroupParams) error {
	_, err := c.sendUpdateMonitoringGroup(ctx, request, params)
	return err
}

func (c *Client) sendUpdateMonitoringGroup(ctx context.Context, request OptUpdateMonitoringGroupReq, params UpdateMonitoringGroupParams) (res *UpdateMonitoringGroupNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateMonitoringGroup"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/monitoring_groups/{monitoringGroupId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateMonitoringGroup",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/monitoring_groups/"
	{
		// Encode "monitoringGroupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "monitoringGroupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.MonitoringGroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateMonitoringGroupRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateMonitoringGroup", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateMonitoringGroup", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateMonitoringGroupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdatePeeringPhoneNumbers invokes updatePeeringPhoneNumbers operation.
//
// Updates phone numbers to Zoom through the Provider Exchange.
// **Note**: Phone peering API and events are for partners that have completed the MoU to peer with
// Zoom. To become a peering provider/ carrier, submit your [request](https://docs.google.
// com/forms/d/e/1FAIpQLSewkY6ixVyKVNkWC-vgmejC16gigxsJWXji3dWzE3XlWtjsgg/viewform).
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`,`phone_peering:write:admin`
// **Granular Scopes:** `phone:update:peering_number:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// PATCH /phone/peering/numbers
func (c *Client) UpdatePeeringPhoneNumbers(ctx context.Context, request OptUpdatePeeringPhoneNumbersReq) (*UpdatePeeringPhoneNumbersOK, error) {
	res, err := c.sendUpdatePeeringPhoneNumbers(ctx, request)
	return res, err
}

func (c *Client) sendUpdatePeeringPhoneNumbers(ctx context.Context, request OptUpdatePeeringPhoneNumbersReq) (res *UpdatePeeringPhoneNumbersOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updatePeeringPhoneNumbers"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/peering/numbers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdatePeeringPhoneNumbers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/peering/numbers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdatePeeringPhoneNumbersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdatePeeringPhoneNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdatePeeringPhoneNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdatePeeringPhoneNumbersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdatePhoneNumberDetails invokes updatePhoneNumberDetails operation.
//
// Updates a Zoom Phone number's information.
// **Prerequisites:**
// * A Paid account
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:number:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// PATCH /phone/numbers/{phoneNumberId}
func (c *Client) UpdatePhoneNumberDetails(ctx context.Context, request OptUpdatePhoneNumberDetailsReq, params UpdatePhoneNumberDetailsParams) error {
	_, err := c.sendUpdatePhoneNumberDetails(ctx, request, params)
	return err
}

func (c *Client) sendUpdatePhoneNumberDetails(ctx context.Context, request OptUpdatePhoneNumberDetailsReq, params UpdatePhoneNumberDetailsParams) (res *UpdatePhoneNumberDetailsNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updatePhoneNumberDetails"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/numbers/{phoneNumberId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdatePhoneNumberDetails",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/numbers/"
	{
		// Encode "phoneNumberId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "phoneNumberId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PhoneNumberId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdatePhoneNumberDetailsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdatePhoneNumberDetails", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdatePhoneNumberDetails", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdatePhoneNumberDetailsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdatePhoneRole invokes UpdatePhoneRole operation.
//
// Use this API to update a role.
// **Prerequisites:**
// * Business, or Education account
// * Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:role:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// PATCH /phone/roles/{roleId}
func (c *Client) UpdatePhoneRole(ctx context.Context, request OptUpdatePhoneRoleReq, params UpdatePhoneRoleParams) error {
	_, err := c.sendUpdatePhoneRole(ctx, request, params)
	return err
}

func (c *Client) sendUpdatePhoneRole(ctx context.Context, request OptUpdatePhoneRoleReq, params UpdatePhoneRoleParams) (res *UpdatePhoneRoleNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("UpdatePhoneRole"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/roles/{roleId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdatePhoneRole",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/roles/"
	{
		// Encode "roleId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "roleId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdatePhoneRoleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdatePhoneRole", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdatePhoneRole", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdatePhoneRoleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdatePhoneSettings invokes updatePhoneSettings operation.
//
// Updates Zoom Phone [account settings](https://support.zoom.us/hc/en-us/articles/360025846692).
// **Prerequisites:**
// * A Business or Enterprise account
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:settings:admin`.
//
// PATCH /phone/settings
func (c *Client) UpdatePhoneSettings(ctx context.Context, request OptUpdatePhoneSettingsReq) error {
	_, err := c.sendUpdatePhoneSettings(ctx, request)
	return err
}

func (c *Client) sendUpdatePhoneSettings(ctx context.Context, request OptUpdatePhoneSettingsReq) (res *UpdatePhoneSettingsNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updatePhoneSettings"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/settings"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdatePhoneSettings",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/settings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdatePhoneSettingsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdatePhoneSettings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdatePhoneSettings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdatePhoneSettingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdatePolicy invokes updatePolicy operation.
//
// Updates the policy subsetting of a specific [auto receptionist](https://support.zoom.
// us/hc/en-us/articles/360021121312-Managing-Auto-Receptionists-and-Interactive-Voice-Response-IVR-)
// according to the `policyType`. For example, you can use this API to update shared access members.
// **Prerequisites:**
// * Pro or higher account plan with Zoom Phone License
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:auto_receptionist_policy:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// PATCH /phone/auto_receptionists/{autoReceptionistId}/policies/{policyType}
func (c *Client) UpdatePolicy(ctx context.Context, request OptUpdatePolicyReq, params UpdatePolicyParams) error {
	_, err := c.sendUpdatePolicy(ctx, request, params)
	return err
}

func (c *Client) sendUpdatePolicy(ctx context.Context, request OptUpdatePolicyReq, params UpdatePolicyParams) (res *UpdatePolicyNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updatePolicy"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/auto_receptionists/{autoReceptionistId}/policies/{policyType}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdatePolicy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/auto_receptionists/"
	{
		// Encode "autoReceptionistId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "autoReceptionistId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AutoReceptionistId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/policies/"
	{
		// Encode "policyType" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "policyType",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PolicyType))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdatePolicyRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdatePolicy", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdatePolicy", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdatePolicyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateProvisionTemplate invokes updateProvisionTemplate operation.
//
// Use this API to update a [provision template](https://support.zoom.
// us/hc/en-us/articles/360035817952#h_7b34cd1d-5ae6-4a23-bd04-454a6ad8cb3e) in a Zoom account.
// **Prerequisites:**
// * A Pro or higher account plan
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:provision_template:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// PATCH /phone/provision_templates/{templateId}
func (c *Client) UpdateProvisionTemplate(ctx context.Context, request OptUpdateProvisionTemplateReq, params UpdateProvisionTemplateParams) error {
	_, err := c.sendUpdateProvisionTemplate(ctx, request, params)
	return err
}

func (c *Client) sendUpdateProvisionTemplate(ctx context.Context, request OptUpdateProvisionTemplateReq, params UpdateProvisionTemplateParams) (res *UpdateProvisionTemplateNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateProvisionTemplate"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/provision_templates/{templateId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateProvisionTemplate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/provision_templates/"
	{
		// Encode "templateId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "templateId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TemplateId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateProvisionTemplateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateProvisionTemplate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateProvisionTemplate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateProvisionTemplateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateProvisionTemplateToDevice invokes updateProvisionTemplateToDevice operation.
//
// Use this API to [assign a provision template to a device](https://support.zoom.
// us/hc/en-us/articles/360035817952#h_6b52ef26-d070-40ed-a3fa-520571944afc) or [remove a provision
// template from the device](https://support.zoom.
// us/hc/en-us/articles/360035817952#h_7b34cd1d-5ae6-4a23-bd04-454a6ad8cb3e) by leaving `templateId`
// empty.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// * [Supported device](https://support.zoom.us/hc/en-us/articles/360029698771#note)
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:device_provision_template:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// PUT /phone/devices/{deviceId}/provision_templates
func (c *Client) UpdateProvisionTemplateToDevice(ctx context.Context, request OptUpdateProvisionTemplateToDeviceReq, params UpdateProvisionTemplateToDeviceParams) error {
	_, err := c.sendUpdateProvisionTemplateToDevice(ctx, request, params)
	return err
}

func (c *Client) sendUpdateProvisionTemplateToDevice(ctx context.Context, request OptUpdateProvisionTemplateToDeviceReq, params UpdateProvisionTemplateToDeviceParams) (res *UpdateProvisionTemplateToDeviceNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateProvisionTemplateToDevice"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/phone/devices/{deviceId}/provision_templates"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateProvisionTemplateToDevice",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/devices/"
	{
		// Encode "deviceId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "deviceId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DeviceId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/provision_templates"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateProvisionTemplateToDeviceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateProvisionTemplateToDevice", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateProvisionTemplateToDevice", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateProvisionTemplateToDeviceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateRecordingStatus invokes UpdateRecordingStatus operation.
//
// Updates the status of a single recording in account.
// **Prerequisites:**
// * User must belong to a Business or Enterprise account
// * User must have a Zoom Phone license
// **Scopes:** `phone:write:admin`,`phone:write`,`phone_recording:write`,`phone_recording:write:admin`
// **Granular Scopes:** `phone:update:call_recording`,`phone:update:call_recording:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// PUT /phone/recordings/{recordingId}/status
func (c *Client) UpdateRecordingStatus(ctx context.Context, request OptUpdateRecordingStatusReq, params UpdateRecordingStatusParams) error {
	_, err := c.sendUpdateRecordingStatus(ctx, request, params)
	return err
}

func (c *Client) sendUpdateRecordingStatus(ctx context.Context, request OptUpdateRecordingStatusReq, params UpdateRecordingStatusParams) (res *UpdateRecordingStatusNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("UpdateRecordingStatus"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/phone/recordings/{recordingId}/status"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateRecordingStatus",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/recordings/"
	{
		// Encode "recordingId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "recordingId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RecordingId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/status"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateRecordingStatusRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateRecordingStatus", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateRecordingStatus", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateRecordingStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateRoutingRule invokes updateRoutingRule operation.
//
// Updates the directory backup routing rule.
// The directory backup routing rules are a series of predefined regular expressions. These rules are
// used to route outgoing calls. If a dialed number does not match a Zoom Phone user, and does not
// match a defined external contact, these rules are tested next. If a dialed number does not match
// any rules, the call will be routed through the PSTN.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:routing_rule:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// PATCH /phone/routing_rules/{routingRuleId}
func (c *Client) UpdateRoutingRule(ctx context.Context, request OptUpdateRoutingRuleReq, params UpdateRoutingRuleParams) error {
	_, err := c.sendUpdateRoutingRule(ctx, request, params)
	return err
}

func (c *Client) sendUpdateRoutingRule(ctx context.Context, request OptUpdateRoutingRuleReq, params UpdateRoutingRuleParams) (res *UpdateRoutingRuleNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateRoutingRule"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/routing_rules/{routingRuleId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateRoutingRule",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/routing_rules/"
	{
		// Encode "routingRuleId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "routingRuleId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoutingRuleId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateRoutingRuleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateRoutingRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateRoutingRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateRoutingRuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateSLGPolicySubSetting invokes updateSLGPolicySubSetting operation.
//
// Updates the policy sub-setting for a specific [shared line group](https://support.zoom.
// us/hc/en-us/articles/360038850792) according to the `policyType`. For example, you can use this
// API to update shared access members.
// **Prerequisites:**
// * Pro or higher account with Zoom Phone license.
// * Account owner or admin privileges
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:shared_line_group_policy:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// PATCH /phone/shared_line_groups/{slgId}/policies/{policyType}
func (c *Client) UpdateSLGPolicySubSetting(ctx context.Context, request OptUpdateSLGPolicySubSettingReq, params UpdateSLGPolicySubSettingParams) error {
	_, err := c.sendUpdateSLGPolicySubSetting(ctx, request, params)
	return err
}

func (c *Client) sendUpdateSLGPolicySubSetting(ctx context.Context, request OptUpdateSLGPolicySubSettingReq, params UpdateSLGPolicySubSettingParams) (res *UpdateSLGPolicySubSettingNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateSLGPolicySubSetting"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/shared_line_groups/{slgId}/policies/{policyType}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateSLGPolicySubSetting",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/shared_line_groups/"
	{
		// Encode "slgId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "slgId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SlgId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/policies/"
	{
		// Encode "policyType" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "policyType",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PolicyType))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateSLGPolicySubSettingRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateSLGPolicySubSetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateSLGPolicySubSetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateSLGPolicySubSettingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateSettingTemplate invokes updateSettingTemplate operation.
//
// Updates or modifies a phone template's settings.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:setting_template:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// PATCH /phone/setting_templates/{templateId}
func (c *Client) UpdateSettingTemplate(ctx context.Context, request OptUpdateSettingTemplateReq, params UpdateSettingTemplateParams) error {
	_, err := c.sendUpdateSettingTemplate(ctx, request, params)
	return err
}

func (c *Client) sendUpdateSettingTemplate(ctx context.Context, request OptUpdateSettingTemplateReq, params UpdateSettingTemplateParams) (res *UpdateSettingTemplateNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateSettingTemplate"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/setting_templates/{templateId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateSettingTemplate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/setting_templates/"
	{
		// Encode "templateId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "templateId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TemplateId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateSettingTemplateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateSettingTemplate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateSettingTemplate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateSettingTemplateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateSharedLineGroupPolicy invokes updateSharedLineGroupPolicy operation.
//
// Updates the policy setting of a specific [shared line group](https://support.zoom.
// us/hc/en-us/articles/360038850792).
// **Prerequisites:**
// * Pro or higher account plan with Zoom Phone License
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:shared_line_group_policy:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// PATCH /phone/shared_line_groups/{sharedLineGroupId}/policies
func (c *Client) UpdateSharedLineGroupPolicy(ctx context.Context, request OptUpdateSharedLineGroupPolicyReq, params UpdateSharedLineGroupPolicyParams) error {
	_, err := c.sendUpdateSharedLineGroupPolicy(ctx, request, params)
	return err
}

func (c *Client) sendUpdateSharedLineGroupPolicy(ctx context.Context, request OptUpdateSharedLineGroupPolicyReq, params UpdateSharedLineGroupPolicyParams) (res *UpdateSharedLineGroupPolicyNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateSharedLineGroupPolicy"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/shared_line_groups/{sharedLineGroupId}/policies"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateSharedLineGroupPolicy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/shared_line_groups/"
	{
		// Encode "sharedLineGroupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sharedLineGroupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SharedLineGroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/policies"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateSharedLineGroupPolicyRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateSharedLineGroupPolicy", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateSharedLineGroupPolicy", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateSharedLineGroupPolicyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateSiteDetails invokes updateSiteDetails operation.
//
// Updates information about a specific [site](https://support.zoom.
// us/hc/en-us/articles/360020809672). It allows you to organize Zoom Phone users in your
// organization.
// **Prerequisites:**
// * Account must have a Pro or a higher plan with Zoom Phone license.
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:site:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// PATCH /phone/sites/{siteId}
func (c *Client) UpdateSiteDetails(ctx context.Context, request OptUpdateSiteDetailsReq, params UpdateSiteDetailsParams) error {
	_, err := c.sendUpdateSiteDetails(ctx, request, params)
	return err
}

func (c *Client) sendUpdateSiteDetails(ctx context.Context, request OptUpdateSiteDetailsReq, params UpdateSiteDetailsParams) (res *UpdateSiteDetailsNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateSiteDetails"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/sites/{siteId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateSiteDetails",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/sites/"
	{
		// Encode "siteId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "siteId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SiteId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateSiteDetailsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateSiteDetails", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateSiteDetails", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateSiteDetailsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateSiteForUnassignedPhoneNumbers invokes updateSiteForUnassignedPhoneNumbers operation.
//
// Updates a site's unassigned [phone numbers](https://support.zoom.
// us/hc/en-us/articles/360020808292-Managing-Phone-Numbers#h_38ba8b01-26e3-4b1b-a9b5-0717c00a7ca6).
// Up to 20 phone numbers can be updated in a single request.
// **Prerequisites:**
// * A Pro or higher account plan
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:site_number:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// PATCH /phone/numbers/sites/{siteId}
func (c *Client) UpdateSiteForUnassignedPhoneNumbers(ctx context.Context, request OptUpdateSiteForUnassignedPhoneNumbersReq, params UpdateSiteForUnassignedPhoneNumbersParams) error {
	_, err := c.sendUpdateSiteForUnassignedPhoneNumbers(ctx, request, params)
	return err
}

func (c *Client) sendUpdateSiteForUnassignedPhoneNumbers(ctx context.Context, request OptUpdateSiteForUnassignedPhoneNumbersReq, params UpdateSiteForUnassignedPhoneNumbersParams) (res *UpdateSiteForUnassignedPhoneNumbersNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateSiteForUnassignedPhoneNumbers"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/numbers/sites/{siteId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateSiteForUnassignedPhoneNumbers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/numbers/sites/"
	{
		// Encode "siteId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "siteId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SiteId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateSiteForUnassignedPhoneNumbersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateSiteForUnassignedPhoneNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateSiteForUnassignedPhoneNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateSiteForUnassignedPhoneNumbersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateSiteOutboundCallingCountriesOrRegions invokes UpdateSiteOutboundCallingCountriesOrRegions operation.
//
// Updates the site level outbound calling policy country or region.
// **Prerequisites:**
// * Account must have a Pro or a higher plan with a Zoom Phone license.
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:site_outbound_calling_rule:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// PATCH /phone/sites/{siteId}/outbound_calling/countries_regions
func (c *Client) UpdateSiteOutboundCallingCountriesOrRegions(ctx context.Context, request OptUpdateSiteOutboundCallingCountriesOrRegionsReq, params UpdateSiteOutboundCallingCountriesOrRegionsParams) error {
	_, err := c.sendUpdateSiteOutboundCallingCountriesOrRegions(ctx, request, params)
	return err
}

func (c *Client) sendUpdateSiteOutboundCallingCountriesOrRegions(ctx context.Context, request OptUpdateSiteOutboundCallingCountriesOrRegionsReq, params UpdateSiteOutboundCallingCountriesOrRegionsParams) (res *UpdateSiteOutboundCallingCountriesOrRegionsNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("UpdateSiteOutboundCallingCountriesOrRegions"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/sites/{siteId}/outbound_calling/countries_regions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateSiteOutboundCallingCountriesOrRegions",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/sites/"
	{
		// Encode "siteId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "siteId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SiteId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/outbound_calling/countries_regions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateSiteOutboundCallingCountriesOrRegionsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateSiteOutboundCallingCountriesOrRegions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateSiteOutboundCallingCountriesOrRegions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateSiteOutboundCallingCountriesOrRegionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateSiteOutboundCallingExceptionRule invokes UpdateSiteOutboundCallingExceptionRule operation.
//
// Updates the site level outbound calling policy for the country region exception rule.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license
// * Account owner or admin permissions
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:site_outbound_calling_rule:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// PATCH /phone/sites/{siteId}/outbound_calling/exception_rules/{exceptionRuleId}
func (c *Client) UpdateSiteOutboundCallingExceptionRule(ctx context.Context, request OptUpdateSiteOutboundCallingExceptionRuleReq, params UpdateSiteOutboundCallingExceptionRuleParams) error {
	_, err := c.sendUpdateSiteOutboundCallingExceptionRule(ctx, request, params)
	return err
}

func (c *Client) sendUpdateSiteOutboundCallingExceptionRule(ctx context.Context, request OptUpdateSiteOutboundCallingExceptionRuleReq, params UpdateSiteOutboundCallingExceptionRuleParams) (res *UpdateSiteOutboundCallingExceptionRuleNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("UpdateSiteOutboundCallingExceptionRule"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/sites/{siteId}/outbound_calling/exception_rules/{exceptionRuleId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateSiteOutboundCallingExceptionRule",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/sites/"
	{
		// Encode "siteId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "siteId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SiteId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/outbound_calling/exception_rules/"
	{
		// Encode "exceptionRuleId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "exceptionRuleId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ExceptionRuleId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateSiteOutboundCallingExceptionRuleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateSiteOutboundCallingExceptionRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateSiteOutboundCallingExceptionRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateSiteOutboundCallingExceptionRuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateSiteSetting invokes updateSiteSetting operation.
//
// Sites allow you to organize Zoom Phone users in your organization. Use this API to update the site
// setting of a specific [site](https://support.zoom.us/hc/en-us/articles/360020809672) according to
// the setting type.
// **Prerequisites:**
// * Account must have a Pro or a higher plan with Zoom Phone license.
// * Multiple sites must be [enabled](https://support.zoom.
// us/hc/en-us/articles/360020809672-Managing-Multiple-Sites#h_05c88e35-1593-491f-b1a8-b7139a75dc15).
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:site_setting:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// PATCH /phone/sites/{siteId}/settings/{settingType}
func (c *Client) UpdateSiteSetting(ctx context.Context, request OptUpdateSiteSettingReq, params UpdateSiteSettingParams) error {
	_, err := c.sendUpdateSiteSetting(ctx, request, params)
	return err
}

func (c *Client) sendUpdateSiteSetting(ctx context.Context, request OptUpdateSiteSettingReq, params UpdateSiteSettingParams) (res *UpdateSiteSettingNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateSiteSetting"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/sites/{siteId}/settings/{settingType}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateSiteSetting",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/sites/"
	{
		// Encode "siteId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "siteId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SiteId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/settings/"
	{
		// Encode "settingType" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "settingType",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SettingType))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateSiteSettingRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateSiteSetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateSiteSetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateSiteSettingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateUserOutboundCallingCountriesOrRegions invokes UpdateUserOutboundCallingCountriesOrRegions operation.
//
// Updates the user level outbound calling policy country or region.
// **Prerequisite:**
// * Account must have a Pro or a higher plan with a Zoom Phone license.
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:user_outbound_calling_rule:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// PATCH /phone/users/{userId}/outbound_calling/countries_regions
func (c *Client) UpdateUserOutboundCallingCountriesOrRegions(ctx context.Context, request OptUpdateUserOutboundCallingCountriesOrRegionsReq, params UpdateUserOutboundCallingCountriesOrRegionsParams) error {
	_, err := c.sendUpdateUserOutboundCallingCountriesOrRegions(ctx, request, params)
	return err
}

func (c *Client) sendUpdateUserOutboundCallingCountriesOrRegions(ctx context.Context, request OptUpdateUserOutboundCallingCountriesOrRegionsReq, params UpdateUserOutboundCallingCountriesOrRegionsParams) (res *UpdateUserOutboundCallingCountriesOrRegionsNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("UpdateUserOutboundCallingCountriesOrRegions"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/users/{userId}/outbound_calling/countries_regions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateUserOutboundCallingCountriesOrRegions",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/outbound_calling/countries_regions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateUserOutboundCallingCountriesOrRegionsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateUserOutboundCallingCountriesOrRegions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateUserOutboundCallingCountriesOrRegions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateUserOutboundCallingCountriesOrRegionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateUserOutboundCallingExceptionRule invokes UpdateUserOutboundCallingExceptionRule operation.
//
// Updates the user level outbound calling policy for the country region exception rule.
// **Prerequisites:**
// * Pro or a higher account with Zoom Phone license.
// * Account owner or admin permissions.
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:user_outbound_calling_rule:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// PATCH /phone/users/{userId}/outbound_calling/exception_rules/{exceptionRuleId}
func (c *Client) UpdateUserOutboundCallingExceptionRule(ctx context.Context, request OptUpdateUserOutboundCallingExceptionRuleReq, params UpdateUserOutboundCallingExceptionRuleParams) error {
	_, err := c.sendUpdateUserOutboundCallingExceptionRule(ctx, request, params)
	return err
}

func (c *Client) sendUpdateUserOutboundCallingExceptionRule(ctx context.Context, request OptUpdateUserOutboundCallingExceptionRuleReq, params UpdateUserOutboundCallingExceptionRuleParams) (res *UpdateUserOutboundCallingExceptionRuleNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("UpdateUserOutboundCallingExceptionRule"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/users/{userId}/outbound_calling/exception_rules/{exceptionRuleId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateUserOutboundCallingExceptionRule",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/outbound_calling/exception_rules/"
	{
		// Encode "exceptionRuleId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "exceptionRuleId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ExceptionRuleId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateUserOutboundCallingExceptionRuleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateUserOutboundCallingExceptionRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateUserOutboundCallingExceptionRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateUserOutboundCallingExceptionRuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateUserProfile invokes updateUserProfile operation.
//
// Updates a user's [Zoom Phone](https://support.zoom.us/hc/en-us/categories/360001370051-Zoom-Phone)
// profile. For user-level apps, pass [the `me` value](https://marketplace.zoom.
// us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
// To add, update or remove the shared access members for voicemail and call recordings, use the
// [Add](https://marketplace.zoom.
// us/docs/api-reference/phone/methods#tag/Users/operation/addUserSetting)/[Update](https://marketplace.zoom.us/docs/api-reference/phone/methods#tag/Users/operation/updateUserSetting)/[Delete](https://marketplace.zoom.us/docs/api-reference/phone/methods#tag/Users/operation/deleteUserSetting) a user's shared access setting API.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:write`,`phone:write:admin`
// **Granular Scopes:** `phone:update:user`,`phone:update:user:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// PATCH /phone/users/{userId}
func (c *Client) UpdateUserProfile(ctx context.Context, request OptUpdateUserProfileReq, params UpdateUserProfileParams) error {
	_, err := c.sendUpdateUserProfile(ctx, request, params)
	return err
}

func (c *Client) sendUpdateUserProfile(ctx context.Context, request OptUpdateUserProfileReq, params UpdateUserProfileParams) (res *UpdateUserProfileNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateUserProfile"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/users/{userId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateUserProfile",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateUserProfileRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateUserProfile", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateUserProfile", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateUserProfileResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateUserSetting invokes updateUserSetting operation.
//
// Updates the user setting according to the setting type, specifically for delegation, intercom and
// shared access for voicemail and call recordings. For user-level apps, pass [the `me`
// value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the
// `userId` parameter.
// To see the shared access settings in the Zoom web portal, go to **Admin &gt; Phone System
// Management &gt; Users &amp; Rooms** . Click **Users** and select **User Policy**. Go to
// **Voicemail, Automatic Call Recording and Ad Hoc Call Recording**.
// To view the delegation and intercom setting in your Zoom web portal, navigate to **Admin &gt;
// Phone System Management &gt; Users &amp; Rooms**. Click the **Users** tab and select **User
// Settings**
// **Prerequisites:**
// * A Business or Enterprise account
// **Scopes:** `phone:write:admin`,`phone:write`
// **Granular Scopes:** `phone:update:shared_setting`,`phone:update:shared_setting:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// PATCH /phone/users/{userId}/settings/{settingType}
func (c *Client) UpdateUserSetting(ctx context.Context, request OptUpdateUserSettingReq, params UpdateUserSettingParams) error {
	_, err := c.sendUpdateUserSetting(ctx, request, params)
	return err
}

func (c *Client) sendUpdateUserSetting(ctx context.Context, request OptUpdateUserSettingReq, params UpdateUserSettingParams) (res *UpdateUserSettingNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateUserSetting"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/users/{userId}/settings/{settingType}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateUserSetting",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/phone/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/settings/"
	{
		// Encode "settingType" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "settingType",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SettingType))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateUserSettingRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateUserSetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateUserSetting", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateUserSettingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateUserSettings invokes updateUserSettings operation.
//
// Updates the Zoom Phone [profile settings](https://support.zoom.
// us/hc/en-us/articles/360021325712-Configuring-Settings) of a user. For user-level apps, pass [the
// `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of
// the `userId` parameter.
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:write`,`phone:write:admin`
// **Granular Scopes:** `phone:update:user_setting`,`phone:update:user_setting:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// PATCH /phone/users/{userId}/settings
func (c *Client) UpdateUserSettings(ctx context.Context, request OptUpdateUserSettingsReq, params UpdateUserSettingsParams) error {
	_, err := c.sendUpdateUserSettings(ctx, request, params)
	return err
}

func (c *Client) sendUpdateUserSettings(ctx context.Context, request OptUpdateUserSettingsReq, params UpdateUserSettingsParams) (res *UpdateUserSettingsNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateUserSettings"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/users/{userId}/settings"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateUserSettings",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/settings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateUserSettingsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateUserSettings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateUserSettings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateUserSettingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateUsersPropertiesInBatch invokes updateUsersPropertiesInBatch operation.
//
// Updates multiple users' properties in batch. For example, you can update the users'
// [site](https://support.zoom.us/hc/en-us/articles/360020809672) when `batchType` is equal to
// `move_site`. You can update 10 users at a time.
// **Prerequisites:**
// * Business, or Education account
// * Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:batch_users:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// PUT /phone/users/batch
func (c *Client) UpdateUsersPropertiesInBatch(ctx context.Context, request OptUpdateUsersPropertiesInBatchReq) error {
	_, err := c.sendUpdateUsersPropertiesInBatch(ctx, request)
	return err
}

func (c *Client) sendUpdateUsersPropertiesInBatch(ctx context.Context, request OptUpdateUsersPropertiesInBatchReq) (res *UpdateUsersPropertiesInBatchNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateUsersPropertiesInBatch"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/phone/users/batch"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateUsersPropertiesInBatch",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone/users/batch"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateUsersPropertiesInBatchRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateUsersPropertiesInBatch", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateUsersPropertiesInBatch", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateUsersPropertiesInBatchResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateVoicemailReadStatus invokes updateVoicemailReadStatus operation.
//
// Updates the status of [voicemail message](https://support.zoom.
// us/hc/en-us/articles/360021400211-Managing-voicemail-messages).
// **Prerequisites:**
// * A Business or Enterprise account
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`,`phone:write`,`phone_voicemail:write`,`phone_voicemail:write:admin`
// **Granular Scopes:** `phone:update:voicemail`,`phone:update:voicemail:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// PATCH /phone/voice_mails/{voicemailId}
func (c *Client) UpdateVoicemailReadStatus(ctx context.Context, params UpdateVoicemailReadStatusParams) error {
	_, err := c.sendUpdateVoicemailReadStatus(ctx, params)
	return err
}

func (c *Client) sendUpdateVoicemailReadStatus(ctx context.Context, params UpdateVoicemailReadStatusParams) (res *UpdateVoicemailReadStatusNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateVoicemailReadStatus"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/voice_mails/{voicemailId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateVoicemailReadStatus",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/voice_mails/"
	{
		// Encode "voicemailId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "voicemailId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VoicemailId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "read_status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "read_status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.ReadStatus))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateVoicemailReadStatus", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateVoicemailReadStatus", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateVoicemailReadStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateZoomRoom invokes updateZoomRoom operation.
//
// Use this API to update a [Zoom Room](https://support.zoom.us/hc/en-us/articles/360025153711) in an
// account that has the Zoom Phone license assigned.
// **Prerequisites:**
// * A Pro or higher account plan
// * A Zoom Phone license
// **Scopes:** `phone:write:admin`
// **Granular Scopes:** `phone:update:room:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// PATCH /phone/rooms/{roomId}
func (c *Client) UpdateZoomRoom(ctx context.Context, request OptUpdateZoomRoomReq, params UpdateZoomRoomParams) error {
	_, err := c.sendUpdateZoomRoom(ctx, request, params)
	return err
}

func (c *Client) sendUpdateZoomRoom(ctx context.Context, request OptUpdateZoomRoomReq, params UpdateZoomRoomParams) (res *UpdateZoomRoomNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateZoomRoom"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/phone/rooms/{roomId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateZoomRoom",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone/rooms/"
	{
		// Encode "roomId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "roomId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoomId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateZoomRoomRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateZoomRoom", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateZoomRoom", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateZoomRoomResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UserSmsSession invokes userSmsSession operation.
//
// Returns details about SMS sessions for a user.
// For user-level apps, pass [the `me` value](https://marketplace.zoom.
// us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
// **Prerequisites:**
// * Paid account
// * User-enabled Zoom phone
// **Scopes:** `phone:read:admin`,`phone:read`,`phone_sms:read`,`phone_sms:read:admin`
// **Granular Scopes:** `phone:read:list_sms_sessions`,`phone:read:list_sms_sessions:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// GET /phone/users/{userId}/sms/sessions
func (c *Client) UserSmsSession(ctx context.Context, params UserSmsSessionParams) (*UserSmsSessionOK, error) {
	res, err := c.sendUserSmsSession(ctx, params)
	return res, err
}

func (c *Client) sendUserSmsSession(ctx context.Context, params UserSmsSessionParams) (res *UserSmsSessionOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("userSmsSession"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/phone/users/{userId}/sms/sessions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UserSmsSession",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/sms/sessions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "session_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "session_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SessionType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "from" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "from",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.From.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "to" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "to",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.To.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "phone_number" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "phone_number",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PhoneNumber.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UserSmsSession", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UserSmsSession", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUserSmsSessionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
