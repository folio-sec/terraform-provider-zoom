// Code generated by ogen, DO NOT EDIT.

package zoomuser

import (
	"context"
	"net/url"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.26.0"
	"go.opentelemetry.io/otel/trace"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
)

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// BulkUpdateFeature invokes bulkUpdateFeature operation.
	//
	// Update multiple features for a user.
	// **Limit**: This endpoint can process a maximum of 30 users at a time.
	// **Scopes:** `user:write`,`user:write:admin`
	// **Granular Scopes:** `user:write:feature:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// POST /users/features
	BulkUpdateFeature(ctx context.Context, request OptBulkUpdateFeatureReq) (*BulkUpdateFeatureCreated, error)
	// ContactGroup invokes contactGroup operation.
	//
	// Get a [contact group](https://support.zoom.us/hc/en-us/articles/204519819-Group-Management-) under
	// an account.
	// **Prerequisite**: Pro or higher account.
	// **Scopes:** `contact_group:write:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /contacts/groups/{groupId}
	ContactGroup(ctx context.Context, params ContactGroupParams) (*ContactGroupOK, error)
	// ContactGroupCreate invokes contactGroupCreate operation.
	//
	// Use this API to create a [contact group](https://support.zoom.
	// us/hc/en-us/articles/204519819-Group-Management).
	// **Prerequisite**: Pro or higher account.
	// **Scopes:** `contact_group:write:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Heavy`.
	//
	// POST /contacts/groups
	ContactGroupCreate(ctx context.Context, request OptContactGroupCreateReq) (*ContactGroupCreateCreated, error)
	// ContactGroupDelete invokes contactGroupDelete operation.
	//
	// Use this API to delete a [contact group](https://support.zoom.
	// us/hc/en-us/articles/204519819-Group-Management-).
	// **Prerequisite**: Pro or higher account.
	// **Scopes:** `contact_group:write:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Heavy`.
	//
	// DELETE /contacts/groups/{groupId}
	ContactGroupDelete(ctx context.Context, params ContactGroupDeleteParams) error
	// ContactGroupMemberAdd invokes contactGroupMemberAdd operation.
	//
	// Use this API to add members to a [contact group](https://support.zoom.
	// us/hc/en-us/articles/204519819-Group-Management).
	// **Prerequisite**: Pro or higher account.
	// **Scopes:** `contact_group:write:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `HEAVY`.
	//
	// POST /contacts/groups/{groupId}/members
	ContactGroupMemberAdd(ctx context.Context, request OptContactGroupMemberAddReq, params ContactGroupMemberAddParams) (*ContactGroupMemberAddCreated, error)
	// ContactGroupMemberRemove invokes contactGroupMemberRemove operation.
	//
	// Removes members in a [contact group](https://support.zoom.
	// us/hc/en-us/articles/204519819-Group-Management-).
	// **Prerequisite**: Pro or higher account.
	// **Scopes:** `contact_group:write:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `HEAVY`.
	//
	// DELETE /contacts/groups/{groupId}/members
	ContactGroupMemberRemove(ctx context.Context, params ContactGroupMemberRemoveParams) error
	// ContactGroupMembers invokes contactGroupMembers operation.
	//
	// List members in [contact groups](https://support.zoom.
	// us/hc/en-us/articles/204519819-Group-Management-) under an account.
	// **Prerequisite**: Pro or higher account.
	// **Scopes:** `contact_group:read:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// GET /contacts/groups/{groupId}/members
	ContactGroupMembers(ctx context.Context, params ContactGroupMembersParams) (*ContactGroupMembersOK, error)
	// ContactGroupUpdate invokes contactGroupUpdate operation.
	//
	// Update a [contact group](https://support.zoom.us/hc/en-us/articles/204519819-Group-Management-)
	// under your account.
	// **Prerequisite**: Pro or higher account.
	// **Scopes:** `contact_group:write:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Heavy`.
	//
	// PATCH /contacts/groups/{groupId}
	ContactGroupUpdate(ctx context.Context, request OptContactGroupUpdateReq, params ContactGroupUpdateParams) error
	// ContactGroups invokes contactGroups operation.
	//
	// List [contact groups](https://support.zoom.us/hc/en-us/articles/204519819-Group-Management-) under
	// an account.
	// **Prerequisite**: Pro or higher account.
	// **Scopes:** `contact_group:read:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /contacts/groups
	ContactGroups(ctx context.Context, params ContactGroupsParams) (*ContactGroupsOK, error)
	// DelGroupVB invokes delGroupVB operation.
	//
	// Use this API to delete a group's [Virtual Background files](https://support.zoom.
	// us/hc/en-us/articles/210707503-Virtual-Background#h_01EJF3YFEWGT8YA0ZJ079JEDQE).
	// **Prerequisites:**
	// * The [Virtual Background feature](https://support.zoom.
	// us/hc/en-us/articles/210707503-Virtual-Background#h_2ef28080-fce9-4ac2-b567-dc958afab1b7) must be
	// enabled on the account.
	// **Scopes:** `group:write:admin`
	// **Granular Scopes:** `group:delete:virtual_background_files:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// DELETE /groups/{groupId}/settings/virtual_backgrounds
	DelGroupVB(ctx context.Context, params DelGroupVBParams) error
	// DelUserVB invokes delUserVB operation.
	//
	// Use this API to delete a user's Virtual Background files. For user-level apps, pass [the `me`
	// value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the
	// `userId` parameter.
	// **Prerequisites:**
	// * The [Virtual Background feature](https://support.zoom.
	// us/hc/en-us/articles/210707503-Virtual-Background#h_2ef28080-fce9-4ac2-b567-dc958afab1b7) must be
	// enabled on the account.
	// **Scopes:** `user:write:admin`,`user:write`
	// **Granular Scopes:** `user:delete:virtual_background_files`,
	// `user:delete:virtual_background_files:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// DELETE /users/{userId}/settings/virtual_backgrounds
	DelUserVB(ctx context.Context, params DelUserVBParams) error
	// GetCollaborationDevice invokes getCollaborationDevice operation.
	//
	// Get collaboration device detail. For user-level apps, pass [the `me` value](https://developers.
	// zoom.us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the `userId` parameter.
	// **Scopes:** `user:read`,`user:write`,`user:read:admin`,`user:write:admin`
	// **Granular Scopes:** `user:read:collaboration_device`,`user:read:collaboration_device:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// GET /users/{userId}/collaboration_devices/{collaborationDeviceId}
	GetCollaborationDevice(ctx context.Context, params GetCollaborationDeviceParams) (*GetCollaborationDeviceOK, error)
	// GetGroupLockSettings invokes getGroupLockSettings operation.
	//
	// Retrieve a [group's](https://support.zoom.us/hc/en-us/articles/204519819-Group-Management-) locked
	// settings.
	// If you lock a setting, the group members will not be able to modify it individually.
	// **Note:** The `force_pmi_jbh_password` field under meeting settings is to be deprecated on
	// September 22, 2019. This field is replaced by another field that will provide the same
	// functionality.
	// **Prerequisite**: Pro, Business, or Education account
	// **Scopes:** `group:read:admin`,`group:write:admin`
	// **Granular Scopes:** `group:read:lock_settings:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// GET /groups/{groupId}/lock_settings
	GetGroupLockSettings(ctx context.Context, params GetGroupLockSettingsParams) (GetGroupLockSettingsOK, error)
	// GetGroupSettings invokes getGroupSettings operation.
	//
	// Get settings for a [group](https://support.zoom.us/hc/en-us/articles/204519819-Group-Management-).
	// **Prerequisite**: Pro, Business, or Education account.
	// **Scopes:** `group:read:admin`,`group:write:admin`
	// **Granular Scopes:** `group:read:settings:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// GET /groups/{groupId}/settings
	GetGroupSettings(ctx context.Context, params GetGroupSettingsParams) (GetGroupSettingsOK, error)
	// GetUserMeetingTemplates invokes getUserMeetingTemplates operation.
	//
	// Retrieve a user's [meeting template](https://support.zoom.
	// us/hc/en-us/articles/360036559151-Meeting-templates). For user-level apps, pass [the `me`
	// value](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the
	// `userId` parameter.
	// **Scopes:** `user:read:admin`,`user:read`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /users/{userId}/meeting_templates/{meetingTemplateId}
	GetUserMeetingTemplates(ctx context.Context, params GetUserMeetingTemplatesParams) (*GetUserMeetingTemplatesOK, error)
	// GetUserPresenceStatus invokes getUserPresenceStatus operation.
	//
	// Returns a user's current status.
	// Users in the Zoom desktop client and mobile apps are assigned with a [presence
	// status](https://support.zoom.us/hc/en-us/articles/360032554051-Status-Icons). The presence status
	// displays the user's  availability.
	// The available statuses are:
	// * **Away**
	// * **Do not disturb**
	// * **Available**
	// * **In a calendar event**
	// * **Presenting**
	// * **In a Zoom meeting**
	// * **On a call**
	// * **Out of Office**
	// * **Busy**
	// * **Offline**
	// If the presence status is **Do not disturb**, `end_time` and `remaining_time` properties are only
	// visible if the user being queried is also the current user.
	// **Scopes:** `user:read`,`user:read:admin`
	// **Granular Scopes:** `user:read:presence_status`,`user:read:presence_status:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// GET /users/{userId}/presence_status
	GetUserPresenceStatus(ctx context.Context, params GetUserPresenceStatusParams) (GetUserPresenceStatusOK, error)
	// Group invokes group operation.
	//
	// Get a [group](https://support.zoom.us/hc/en-us/articles/204519819-Group-Management-) under an
	// account.
	// **Prerequisite**: Pro, Business, or Education account
	// **Scopes:** `group:read:admin`,`group:write:admin`
	// **Granular Scopes:** `group:read:group:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /groups/{groupId}
	Group(ctx context.Context, params GroupParams) (*GroupOK, error)
	// GroupAdmins invokes groupAdmins operation.
	//
	// Use this API to return a list of [group](https://support.zoom.
	// us/hc/en-us/articles/204519819-Group-Management-) administrators under your account.
	// **Prerequisites:**
	// * A Pro, Business, or Education account
	// **Scopes:** `group:read:admin`,`group:write:admin`
	// **Granular Scopes:** `group:read:administrator:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /groups/{groupId}/admins
	GroupAdmins(ctx context.Context, params GroupAdminsParams) (*GroupAdminsOK, error)
	// GroupAdminsCreate invokes groupAdminsCreate operation.
	//
	// Use this API to add administrators to a [group](https://support.zoom.
	// us/hc/en-us/articles/204519819-Group-Management-) under your account.
	// **Prerequisites:**
	// * A Pro, Business, or Education account
	// **Scopes:** `group:write:admin`
	// **Granular Scopes:** `group:write:administrator:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// POST /groups/{groupId}/admins
	GroupAdminsCreate(ctx context.Context, request OptGroupAdminsCreateReq, params GroupAdminsCreateParams) (GroupAdminsCreateRes, error)
	// GroupAdminsDelete invokes groupAdminsDelete operation.
	//
	// Use this API to remove a [group](https://support.zoom.
	// us/hc/en-us/articles/204519819-Group-Management-) administrator in a Zoom account.
	// **Prerequisites:**
	// * A Pro, Business, or Education account
	// **Scopes:** `group:write:admin`
	// **Granular Scopes:** `group:delete:administrator:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /groups/{groupId}/admins/{userId}
	GroupAdminsDelete(ctx context.Context, params GroupAdminsDeleteParams) (GroupAdminsDeleteRes, error)
	// GroupChannels invokes groupChannels operation.
	//
	// Returns a list of channels for a [group](https://support.zoom.
	// us/hc/en-us/articles/204519819-Group-Management-) under your account.
	// **Prerequisite**:
	// - Pro, Business, or Education account
	// **Scopes:** `group:read:admin`,`group:write:admin`
	// **Granular Scopes:** `group:read:list_channels:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// GET /groups/{groupId}/channels
	GroupChannels(ctx context.Context, params GroupChannelsParams) (*GroupChannelsOK, error)
	// GroupCreate invokes groupCreate operation.
	//
	// Use this API to create a [group](https://support.zoom.
	// us/hc/en-us/articles/204519819-Group-Management). You can add a **maximum** of 100 groups in one
	// account per day, and a maximum of 5000 groups in one account.
	// If you enabled a new group via the user interface, you can also choose whether to display the
	// group and set its privacy level.
	// **Prerequisites**:
	// * A Pro or higher account
	// **Scopes:** `group:write:admin`
	// **Granular Scopes:** `group:write:group:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// POST /groups
	GroupCreate(ctx context.Context, request OptGroupCreateReq) (GroupCreateRes, error)
	// GroupDelete invokes groupDelete operation.
	//
	// Delete an entire [group](https://support.zoom.us/hc/en-us/articles/204519819-Group-Management-).
	// **Prerequisites:** * A Pro, Business, or Education account.
	// **Scopes:** `group:write:admin`
	// **Granular Scopes:** `group:delete:group:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// DELETE /groups/{groupId}
	GroupDelete(ctx context.Context, params GroupDeleteParams) error
	// GroupLockedSettings invokes groupLockedSettings operation.
	//
	// Update a [group's](https://support.zoom.us/hc/en-us/articles/204519819-Group-Management-) locked
	// settings. If you lock a setting, the group members cannot modify it individually.
	// **Note:** The `force_pmi_jbh_password` field under meeting settings is deprecated as of September
	// 22, 2019. This field will be replaced by another field that will provide the same functionality.
	// &lt;/p&gt;
	// **Prerequisite**: Pro, Business, or Education account
	// **Scopes:** `group:write:admin`
	// **Granular Scopes:** `group:update:lock_settings:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// PATCH /groups/{groupId}/lock_settings
	GroupLockedSettings(ctx context.Context, request OptGroupLockedSettingsReq, params GroupLockedSettingsParams) error
	// GroupMembers invokes groupMembers operation.
	//
	// List the members of a [group](https://support.zoom.
	// us/hc/en-us/articles/204519819-Group-Management-) under your account.
	// **Prerequisite**: Pro, Business, or Education account
	// **Scopes:** `group:read:admin`,`group:write:admin`
	// **Granular Scopes:** `group:read:list_members:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /groups/{groupId}/members
	GroupMembers(ctx context.Context, params GroupMembersParams) (*GroupMembersOK, error)
	// GroupMembersCreate invokes groupMembersCreate operation.
	//
	// Use this API to add users to a [group](https://support.zoom.
	// us/hc/en-us/articles/204519819-Group-Management-) in your account.
	// **Prerequisites:**
	// * A Pro, Business, or Education account
	// **Scopes:** `group:write:admin`
	// **Granular Scopes:** `group:write:member:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// POST /groups/{groupId}/members
	GroupMembersCreate(ctx context.Context, request OptGroupMembersCreateReq, params GroupMembersCreateParams) (GroupMembersCreateRes, error)
	// GroupMembersDelete invokes groupMembersDelete operation.
	//
	// Use this API to remove a user from a [group](https://support.zoom.
	// us/hc/en-us/articles/204519819-Group-Management-) in an account.
	// **Prerequisites:**
	// * A Pro, Business, or Education account
	// **Scopes:** `group:write:admin`
	// **Granular Scopes:** `group:delete:member:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /groups/{groupId}/members/{memberId}
	GroupMembersDelete(ctx context.Context, params GroupMembersDeleteParams) (GroupMembersDeleteRes, error)
	// GroupSettingsRegistration invokes groupSettingsRegistration operation.
	//
	// Get webinar registration settings for a [group](https://support.zoom.
	// us/hc/en-us/articles/204519819-Group-Management-).
	// **Prerequisite**: Pro, Business, or Education account
	// **Scopes:** `group:read:admin`,`group:write:admin`
	// **Granular Scopes:** `group:read:registration_settings:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /groups/{groupId}/settings/registration
	GroupSettingsRegistration(ctx context.Context, params GroupSettingsRegistrationParams) (*GroupSettingsRegistrationOK, error)
	// GroupSettingsRegistrationUpdate invokes groupSettingsRegistrationUpdate operation.
	//
	// Update webinar registration settings for a [group](https://support.zoom.
	// us/hc/en-us/articles/204519819-Group-Management-).&lt;p style=&quot;background-color:#FEEFB3;
	// color:#9F6000&quot;&gt;
	// Note:&lt;/b&gt; The `force_pmi_jbh_password` field under meeting settings is planned to be
	// deprecated on September 22, 2019. This field will be replaced by another field that will provide
	// the same functionality.&lt;/p&gt;
	// **Prerequisite**: Pro, Business, or Education account
	// **Scopes:** `group:write:admin`
	// **Granular Scopes:** `group:update:registration_settings:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// PATCH /groups/{groupId}/settings/registration
	GroupSettingsRegistrationUpdate(ctx context.Context, request OptGroupSettingsRegistrationUpdateReq, params GroupSettingsRegistrationUpdateParams) (GroupSettingsRegistrationUpdateRes, error)
	// GroupUpdate invokes groupUpdate operation.
	//
	// Update a [group](https://support.zoom.us/hc/en-us/articles/204519819-Group-Management-) under your
	// account.
	// **Prerequisite**: Pro, Business, or Education account
	// **Scopes:** `group:write:admin`
	// **Granular Scopes:** `group:update:group:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// PATCH /groups/{groupId}
	GroupUpdate(ctx context.Context, request OptGroupUpdateReq, params GroupUpdateParams) (GroupUpdateRes, error)
	// Groups invokes groups operation.
	//
	// List [groups](https://support.zoom.us/hc/en-us/articles/204519819-Group-Management-) under an
	// account.
	// **Prerequisite**: Pro or higher account.
	// **Scopes:** `group:read:admin`,`group:write:admin`
	// **Granular Scopes:** `group:read:list_groups:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /groups
	Groups(ctx context.Context) (*GroupsOK, error)
	// ListCollaborationDevices invokes listCollaborationDevices operation.
	//
	// List a user's collaboration devices. For user-level apps, pass [the `me` value](https://developers.
	// zoom.us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the `userId` parameter.
	// **Scopes:** `user:read`,`user:write`,`user:read:admin`,`user:write:admin`
	// **Granular Scopes:** `user:read:list_collaboration_devices`,
	// `user:read:list_collaboration_devices:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// GET /users/{userId}/collaboration_devices
	ListCollaborationDevices(ctx context.Context, params ListCollaborationDevicesParams) (*ListCollaborationDevicesOK, error)
	// UpdateAGroupMember invokes updateAGroupMember operation.
	//
	// Use this API to perform either of the following tasks:
	// * Remove a group member from one group and move them to a different group.
	// * Set a user's primary group. By default, the primary group is the first group that user is added
	// to.
	// If a user is a member of multiple groups, you can [assign the user a primary
	// group](https://support.zoom.
	// us/hc/en-us/articles/204519819-Group-Management-#h_d07c7dcd-4fd8-485a-b5fe-a322e8d21c09). The user
	// will use the primary group's settings by default. However, if the user is a member of a group with
	// locked settings, those group settings will remain locked to the user.
	// **Prerequisites:**
	// * A Pro or higher account
	// **Scopes:** `group:write:admin`
	// **Granular Scopes:** `group:update:member:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// PATCH /groups/{groupId}/members/{memberId}
	UpdateAGroupMember(ctx context.Context, request OptUpdateAGroupMemberReq, params UpdateAGroupMemberParams) error
	// UpdateGroupSettings invokes updateGroupSettings operation.
	//
	// Update settings for a [group](https://support.zoom.
	// us/hc/en-us/articles/204519819-Group-Management-).
	// **Note:**The `force_pmi_jbh_password` field under meeting settings is planned to be deprecated on
	// September 22, 2019. This field will be replaced by another field that will provide the same
	// functionality
	// **Prerequisite**: Pro, Business, or Education account
	// **Scopes:** `group:write:admin`
	// **Granular Scopes:** `group:update:settings:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// PATCH /groups/{groupId}/settings
	UpdateGroupSettings(ctx context.Context, request OptUpdateGroupSettingsReq, params UpdateGroupSettingsParams) error
	// UpdatePresenceStatus invokes updatePresenceStatus operation.
	//
	// Update a user's presence status. For user-level apps, pass [the `me` value](https://developers.
	// zoom.us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the `userId` parameter.
	// A user's status **cannot** be updated more than once per minute. For example, you can only submit
	// a maximum of one update request per minute for a single user.
	// Users in the Zoom desktop client and mobile apps are assigned with a [presence
	// status](https://support.zoom.us/hc/en-us/articles/360032554051-Status-Icons). The presence status
	// informs users of their contact's availability. Users can also change their own presence status to
	// one the following:
	// * **Away**
	// * **Do not disturb**
	// * **Available**
	// * **In a calendar event**
	// * **Presenting**
	// * **In a Zoom meeting**
	// * **On a call**
	// * **Out of Office**
	// * **Busy**
	// Note that a user's presence status **cannot** be updated via this API if the user is not logged in
	// to the Zoom client.
	// **Scopes:** `user:write`,`user:write:admin`
	// **Granular Scopes:** `user:update:presence_status`,`user:update:presence_status:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// PUT /users/{userId}/presence_status
	UpdatePresenceStatus(ctx context.Context, request OptUpdatePresenceStatusReq, params UpdatePresenceStatusParams) error
	// UploadGroupVB invokes uploadGroupVB operation.
	//
	// Use this API to [upload Virtual Background files](https://support.zoom.
	// us/hc/en-us/articles/210707503-Virtual-Background#h_01EJF3YFEWGT8YA0ZJ079JEDQE) for all users in a
	// group to use.
	// **Prerequisites:**
	// * The [Virtual Background feature](https://support.zoom.
	// us/hc/en-us/articles/210707503-Virtual-Background#h_2ef28080-fce9-4ac2-b567-dc958afab1b7) must be
	// enabled on the account.
	// **Scopes:** `group:write:admin`
	// **Granular Scopes:** `group:write:virtual_background_files:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// POST /groups/{groupId}/settings/virtual_backgrounds
	UploadGroupVB(ctx context.Context, request OptUploadGroupVBReq, params UploadGroupVBParams) (*UploadGroupVBCreated, error)
	// UploadVBuser invokes uploadVBuser operation.
	//
	// Use this API to [upload a Virtual Background files](https://support.zoom.
	// us/hc/en-us/articles/210707503-Virtual-Background) to a user's profile. For user-level apps, pass
	// [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead
	// of the `userId` parameter.
	// **Note:**
	// * A user profile cannot exceed more than 10 Virtual Background files.
	// * You can only upload image files that are in JPG/JPEG, GIF or PNG format.
	// * Video files must be in MP4 or MOV file format with a minimum resolution of 480 by 360 pixels
	// (360p) and a maximum resolution of 1920 by 1080 pixels (1080p).
	// * The Virtual Background file size cannot exceed 15 megabytes (MB).
	// **Prerequisites:**
	// * The [Virtual Background feature](https://support.zoom.
	// us/hc/en-us/articles/210707503-Virtual-Background#h_2ef28080-fce9-4ac2-b567-dc958afab1b7) must be
	// enabled on the account.
	// **Scopes:** `user:write:admin`,`user:write`
	// **Granular Scopes:** `user:write:virtual_background_files`,
	// `user:write:virtual_background_files:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// POST /users/{userId}/settings/virtual_backgrounds
	UploadVBuser(ctx context.Context, request OptUploadVBuserReq, params UploadVBuserParams) (*UploadVBuserCreated, error)
	// User invokes user operation.
	//
	// View a user's information on a Zoom account. For user-managed apps, pass [the `me`
	// value](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the
	// `userId` parameter.
	// **Note:** The `user_info:read` scope is only available when you pass the `me` value for the
	// `$userId` value.
	// Users who have not activated their account will have a `pending` status. These users' `created_at`
	// timestamp will also display the time at which the API call was made, **not** the account's
	// creation date.
	// **Scopes:** `user:read`,`user:write`,`user:read:admin`,`user:write:admin`,`user_profile`,
	// `user_info:read`
	// **Granular Scopes:** `user:read:user`,`user:read:user:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// GET /users/{userId}
	User(ctx context.Context, params UserParams) (*UserOK, error)
	// UserAssistantCreate invokes userAssistantCreate operation.
	//
	// Assign assistants to a user. In the request body, provide either the user's ID or the user's email
	// address. For user-level apps, pass [the `me` value](https://developers.zoom.
	// us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the `userId` parameter.
	// Assistants are the users to whom the current user has assigned [scheduling
	// privilege](https://support.zoom.us/hc/en-us/articles/201362803-Scheduling-Privilege). Assistants
	// can schedule meetings on behalf of the current user, and can also manage and act as an alternative
	// host for all meetings if the admin has enabled the [co-host option](https://zoom.
	// us/account/setting) on the account.
	// **Prerequisites:**
	// * The user as well as the assistant must have Licensed or an On-prem license.
	// * Assistants must be under the current user's account, or the assistants' account must be in the
	// same organization as the current user's account.
	// **Scopes:** `user:write:admin`,`user:write`
	// **Granular Scopes:** `user:write:assistant`,`user:write:assistant:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// POST /users/{userId}/assistants
	UserAssistantCreate(ctx context.Context, request OptUserAssistantCreateReq, params UserAssistantCreateParams) (*UserAssistantCreateCreated, error)
	// UserAssistantDelete invokes userAssistantDelete operation.
	//
	// Delete a specific assistant of a user. For user-level apps, pass [the `me`
	// value](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the
	// `userId` parameter.
	// Assistants are the users who the current user has assigned [scheduling privilege](https://support.
	// zoom.us/hc/en-us/articles/201362803-Scheduling-Privilege). These assistants can schedule meeting
	// on behalf of the current user as well as manage and act as an alternative host for all meetings if
	// the admin has enabled [co-host option](https://zoom.us/account/setting) on the account.
	// **Prerequisites:**
	// * The user as well as the assistant must have Licensed or an On-prem license.
	// * Assistants must be under the current user's account.
	// **Scopes:** `user:write:admin`,`user:write`
	// **Granular Scopes:** `user:delete:assistant`,`user:delete:assistant:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /users/{userId}/assistants/{assistantId}
	UserAssistantDelete(ctx context.Context, params UserAssistantDeleteParams) error
	// UserAssistants invokes userAssistants operation.
	//
	// List a user's assistants. For user-level apps, pass [the `me` value](https://developers.zoom.
	// us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the `userId` parameter.
	// Assistants are users who the current user has assigned [scheduling privilege](https://support.zoom.
	// us/hc/en-us/articles/201362803-Scheduling-Privilege). These assistants can schedule meetings on
	// behalf of the current user, as well as manage and act as an alternative host for all meetings if
	// the admin has enabled the [co-host option](https://zoom.us/account/setting) on the account.
	// **Prerequisites:**
	// * Current user as well as the assistant must have Licensed or an On-prem license.
	// * Assistants must be under the current user's account.
	// **Scopes:** `user:read`,`user:write`,`user:read:admin`,`user:write:admin`,`user_profile`
	// **Granular Scopes:** `user:read:list_assistants`,`user:read:list_assistants:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /users/{userId}/assistants
	UserAssistants(ctx context.Context, params UserAssistantsParams) (*UserAssistantsOK, error)
	// UserAssistantsDelete invokes userAssistantsDelete operation.
	//
	// Delete all of the current user's assistants. For user-level apps, pass [the `me`
	// value](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the
	// `userId` parameter.
	// Assistants are the users who the current user has assigned [scheduling privilege](https://support.
	// zoom.us/hc/en-us/articles/201362803-Scheduling-Privilege). These assistants can schedule meeting
	// on behalf of the current user, and manage and act as an alternative host for all meetings if the
	// admin has enabled [co-host option](https://zoom.us/account/setting) on the account.
	// **Prerequisites:**
	// * The user as well as the assistant must have Licensed or an On-prem license.
	// * Assistants must be under the current user's account.
	// **Scopes:** `user:write:admin`,`user:write`
	// **Granular Scopes:** `user:delete:assistant`,`user:delete:assistant:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /users/{userId}/assistants
	UserAssistantsDelete(ctx context.Context, params UserAssistantsDeleteParams) error
	// UserCreate invokes userCreate operation.
	//
	// Add a new user to your Zoom account.
	// **Note** These rate limits apply when you use the `create` value for the `action` field:
	// * 50 requests per day for **Free** accounts.
	// * 1,500 requests per day for **Pro** accounts.
	// * 10,000 requests per day for **Business+** accounts.
	// **Prerequisites:**
	// * A Pro or higher plan.
	// **Scopes:** `user:write`,`user:write:admin`
	// **Granular Scopes:** `user:write:user:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// POST /users
	UserCreate(ctx context.Context, request OptUserCreateReq) (*UserCreateCreated, error)
	// UserDelete invokes userDelete operation.
	//
	// **Disassociate** (unlink) a user or permanently **delete** a user.
	// **Disassociating** a user unlinks the user from the associated Zoom account and provides the user
	// their own basic free Zoom account. The disassociated user can then purchase their own Zoom
	// licenses. An account owner or account admin can transfer the user's meetings, webinars, and cloud
	// recordings to another user before disassociation.
	// **Deleting** a user permanently removes the user and their data from Zoom. Users can create a new
	// Zoom account using the same email address. An account owner or an account admin can transfer
	// meetings, webinars, and cloud recordings to another Zoom user account before deleting.
	// For user-level apps, pass [the `me` value](https://developers.zoom.
	// us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the `userId` parameter.
	// **Note:** This API does not support the deletion requirements of a [Data Subject Access Request
	// (DSAR)](https://dataprivacymanager.net/what-is-data-subject-access-request-dsar/). For a DSAR
	// request, contact Zoom Support.
	// **Scopes:** `user:write:admin`,`user:write`
	// **Granular Scopes:** `user:delete:user`,`user:delete:user:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// DELETE /users/{userId}
	UserDelete(ctx context.Context, params UserDeleteParams) error
	// UserEmail invokes userEmail operation.
	//
	// Verify if a user's email is registered with Zoom.
	// &lt;b&gt;Note: &lt;/b&gt;You can successfully check if a user is a registered Zoom user only if
	// the user **signed up for Zoom via email and is within your account.** If you provide an email
	// address of a user who is not in your account, the value of &quot;existed_email&quot; parameter
	// will be &quot;false&quot; irrespective of whether or not the user is registered with Zoom. The
	// response of this API call will not include users who joined Zoom using options such as &quot;Sign
	// in with SSO&quot;, &quot;Sign in with Google&quot; or &quot;Sign in with Facebook&quot; even if
	// they are in the same account as yours.
	// **Scopes:** `user:read`,`user:write`,`user:read:admin`,`user:write:admin`
	// **Granular Scopes:** `user:read:email`,`user:read:email:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /users/email
	UserEmail(ctx context.Context, params UserEmailParams) (*UserEmailOK, error)
	// UserEmailUpdate invokes userEmailUpdate operation.
	//
	// Change a user's [email address](https://support.zoom.
	// us/hc/en-us/articles/201362563-How-Do-I-Change-the-Email-on-My-Account-) on a Zoom account that
	// has managed domain set up. For user-level apps, pass [the `me` value](https://developers.zoom.
	// us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the `userId` parameter.
	// * If the Zoom account in which the user belongs has multiple [managed domains](https://support.
	// zoom.us/hc/en-us/articles/203395207-What-is-Managed-Domain-), then the email to be updated
	// **must** match one of the managed domains.
	// * A user's email address can be changed up to 3 times in any 24 hour period.
	// **Prerequisites:**
	// * Managed domain must be enabled in the account.
	// * The new email address should not already exist in Zoom.
	// **Scopes:** `user:write:admin`,`user:write`
	// **Granular Scopes:** `user:update:email`,`user:update:email:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// PUT /users/{userId}/email
	UserEmailUpdate(ctx context.Context, request OptUserEmailUpdateReq, params UserEmailUpdateParams) error
	// UserPassword invokes userPassword operation.
	//
	// Update the [password](https://support.zoom.
	// us/hc/en-us/articles/206344385-Change-a-User-s-Password) of a user using which the user can login
	// to Zoom. For user-level apps, pass [the `me` value](https://developers.zoom.
	// us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the `userId` parameter.
	// After this request is processed successfully, an email notification is sent to the user saying
	// that the password was changed.
	// **Prerequisites:**
	// * Owner or admin of the Zoom account.
	// **Scopes:** `user:write:admin`,`user:write`
	// **Granular Scopes:** `user:update:password`,`user:update:password:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// PUT /users/{userId}/password
	UserPassword(ctx context.Context, request OptUserPasswordReq, params UserPasswordParams) error
	// UserPermission invokes userPermission operation.
	//
	// Get permissions that have been granted to the user. For user-level apps, pass [the `me`
	// value](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the
	// `userId` parameter.
	// Users can be assigned a set of permissions that allows them to access only the pages or
	// information that a user needs to view or edit.
	// **Scopes:** `user:read`,`user:write`,`user:read:admin`,`user:write:admin`,`user_profile`
	// **Granular Scopes:** `user:read:list_permissions`,`user:read:list_permissions:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// GET /users/{userId}/permissions
	UserPermission(ctx context.Context, params UserPermissionParams) (*UserPermissionOK, error)
	// UserPicture invokes userPicture operation.
	//
	// Upload a user's profile picture. For user-level apps, pass [the `me` value](https://developers.
	// zoom.us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the `userId` parameter.
	// Provide `multipart/form-data` as the value of the `content-type` header for this request. This API
	// supports `.jpeg` and `.png` file formats.
	// **Scopes:** `user:write:admin`,`user:write`
	// **Granular Scopes:** `user:write:profile_picture`,`user:write:profile_picture:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// POST /users/{userId}/picture
	UserPicture(ctx context.Context, request OptUserPictureReq, params UserPictureParams) error
	// UserPictureDelete invokes userPictureDelete operation.
	//
	// Delete a user's profile picture. For user-level apps, pass [the `me` value](https://developers.
	// zoom.us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the `userId` parameter.
	// **Scopes:** `user:write:admin`,`user:write`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// DELETE /users/{userId}/picture
	UserPictureDelete(ctx context.Context, params UserPictureDeleteParams) error
	// UserSSOTokenDelete invokes userSSOTokenDelete operation.
	//
	// Revokes a user's SSO token. For user-level apps, pass [the `me` value](https://developers.zoom.
	// us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the `userId` parameter.
	// After calling this API, the SSO user will be logged out of their current Zoom session.
	// **Scopes:** `user:write:admin`,`user:write`
	// **Granular Scopes:** `user:delete:token`,`user:delete:token:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// DELETE /users/{userId}/token
	UserSSOTokenDelete(ctx context.Context, params UserSSOTokenDeleteParams) error
	// UserSchedulerDelete invokes userSchedulerDelete operation.
	//
	// Delete a scheduler. For user-level apps, pass [the `me` value](https://developers.zoom.
	// us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the `userId` parameter.
	// Schedulers are users who the current user (assistant) can schedule meetings on their behalf. By
	// calling this API, the current user will no longer be a scheduling assistant of this scheduler.
	// **Prerequisites:**
	// * Current user must be under the same account as the scheduler.
	// **Scopes:** `user:write:admin`,`user:write`
	// **Granular Scopes:** `user:delete:scheduler`,`user:delete:scheduler:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /users/{userId}/schedulers/{schedulerId}
	UserSchedulerDelete(ctx context.Context, params UserSchedulerDeleteParams) error
	// UserSchedulers invokes userSchedulers operation.
	//
	// List all of a user's schedulers. For user-level apps, pass [the `me` value](https://developers.
	// zoom.us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the `userId` parameter.
	// Schedulers in this context are users who can schedule meetings for the current user. For example,
	// if the current user, the user whose `userId` was passed in the `path` parameter, is **User A**,
	// this API's response will list all users for whom **User A** can schedule and manage meetings.
	// **User A** is the assistant of these users, and thus has scheduling privilege for these users.
	// **Prerequisites**
	// * Current user must be under the same account as the scheduler.
	// **Scopes:** `user:read`,`user:write`,`user:read:admin`,`user:write:admin`,`user_profile`
	// **Granular Scopes:** `user:read:list_schedulers`,`user:read:list_schedulers:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Medium`.
	//
	// GET /users/{userId}/schedulers
	UserSchedulers(ctx context.Context, params UserSchedulersParams) (*UserSchedulersOK, error)
	// UserSchedulersDelete invokes userSchedulersDelete operation.
	//
	// Delete all of a user's schedulers. For user-level apps, pass [the `me` value](https://developers.
	// zoom.us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the `userId` parameter.
	// Schedulers are users on whose behalf the current user (assistant) can schedule meetings for. By
	// calling this API, the current user will no longer be a scheduling assistant of any user.
	// **Prerequisites:**
	// * Current user (assistant) must be under the same account as the scheduler.
	// **Scopes:** `user:write:admin`,`user:write`
	// **Granular Scopes:** `user:delete:scheduler`,`user:delete:scheduler:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// DELETE /users/{userId}/schedulers
	UserSchedulersDelete(ctx context.Context, params UserSchedulersDeleteParams) error
	// UserSettings invokes userSettings operation.
	//
	// Retrieve a user's settings. For user-level apps, pass [the `me` value](https://developers.zoom.
	// us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the `userId` parameter.
	// **Scopes:** `user:read`,`user:write`,`user:read:admin`,`user:write:admin`
	// **Granular Scopes:** `user:read:settings`,`user:read:settings:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// GET /users/{userId}/settings
	UserSettings(ctx context.Context, params UserSettingsParams) (UserSettingsOK, error)
	// UserSettingsUpdate invokes userSettingsUpdate operation.
	//
	// Updates a user's settings. For user-level apps, pass [the `me` value](https://developers.zoom.
	// us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the `userId` parameter.
	// **Scopes:** `user:write:admin`,`user:write`
	// **Granular Scopes:** `user:update:settings`,`user:update:settings:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// PATCH /users/{userId}/settings
	UserSettingsUpdate(ctx context.Context, request OptUserSettingsUpdateReq, params UserSettingsUpdateParams) error
	// UserStatus invokes userStatus operation.
	//
	// [Deactivate](https://support.zoom.
	// us/hc/en-us/articles/115005269946-Remove-User-from-your-Account#h_6a9bc1c3-d739-4945-b1f2-00b3b88fb5cc) an active user or to [reactivate](https://support.zoom.us/hc/en-us/articles/115005269946-Remove-User-from-your-Account#h_16319724-d120-4be6-af5d-31582d134ea0) a deactivated user. For user-level apps, pass [the `me` value](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the `userId` parameter.
	// An account owner or admins can deactivate as well as activate a user in a Zoom account.
	// Deactivating a user removes all licenses associated with a user, and prevents the deactivated user
	// from logging into their Zoom account. A deactivated user can be reactivated. Reactivating a user
	// grants the user access to log in to their Zoom account.
	// **Scopes:** `user:write:admin`,`user:write`
	// **Granular Scopes:** `user:update:presence_status`,`user:update:presence_status:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// PUT /users/{userId}/status
	UserStatus(ctx context.Context, request OptUserStatusReq, params UserStatusParams) error
	// UserSummary invokes userSummary operation.
	//
	// Gets a summary of users, including the number and types of users in the account.
	// **Scopes:** `user:read`,`user:write`,`user:read:admin`,`user:write:admin`
	// **Granular Scopes:** `user:read:summary:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// GET /users/summary
	UserSummary(ctx context.Context) (*UserSummaryOK, error)
	// UserToken invokes userToken operation.
	//
	// Gets a user's Zoom token or Zoom Access Key (ZAK). For user-level apps, pass [the `me`
	// value](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the
	// `userId` parameter.
	// **Scopes:** `user:read`,`user:write`,`user:read:admin`,`user:write:admin`,`user_profile`
	// **Granular Scopes:** `user:read:token`,`user:read:token:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// GET /users/{userId}/token
	UserToken(ctx context.Context, params UserTokenParams) (*UserTokenOK, error)
	// UserUpdate invokes userUpdate operation.
	//
	// Updates a user's [Zoom profile](https://support.zoom.us/hc/en-us/articles/201363203-My-Profile)
	// information.
	// For user-level apps, pass [the `me` value](hhttps://developers.zoom.
	// us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the `userId` parameter.
	// **Scopes:** `user:write:admin`,`user:write`
	// **Granular Scopes:** `user:update:user`,`user:update:user:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `LIGHT`.
	//
	// PATCH /users/{userId}
	UserUpdate(ctx context.Context, request OptUserUpdateReq, params UserUpdateParams) error
	// UserVanityName invokes userVanityName operation.
	//
	// A personal meeting room is a virtual meeting room that can be permanently assigned to a user.
	// Use this API to check if a personal meeting room with the given name exists or not.
	// **Scopes:** `user:read`,`user:write`,`user:read:admin`,`user:write:admin`
	// **Granular Scopes:** `user:read:pm_room`,`user:read:pm_room:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /users/vanity_name
	UserVanityName(ctx context.Context, params UserVanityNameParams) (*UserVanityNameOK, error)
	// UserZak invokes userZak operation.
	//
	// Get the Zoom Access Key (ZAK) for the authenticated user associated with the access token in the
	// API request. Use a ZAK to start or join a meeting on behalf of this user.
	// ZAKs obtained with this endpoint expire five minutes after receipt.
	// To get a ZAK for a different user or with a different expiration, use the [Get a user
	// token](https://marketplace.zoom.us/docs/api-reference/zoom-api/methods#operation/userToken) API
	// with the `zak` `type` query parameter.
	// See [Getting a Zoom Access Key (ZAK)](https://developers.zoom.
	// us/docs/meeting-sdk/auth/#start-meetings-and-webinars-with-a-zoom-users-zak-token) for details.
	// **Scopes:** `user_zak:read`
	// **Granular Scopes:** `user:read:zak`,`user:read:zak:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `Light`.
	//
	// GET /users/me/zak
	UserZak(ctx context.Context) (*UserZakOK, error)
	// Users invokes users operation.
	//
	// Retrieve a list your account's users.
	// **Scopes:** `user:read`,`user:write`,`user:read:admin`,`user:write:admin`
	// **Granular Scopes:** `user:read:list_users:admin`
	// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
	// `MEDIUM`.
	//
	// GET /users
	Users(ctx context.Context, params UsersParams) (*UsersOK, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// BulkUpdateFeature invokes bulkUpdateFeature operation.
//
// Update multiple features for a user.
// **Limit**: This endpoint can process a maximum of 30 users at a time.
// **Scopes:** `user:write`,`user:write:admin`
// **Granular Scopes:** `user:write:feature:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// POST /users/features
func (c *Client) BulkUpdateFeature(ctx context.Context, request OptBulkUpdateFeatureReq) (*BulkUpdateFeatureCreated, error) {
	res, err := c.sendBulkUpdateFeature(ctx, request)
	return res, err
}

func (c *Client) sendBulkUpdateFeature(ctx context.Context, request OptBulkUpdateFeatureReq) (res *BulkUpdateFeatureCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("bulkUpdateFeature"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/users/features"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "BulkUpdateFeature",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/users/features"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeBulkUpdateFeatureRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "BulkUpdateFeature", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "BulkUpdateFeature", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeBulkUpdateFeatureResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ContactGroup invokes contactGroup operation.
//
// Get a [contact group](https://support.zoom.us/hc/en-us/articles/204519819-Group-Management-) under
// an account.
// **Prerequisite**: Pro or higher account.
// **Scopes:** `contact_group:write:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /contacts/groups/{groupId}
func (c *Client) ContactGroup(ctx context.Context, params ContactGroupParams) (*ContactGroupOK, error) {
	res, err := c.sendContactGroup(ctx, params)
	return res, err
}

func (c *Client) sendContactGroup(ctx context.Context, params ContactGroupParams) (res *ContactGroupOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("contactGroup"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/contacts/groups/{groupId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ContactGroup",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/contacts/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ContactGroup", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ContactGroup", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeContactGroupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ContactGroupCreate invokes contactGroupCreate operation.
//
// Use this API to create a [contact group](https://support.zoom.
// us/hc/en-us/articles/204519819-Group-Management).
// **Prerequisite**: Pro or higher account.
// **Scopes:** `contact_group:write:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Heavy`.
//
// POST /contacts/groups
func (c *Client) ContactGroupCreate(ctx context.Context, request OptContactGroupCreateReq) (*ContactGroupCreateCreated, error) {
	res, err := c.sendContactGroupCreate(ctx, request)
	return res, err
}

func (c *Client) sendContactGroupCreate(ctx context.Context, request OptContactGroupCreateReq) (res *ContactGroupCreateCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("contactGroupCreate"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/contacts/groups"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ContactGroupCreate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/contacts/groups"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeContactGroupCreateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ContactGroupCreate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ContactGroupCreate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeContactGroupCreateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ContactGroupDelete invokes contactGroupDelete operation.
//
// Use this API to delete a [contact group](https://support.zoom.
// us/hc/en-us/articles/204519819-Group-Management-).
// **Prerequisite**: Pro or higher account.
// **Scopes:** `contact_group:write:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Heavy`.
//
// DELETE /contacts/groups/{groupId}
func (c *Client) ContactGroupDelete(ctx context.Context, params ContactGroupDeleteParams) error {
	_, err := c.sendContactGroupDelete(ctx, params)
	return err
}

func (c *Client) sendContactGroupDelete(ctx context.Context, params ContactGroupDeleteParams) (res *ContactGroupDeleteNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("contactGroupDelete"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/contacts/groups/{groupId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ContactGroupDelete",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/contacts/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ContactGroupDelete", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ContactGroupDelete", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeContactGroupDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ContactGroupMemberAdd invokes contactGroupMemberAdd operation.
//
// Use this API to add members to a [contact group](https://support.zoom.
// us/hc/en-us/articles/204519819-Group-Management).
// **Prerequisite**: Pro or higher account.
// **Scopes:** `contact_group:write:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `HEAVY`.
//
// POST /contacts/groups/{groupId}/members
func (c *Client) ContactGroupMemberAdd(ctx context.Context, request OptContactGroupMemberAddReq, params ContactGroupMemberAddParams) (*ContactGroupMemberAddCreated, error) {
	res, err := c.sendContactGroupMemberAdd(ctx, request, params)
	return res, err
}

func (c *Client) sendContactGroupMemberAdd(ctx context.Context, request OptContactGroupMemberAddReq, params ContactGroupMemberAddParams) (res *ContactGroupMemberAddCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("contactGroupMemberAdd"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/contacts/groups/{groupId}/members"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ContactGroupMemberAdd",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/contacts/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeContactGroupMemberAddRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ContactGroupMemberAdd", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ContactGroupMemberAdd", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeContactGroupMemberAddResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ContactGroupMemberRemove invokes contactGroupMemberRemove operation.
//
// Removes members in a [contact group](https://support.zoom.
// us/hc/en-us/articles/204519819-Group-Management-).
// **Prerequisite**: Pro or higher account.
// **Scopes:** `contact_group:write:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `HEAVY`.
//
// DELETE /contacts/groups/{groupId}/members
func (c *Client) ContactGroupMemberRemove(ctx context.Context, params ContactGroupMemberRemoveParams) error {
	_, err := c.sendContactGroupMemberRemove(ctx, params)
	return err
}

func (c *Client) sendContactGroupMemberRemove(ctx context.Context, params ContactGroupMemberRemoveParams) (res *ContactGroupMemberRemoveNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("contactGroupMemberRemove"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/contacts/groups/{groupId}/members"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ContactGroupMemberRemove",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/contacts/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "member_ids" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "member_ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.MemberIds))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ContactGroupMemberRemove", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ContactGroupMemberRemove", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeContactGroupMemberRemoveResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ContactGroupMembers invokes contactGroupMembers operation.
//
// List members in [contact groups](https://support.zoom.
// us/hc/en-us/articles/204519819-Group-Management-) under an account.
// **Prerequisite**: Pro or higher account.
// **Scopes:** `contact_group:read:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// GET /contacts/groups/{groupId}/members
func (c *Client) ContactGroupMembers(ctx context.Context, params ContactGroupMembersParams) (*ContactGroupMembersOK, error) {
	res, err := c.sendContactGroupMembers(ctx, params)
	return res, err
}

func (c *Client) sendContactGroupMembers(ctx context.Context, params ContactGroupMembersParams) (res *ContactGroupMembersOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("contactGroupMembers"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/contacts/groups/{groupId}/members"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ContactGroupMembers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/contacts/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ContactGroupMembers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ContactGroupMembers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeContactGroupMembersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ContactGroupUpdate invokes contactGroupUpdate operation.
//
// Update a [contact group](https://support.zoom.us/hc/en-us/articles/204519819-Group-Management-)
// under your account.
// **Prerequisite**: Pro or higher account.
// **Scopes:** `contact_group:write:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Heavy`.
//
// PATCH /contacts/groups/{groupId}
func (c *Client) ContactGroupUpdate(ctx context.Context, request OptContactGroupUpdateReq, params ContactGroupUpdateParams) error {
	_, err := c.sendContactGroupUpdate(ctx, request, params)
	return err
}

func (c *Client) sendContactGroupUpdate(ctx context.Context, request OptContactGroupUpdateReq, params ContactGroupUpdateParams) (res *ContactGroupUpdateNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("contactGroupUpdate"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/contacts/groups/{groupId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ContactGroupUpdate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/contacts/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeContactGroupUpdateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ContactGroupUpdate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ContactGroupUpdate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeContactGroupUpdateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ContactGroups invokes contactGroups operation.
//
// List [contact groups](https://support.zoom.us/hc/en-us/articles/204519819-Group-Management-) under
// an account.
// **Prerequisite**: Pro or higher account.
// **Scopes:** `contact_group:read:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /contacts/groups
func (c *Client) ContactGroups(ctx context.Context, params ContactGroupsParams) (*ContactGroupsOK, error) {
	res, err := c.sendContactGroups(ctx, params)
	return res, err
}

func (c *Client) sendContactGroups(ctx context.Context, params ContactGroupsParams) (res *ContactGroupsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("contactGroups"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/contacts/groups"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ContactGroups",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/contacts/groups"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ContactGroups", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ContactGroups", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeContactGroupsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DelGroupVB invokes delGroupVB operation.
//
// Use this API to delete a group's [Virtual Background files](https://support.zoom.
// us/hc/en-us/articles/210707503-Virtual-Background#h_01EJF3YFEWGT8YA0ZJ079JEDQE).
// **Prerequisites:**
// * The [Virtual Background feature](https://support.zoom.
// us/hc/en-us/articles/210707503-Virtual-Background#h_2ef28080-fce9-4ac2-b567-dc958afab1b7) must be
// enabled on the account.
// **Scopes:** `group:write:admin`
// **Granular Scopes:** `group:delete:virtual_background_files:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// DELETE /groups/{groupId}/settings/virtual_backgrounds
func (c *Client) DelGroupVB(ctx context.Context, params DelGroupVBParams) error {
	_, err := c.sendDelGroupVB(ctx, params)
	return err
}

func (c *Client) sendDelGroupVB(ctx context.Context, params DelGroupVBParams) (res *DelGroupVBNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delGroupVB"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/groups/{groupId}/settings/virtual_backgrounds"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DelGroupVB",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/settings/virtual_backgrounds"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "file_ids" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "file_ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FileIds.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DelGroupVB", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DelGroupVB", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDelGroupVBResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DelUserVB invokes delUserVB operation.
//
// Use this API to delete a user's Virtual Background files. For user-level apps, pass [the `me`
// value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the
// `userId` parameter.
// **Prerequisites:**
// * The [Virtual Background feature](https://support.zoom.
// us/hc/en-us/articles/210707503-Virtual-Background#h_2ef28080-fce9-4ac2-b567-dc958afab1b7) must be
// enabled on the account.
// **Scopes:** `user:write:admin`,`user:write`
// **Granular Scopes:** `user:delete:virtual_background_files`,
// `user:delete:virtual_background_files:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// DELETE /users/{userId}/settings/virtual_backgrounds
func (c *Client) DelUserVB(ctx context.Context, params DelUserVBParams) error {
	_, err := c.sendDelUserVB(ctx, params)
	return err
}

func (c *Client) sendDelUserVB(ctx context.Context, params DelUserVBParams) (res *DelUserVBNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delUserVB"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/users/{userId}/settings/virtual_backgrounds"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DelUserVB",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/settings/virtual_backgrounds"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "file_ids" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "file_ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FileIds.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "DelUserVB", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "DelUserVB", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDelUserVBResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCollaborationDevice invokes getCollaborationDevice operation.
//
// Get collaboration device detail. For user-level apps, pass [the `me` value](https://developers.
// zoom.us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the `userId` parameter.
// **Scopes:** `user:read`,`user:write`,`user:read:admin`,`user:write:admin`
// **Granular Scopes:** `user:read:collaboration_device`,`user:read:collaboration_device:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// GET /users/{userId}/collaboration_devices/{collaborationDeviceId}
func (c *Client) GetCollaborationDevice(ctx context.Context, params GetCollaborationDeviceParams) (*GetCollaborationDeviceOK, error) {
	res, err := c.sendGetCollaborationDevice(ctx, params)
	return res, err
}

func (c *Client) sendGetCollaborationDevice(ctx context.Context, params GetCollaborationDeviceParams) (res *GetCollaborationDeviceOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getCollaborationDevice"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{userId}/collaboration_devices/{collaborationDeviceId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetCollaborationDevice",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/collaboration_devices/"
	{
		// Encode "collaborationDeviceId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "collaborationDeviceId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CollaborationDeviceId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetCollaborationDevice", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetCollaborationDevice", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetCollaborationDeviceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetGroupLockSettings invokes getGroupLockSettings operation.
//
// Retrieve a [group's](https://support.zoom.us/hc/en-us/articles/204519819-Group-Management-) locked
// settings.
// If you lock a setting, the group members will not be able to modify it individually.
// **Note:** The `force_pmi_jbh_password` field under meeting settings is to be deprecated on
// September 22, 2019. This field is replaced by another field that will provide the same
// functionality.
// **Prerequisite**: Pro, Business, or Education account
// **Scopes:** `group:read:admin`,`group:write:admin`
// **Granular Scopes:** `group:read:lock_settings:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// GET /groups/{groupId}/lock_settings
func (c *Client) GetGroupLockSettings(ctx context.Context, params GetGroupLockSettingsParams) (GetGroupLockSettingsOK, error) {
	res, err := c.sendGetGroupLockSettings(ctx, params)
	return res, err
}

func (c *Client) sendGetGroupLockSettings(ctx context.Context, params GetGroupLockSettingsParams) (res GetGroupLockSettingsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getGroupLockSettings"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/groups/{groupId}/lock_settings"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetGroupLockSettings",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/lock_settings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "option" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "option",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Option.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetGroupLockSettings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetGroupLockSettings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetGroupLockSettingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetGroupSettings invokes getGroupSettings operation.
//
// Get settings for a [group](https://support.zoom.us/hc/en-us/articles/204519819-Group-Management-).
// **Prerequisite**: Pro, Business, or Education account.
// **Scopes:** `group:read:admin`,`group:write:admin`
// **Granular Scopes:** `group:read:settings:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// GET /groups/{groupId}/settings
func (c *Client) GetGroupSettings(ctx context.Context, params GetGroupSettingsParams) (GetGroupSettingsOK, error) {
	res, err := c.sendGetGroupSettings(ctx, params)
	return res, err
}

func (c *Client) sendGetGroupSettings(ctx context.Context, params GetGroupSettingsParams) (res GetGroupSettingsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getGroupSettings"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/groups/{groupId}/settings"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetGroupSettings",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/settings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "option" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "option",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Option.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "custom_query_fields" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "custom_query_fields",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CustomQueryFields.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetGroupSettings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetGroupSettings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetGroupSettingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUserMeetingTemplates invokes getUserMeetingTemplates operation.
//
// Retrieve a user's [meeting template](https://support.zoom.
// us/hc/en-us/articles/360036559151-Meeting-templates). For user-level apps, pass [the `me`
// value](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the
// `userId` parameter.
// **Scopes:** `user:read:admin`,`user:read`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /users/{userId}/meeting_templates/{meetingTemplateId}
func (c *Client) GetUserMeetingTemplates(ctx context.Context, params GetUserMeetingTemplatesParams) (*GetUserMeetingTemplatesOK, error) {
	res, err := c.sendGetUserMeetingTemplates(ctx, params)
	return res, err
}

func (c *Client) sendGetUserMeetingTemplates(ctx context.Context, params GetUserMeetingTemplatesParams) (res *GetUserMeetingTemplatesOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getUserMeetingTemplates"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{userId}/meeting_templates/{meetingTemplateId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetUserMeetingTemplates",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/meeting_templates/"
	{
		// Encode "meetingTemplateId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "meetingTemplateId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.MeetingTemplateId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetUserMeetingTemplates", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetUserMeetingTemplates", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetUserMeetingTemplatesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUserPresenceStatus invokes getUserPresenceStatus operation.
//
// Returns a user's current status.
// Users in the Zoom desktop client and mobile apps are assigned with a [presence
// status](https://support.zoom.us/hc/en-us/articles/360032554051-Status-Icons). The presence status
// displays the user's  availability.
// The available statuses are:
// * **Away**
// * **Do not disturb**
// * **Available**
// * **In a calendar event**
// * **Presenting**
// * **In a Zoom meeting**
// * **On a call**
// * **Out of Office**
// * **Busy**
// * **Offline**
// If the presence status is **Do not disturb**, `end_time` and `remaining_time` properties are only
// visible if the user being queried is also the current user.
// **Scopes:** `user:read`,`user:read:admin`
// **Granular Scopes:** `user:read:presence_status`,`user:read:presence_status:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// GET /users/{userId}/presence_status
func (c *Client) GetUserPresenceStatus(ctx context.Context, params GetUserPresenceStatusParams) (GetUserPresenceStatusOK, error) {
	res, err := c.sendGetUserPresenceStatus(ctx, params)
	return res, err
}

func (c *Client) sendGetUserPresenceStatus(ctx context.Context, params GetUserPresenceStatusParams) (res GetUserPresenceStatusOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getUserPresenceStatus"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{userId}/presence_status"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetUserPresenceStatus",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/presence_status"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GetUserPresenceStatus", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GetUserPresenceStatus", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetUserPresenceStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// Group invokes group operation.
//
// Get a [group](https://support.zoom.us/hc/en-us/articles/204519819-Group-Management-) under an
// account.
// **Prerequisite**: Pro, Business, or Education account
// **Scopes:** `group:read:admin`,`group:write:admin`
// **Granular Scopes:** `group:read:group:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /groups/{groupId}
func (c *Client) Group(ctx context.Context, params GroupParams) (*GroupOK, error) {
	res, err := c.sendGroup(ctx, params)
	return res, err
}

func (c *Client) sendGroup(ctx context.Context, params GroupParams) (res *GroupOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("group"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/groups/{groupId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "Group",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "Group", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "Group", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGroupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GroupAdmins invokes groupAdmins operation.
//
// Use this API to return a list of [group](https://support.zoom.
// us/hc/en-us/articles/204519819-Group-Management-) administrators under your account.
// **Prerequisites:**
// * A Pro, Business, or Education account
// **Scopes:** `group:read:admin`,`group:write:admin`
// **Granular Scopes:** `group:read:administrator:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /groups/{groupId}/admins
func (c *Client) GroupAdmins(ctx context.Context, params GroupAdminsParams) (*GroupAdminsOK, error) {
	res, err := c.sendGroupAdmins(ctx, params)
	return res, err
}

func (c *Client) sendGroupAdmins(ctx context.Context, params GroupAdminsParams) (res *GroupAdminsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("groupAdmins"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/groups/{groupId}/admins"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GroupAdmins",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/admins"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GroupAdmins", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GroupAdmins", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGroupAdminsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GroupAdminsCreate invokes groupAdminsCreate operation.
//
// Use this API to add administrators to a [group](https://support.zoom.
// us/hc/en-us/articles/204519819-Group-Management-) under your account.
// **Prerequisites:**
// * A Pro, Business, or Education account
// **Scopes:** `group:write:admin`
// **Granular Scopes:** `group:write:administrator:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// POST /groups/{groupId}/admins
func (c *Client) GroupAdminsCreate(ctx context.Context, request OptGroupAdminsCreateReq, params GroupAdminsCreateParams) (GroupAdminsCreateRes, error) {
	res, err := c.sendGroupAdminsCreate(ctx, request, params)
	return res, err
}

func (c *Client) sendGroupAdminsCreate(ctx context.Context, request OptGroupAdminsCreateReq, params GroupAdminsCreateParams) (res GroupAdminsCreateRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("groupAdminsCreate"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/groups/{groupId}/admins"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GroupAdminsCreate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/admins"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGroupAdminsCreateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GroupAdminsCreate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GroupAdminsCreate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGroupAdminsCreateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GroupAdminsDelete invokes groupAdminsDelete operation.
//
// Use this API to remove a [group](https://support.zoom.
// us/hc/en-us/articles/204519819-Group-Management-) administrator in a Zoom account.
// **Prerequisites:**
// * A Pro, Business, or Education account
// **Scopes:** `group:write:admin`
// **Granular Scopes:** `group:delete:administrator:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /groups/{groupId}/admins/{userId}
func (c *Client) GroupAdminsDelete(ctx context.Context, params GroupAdminsDeleteParams) (GroupAdminsDeleteRes, error) {
	res, err := c.sendGroupAdminsDelete(ctx, params)
	return res, err
}

func (c *Client) sendGroupAdminsDelete(ctx context.Context, params GroupAdminsDeleteParams) (res GroupAdminsDeleteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("groupAdminsDelete"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/groups/{groupId}/admins/{userId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GroupAdminsDelete",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/admins/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GroupAdminsDelete", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GroupAdminsDelete", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGroupAdminsDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GroupChannels invokes groupChannels operation.
//
// Returns a list of channels for a [group](https://support.zoom.
// us/hc/en-us/articles/204519819-Group-Management-) under your account.
// **Prerequisite**:
// - Pro, Business, or Education account
// **Scopes:** `group:read:admin`,`group:write:admin`
// **Granular Scopes:** `group:read:list_channels:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// GET /groups/{groupId}/channels
func (c *Client) GroupChannels(ctx context.Context, params GroupChannelsParams) (*GroupChannelsOK, error) {
	res, err := c.sendGroupChannels(ctx, params)
	return res, err
}

func (c *Client) sendGroupChannels(ctx context.Context, params GroupChannelsParams) (res *GroupChannelsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("groupChannels"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/groups/{groupId}/channels"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GroupChannels",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/channels"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GroupChannels", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GroupChannels", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGroupChannelsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GroupCreate invokes groupCreate operation.
//
// Use this API to create a [group](https://support.zoom.
// us/hc/en-us/articles/204519819-Group-Management). You can add a **maximum** of 100 groups in one
// account per day, and a maximum of 5000 groups in one account.
// If you enabled a new group via the user interface, you can also choose whether to display the
// group and set its privacy level.
// **Prerequisites**:
// * A Pro or higher account
// **Scopes:** `group:write:admin`
// **Granular Scopes:** `group:write:group:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// POST /groups
func (c *Client) GroupCreate(ctx context.Context, request OptGroupCreateReq) (GroupCreateRes, error) {
	res, err := c.sendGroupCreate(ctx, request)
	return res, err
}

func (c *Client) sendGroupCreate(ctx context.Context, request OptGroupCreateReq) (res GroupCreateRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("groupCreate"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/groups"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GroupCreate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/groups"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGroupCreateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GroupCreate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GroupCreate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGroupCreateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GroupDelete invokes groupDelete operation.
//
// Delete an entire [group](https://support.zoom.us/hc/en-us/articles/204519819-Group-Management-).
// **Prerequisites:** * A Pro, Business, or Education account.
// **Scopes:** `group:write:admin`
// **Granular Scopes:** `group:delete:group:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// DELETE /groups/{groupId}
func (c *Client) GroupDelete(ctx context.Context, params GroupDeleteParams) error {
	_, err := c.sendGroupDelete(ctx, params)
	return err
}

func (c *Client) sendGroupDelete(ctx context.Context, params GroupDeleteParams) (res *GroupDeleteNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("groupDelete"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/groups/{groupId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GroupDelete",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GroupDelete", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GroupDelete", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGroupDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GroupLockedSettings invokes groupLockedSettings operation.
//
// Update a [group's](https://support.zoom.us/hc/en-us/articles/204519819-Group-Management-) locked
// settings. If you lock a setting, the group members cannot modify it individually.
// **Note:** The `force_pmi_jbh_password` field under meeting settings is deprecated as of September
// 22, 2019. This field will be replaced by another field that will provide the same functionality.
// &lt;/p&gt;
// **Prerequisite**: Pro, Business, or Education account
// **Scopes:** `group:write:admin`
// **Granular Scopes:** `group:update:lock_settings:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// PATCH /groups/{groupId}/lock_settings
func (c *Client) GroupLockedSettings(ctx context.Context, request OptGroupLockedSettingsReq, params GroupLockedSettingsParams) error {
	_, err := c.sendGroupLockedSettings(ctx, request, params)
	return err
}

func (c *Client) sendGroupLockedSettings(ctx context.Context, request OptGroupLockedSettingsReq, params GroupLockedSettingsParams) (res *GroupLockedSettingsNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("groupLockedSettings"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/groups/{groupId}/lock_settings"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GroupLockedSettings",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/lock_settings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "option" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "option",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Option.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGroupLockedSettingsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GroupLockedSettings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GroupLockedSettings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGroupLockedSettingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GroupMembers invokes groupMembers operation.
//
// List the members of a [group](https://support.zoom.
// us/hc/en-us/articles/204519819-Group-Management-) under your account.
// **Prerequisite**: Pro, Business, or Education account
// **Scopes:** `group:read:admin`,`group:write:admin`
// **Granular Scopes:** `group:read:list_members:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /groups/{groupId}/members
func (c *Client) GroupMembers(ctx context.Context, params GroupMembersParams) (*GroupMembersOK, error) {
	res, err := c.sendGroupMembers(ctx, params)
	return res, err
}

func (c *Client) sendGroupMembers(ctx context.Context, params GroupMembersParams) (res *GroupMembersOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("groupMembers"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/groups/{groupId}/members"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GroupMembers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_number" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_number",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GroupMembers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GroupMembers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGroupMembersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GroupMembersCreate invokes groupMembersCreate operation.
//
// Use this API to add users to a [group](https://support.zoom.
// us/hc/en-us/articles/204519819-Group-Management-) in your account.
// **Prerequisites:**
// * A Pro, Business, or Education account
// **Scopes:** `group:write:admin`
// **Granular Scopes:** `group:write:member:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// POST /groups/{groupId}/members
func (c *Client) GroupMembersCreate(ctx context.Context, request OptGroupMembersCreateReq, params GroupMembersCreateParams) (GroupMembersCreateRes, error) {
	res, err := c.sendGroupMembersCreate(ctx, request, params)
	return res, err
}

func (c *Client) sendGroupMembersCreate(ctx context.Context, request OptGroupMembersCreateReq, params GroupMembersCreateParams) (res GroupMembersCreateRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("groupMembersCreate"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/groups/{groupId}/members"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GroupMembersCreate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGroupMembersCreateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GroupMembersCreate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GroupMembersCreate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGroupMembersCreateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GroupMembersDelete invokes groupMembersDelete operation.
//
// Use this API to remove a user from a [group](https://support.zoom.
// us/hc/en-us/articles/204519819-Group-Management-) in an account.
// **Prerequisites:**
// * A Pro, Business, or Education account
// **Scopes:** `group:write:admin`
// **Granular Scopes:** `group:delete:member:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /groups/{groupId}/members/{memberId}
func (c *Client) GroupMembersDelete(ctx context.Context, params GroupMembersDeleteParams) (GroupMembersDeleteRes, error) {
	res, err := c.sendGroupMembersDelete(ctx, params)
	return res, err
}

func (c *Client) sendGroupMembersDelete(ctx context.Context, params GroupMembersDeleteParams) (res GroupMembersDeleteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("groupMembersDelete"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/groups/{groupId}/members/{memberId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GroupMembersDelete",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members/"
	{
		// Encode "memberId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "memberId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.MemberId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GroupMembersDelete", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GroupMembersDelete", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGroupMembersDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GroupSettingsRegistration invokes groupSettingsRegistration operation.
//
// Get webinar registration settings for a [group](https://support.zoom.
// us/hc/en-us/articles/204519819-Group-Management-).
// **Prerequisite**: Pro, Business, or Education account
// **Scopes:** `group:read:admin`,`group:write:admin`
// **Granular Scopes:** `group:read:registration_settings:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /groups/{groupId}/settings/registration
func (c *Client) GroupSettingsRegistration(ctx context.Context, params GroupSettingsRegistrationParams) (*GroupSettingsRegistrationOK, error) {
	res, err := c.sendGroupSettingsRegistration(ctx, params)
	return res, err
}

func (c *Client) sendGroupSettingsRegistration(ctx context.Context, params GroupSettingsRegistrationParams) (res *GroupSettingsRegistrationOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("groupSettingsRegistration"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/groups/{groupId}/settings/registration"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GroupSettingsRegistration",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/settings/registration"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GroupSettingsRegistration", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GroupSettingsRegistration", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGroupSettingsRegistrationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GroupSettingsRegistrationUpdate invokes groupSettingsRegistrationUpdate operation.
//
// Update webinar registration settings for a [group](https://support.zoom.
// us/hc/en-us/articles/204519819-Group-Management-).&lt;p style=&quot;background-color:#FEEFB3;
// color:#9F6000&quot;&gt;
// Note:&lt;/b&gt; The `force_pmi_jbh_password` field under meeting settings is planned to be
// deprecated on September 22, 2019. This field will be replaced by another field that will provide
// the same functionality.&lt;/p&gt;
// **Prerequisite**: Pro, Business, or Education account
// **Scopes:** `group:write:admin`
// **Granular Scopes:** `group:update:registration_settings:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// PATCH /groups/{groupId}/settings/registration
func (c *Client) GroupSettingsRegistrationUpdate(ctx context.Context, request OptGroupSettingsRegistrationUpdateReq, params GroupSettingsRegistrationUpdateParams) (GroupSettingsRegistrationUpdateRes, error) {
	res, err := c.sendGroupSettingsRegistrationUpdate(ctx, request, params)
	return res, err
}

func (c *Client) sendGroupSettingsRegistrationUpdate(ctx context.Context, request OptGroupSettingsRegistrationUpdateReq, params GroupSettingsRegistrationUpdateParams) (res GroupSettingsRegistrationUpdateRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("groupSettingsRegistrationUpdate"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/groups/{groupId}/settings/registration"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GroupSettingsRegistrationUpdate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/settings/registration"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGroupSettingsRegistrationUpdateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GroupSettingsRegistrationUpdate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GroupSettingsRegistrationUpdate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGroupSettingsRegistrationUpdateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GroupUpdate invokes groupUpdate operation.
//
// Update a [group](https://support.zoom.us/hc/en-us/articles/204519819-Group-Management-) under your
// account.
// **Prerequisite**: Pro, Business, or Education account
// **Scopes:** `group:write:admin`
// **Granular Scopes:** `group:update:group:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// PATCH /groups/{groupId}
func (c *Client) GroupUpdate(ctx context.Context, request OptGroupUpdateReq, params GroupUpdateParams) (GroupUpdateRes, error) {
	res, err := c.sendGroupUpdate(ctx, request, params)
	return res, err
}

func (c *Client) sendGroupUpdate(ctx context.Context, request OptGroupUpdateReq, params GroupUpdateParams) (res GroupUpdateRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("groupUpdate"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/groups/{groupId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GroupUpdate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGroupUpdateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "GroupUpdate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "GroupUpdate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGroupUpdateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// Groups invokes groups operation.
//
// List [groups](https://support.zoom.us/hc/en-us/articles/204519819-Group-Management-) under an
// account.
// **Prerequisite**: Pro or higher account.
// **Scopes:** `group:read:admin`,`group:write:admin`
// **Granular Scopes:** `group:read:list_groups:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /groups
func (c *Client) Groups(ctx context.Context) (*GroupsOK, error) {
	res, err := c.sendGroups(ctx)
	return res, err
}

func (c *Client) sendGroups(ctx context.Context) (res *GroupsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("groups"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/groups"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "Groups",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/groups"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "Groups", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "Groups", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGroupsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListCollaborationDevices invokes listCollaborationDevices operation.
//
// List a user's collaboration devices. For user-level apps, pass [the `me` value](https://developers.
// zoom.us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the `userId` parameter.
// **Scopes:** `user:read`,`user:write`,`user:read:admin`,`user:write:admin`
// **Granular Scopes:** `user:read:list_collaboration_devices`,
// `user:read:list_collaboration_devices:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// GET /users/{userId}/collaboration_devices
func (c *Client) ListCollaborationDevices(ctx context.Context, params ListCollaborationDevicesParams) (*ListCollaborationDevicesOK, error) {
	res, err := c.sendListCollaborationDevices(ctx, params)
	return res, err
}

func (c *Client) sendListCollaborationDevices(ctx context.Context, params ListCollaborationDevicesParams) (res *ListCollaborationDevicesOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCollaborationDevices"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{userId}/collaboration_devices"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListCollaborationDevices",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/collaboration_devices"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "ListCollaborationDevices", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "ListCollaborationDevices", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListCollaborationDevicesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateAGroupMember invokes updateAGroupMember operation.
//
// Use this API to perform either of the following tasks:
// * Remove a group member from one group and move them to a different group.
// * Set a user's primary group. By default, the primary group is the first group that user is added
// to.
// If a user is a member of multiple groups, you can [assign the user a primary
// group](https://support.zoom.
// us/hc/en-us/articles/204519819-Group-Management-#h_d07c7dcd-4fd8-485a-b5fe-a322e8d21c09). The user
// will use the primary group's settings by default. However, if the user is a member of a group with
// locked settings, those group settings will remain locked to the user.
// **Prerequisites:**
// * A Pro or higher account
// **Scopes:** `group:write:admin`
// **Granular Scopes:** `group:update:member:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// PATCH /groups/{groupId}/members/{memberId}
func (c *Client) UpdateAGroupMember(ctx context.Context, request OptUpdateAGroupMemberReq, params UpdateAGroupMemberParams) error {
	_, err := c.sendUpdateAGroupMember(ctx, request, params)
	return err
}

func (c *Client) sendUpdateAGroupMember(ctx context.Context, request OptUpdateAGroupMemberReq, params UpdateAGroupMemberParams) (res *UpdateAGroupMemberNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateAGroupMember"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/groups/{groupId}/members/{memberId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateAGroupMember",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members/"
	{
		// Encode "memberId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "memberId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.MemberId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateAGroupMemberRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateAGroupMember", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateAGroupMember", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateAGroupMemberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateGroupSettings invokes updateGroupSettings operation.
//
// Update settings for a [group](https://support.zoom.
// us/hc/en-us/articles/204519819-Group-Management-).
// **Note:**The `force_pmi_jbh_password` field under meeting settings is planned to be deprecated on
// September 22, 2019. This field will be replaced by another field that will provide the same
// functionality
// **Prerequisite**: Pro, Business, or Education account
// **Scopes:** `group:write:admin`
// **Granular Scopes:** `group:update:settings:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// PATCH /groups/{groupId}/settings
func (c *Client) UpdateGroupSettings(ctx context.Context, request OptUpdateGroupSettingsReq, params UpdateGroupSettingsParams) error {
	_, err := c.sendUpdateGroupSettings(ctx, request, params)
	return err
}

func (c *Client) sendUpdateGroupSettings(ctx context.Context, request OptUpdateGroupSettingsReq, params UpdateGroupSettingsParams) (res *UpdateGroupSettingsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateGroupSettings"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/groups/{groupId}/settings"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateGroupSettings",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/settings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "option" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "option",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Option.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateGroupSettingsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdateGroupSettings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdateGroupSettings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateGroupSettingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdatePresenceStatus invokes updatePresenceStatus operation.
//
// Update a user's presence status. For user-level apps, pass [the `me` value](https://developers.
// zoom.us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the `userId` parameter.
// A user's status **cannot** be updated more than once per minute. For example, you can only submit
// a maximum of one update request per minute for a single user.
// Users in the Zoom desktop client and mobile apps are assigned with a [presence
// status](https://support.zoom.us/hc/en-us/articles/360032554051-Status-Icons). The presence status
// informs users of their contact's availability. Users can also change their own presence status to
// one the following:
// * **Away**
// * **Do not disturb**
// * **Available**
// * **In a calendar event**
// * **Presenting**
// * **In a Zoom meeting**
// * **On a call**
// * **Out of Office**
// * **Busy**
// Note that a user's presence status **cannot** be updated via this API if the user is not logged in
// to the Zoom client.
// **Scopes:** `user:write`,`user:write:admin`
// **Granular Scopes:** `user:update:presence_status`,`user:update:presence_status:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// PUT /users/{userId}/presence_status
func (c *Client) UpdatePresenceStatus(ctx context.Context, request OptUpdatePresenceStatusReq, params UpdatePresenceStatusParams) error {
	_, err := c.sendUpdatePresenceStatus(ctx, request, params)
	return err
}

func (c *Client) sendUpdatePresenceStatus(ctx context.Context, request OptUpdatePresenceStatusReq, params UpdatePresenceStatusParams) (res *UpdatePresenceStatusNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updatePresenceStatus"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/users/{userId}/presence_status"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdatePresenceStatus",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/presence_status"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdatePresenceStatusRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UpdatePresenceStatus", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UpdatePresenceStatus", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdatePresenceStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UploadGroupVB invokes uploadGroupVB operation.
//
// Use this API to [upload Virtual Background files](https://support.zoom.
// us/hc/en-us/articles/210707503-Virtual-Background#h_01EJF3YFEWGT8YA0ZJ079JEDQE) for all users in a
// group to use.
// **Prerequisites:**
// * The [Virtual Background feature](https://support.zoom.
// us/hc/en-us/articles/210707503-Virtual-Background#h_2ef28080-fce9-4ac2-b567-dc958afab1b7) must be
// enabled on the account.
// **Scopes:** `group:write:admin`
// **Granular Scopes:** `group:write:virtual_background_files:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// POST /groups/{groupId}/settings/virtual_backgrounds
func (c *Client) UploadGroupVB(ctx context.Context, request OptUploadGroupVBReq, params UploadGroupVBParams) (*UploadGroupVBCreated, error) {
	res, err := c.sendUploadGroupVB(ctx, request, params)
	return res, err
}

func (c *Client) sendUploadGroupVB(ctx context.Context, request OptUploadGroupVBReq, params UploadGroupVBParams) (res *UploadGroupVBCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("uploadGroupVB"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/groups/{groupId}/settings/virtual_backgrounds"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UploadGroupVB",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/settings/virtual_backgrounds"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUploadGroupVBRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UploadGroupVB", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UploadGroupVB", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUploadGroupVBResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UploadVBuser invokes uploadVBuser operation.
//
// Use this API to [upload a Virtual Background files](https://support.zoom.
// us/hc/en-us/articles/210707503-Virtual-Background) to a user's profile. For user-level apps, pass
// [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead
// of the `userId` parameter.
// **Note:**
// * A user profile cannot exceed more than 10 Virtual Background files.
// * You can only upload image files that are in JPG/JPEG, GIF or PNG format.
// * Video files must be in MP4 or MOV file format with a minimum resolution of 480 by 360 pixels
// (360p) and a maximum resolution of 1920 by 1080 pixels (1080p).
// * The Virtual Background file size cannot exceed 15 megabytes (MB).
// **Prerequisites:**
// * The [Virtual Background feature](https://support.zoom.
// us/hc/en-us/articles/210707503-Virtual-Background#h_2ef28080-fce9-4ac2-b567-dc958afab1b7) must be
// enabled on the account.
// **Scopes:** `user:write:admin`,`user:write`
// **Granular Scopes:** `user:write:virtual_background_files`,
// `user:write:virtual_background_files:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// POST /users/{userId}/settings/virtual_backgrounds
func (c *Client) UploadVBuser(ctx context.Context, request OptUploadVBuserReq, params UploadVBuserParams) (*UploadVBuserCreated, error) {
	res, err := c.sendUploadVBuser(ctx, request, params)
	return res, err
}

func (c *Client) sendUploadVBuser(ctx context.Context, request OptUploadVBuserReq, params UploadVBuserParams) (res *UploadVBuserCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("uploadVBuser"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/users/{userId}/settings/virtual_backgrounds"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UploadVBuser",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/settings/virtual_backgrounds"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUploadVBuserRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UploadVBuser", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UploadVBuser", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUploadVBuserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// User invokes user operation.
//
// View a user's information on a Zoom account. For user-managed apps, pass [the `me`
// value](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the
// `userId` parameter.
// **Note:** The `user_info:read` scope is only available when you pass the `me` value for the
// `$userId` value.
// Users who have not activated their account will have a `pending` status. These users' `created_at`
// timestamp will also display the time at which the API call was made, **not** the account's
// creation date.
// **Scopes:** `user:read`,`user:write`,`user:read:admin`,`user:write:admin`,`user_profile`,
// `user_info:read`
// **Granular Scopes:** `user:read:user`,`user:read:user:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// GET /users/{userId}
func (c *Client) User(ctx context.Context, params UserParams) (*UserOK, error) {
	res, err := c.sendUser(ctx, params)
	return res, err
}

func (c *Client) sendUser(ctx context.Context, params UserParams) (res *UserOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{userId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "User",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "login_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "login_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.LoginType.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "encrypted_email" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "encrypted_email",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EncryptedEmail.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "search_by_unique_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "search_by_unique_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SearchByUniqueID.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "User", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "User", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UserAssistantCreate invokes userAssistantCreate operation.
//
// Assign assistants to a user. In the request body, provide either the user's ID or the user's email
// address. For user-level apps, pass [the `me` value](https://developers.zoom.
// us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the `userId` parameter.
// Assistants are the users to whom the current user has assigned [scheduling
// privilege](https://support.zoom.us/hc/en-us/articles/201362803-Scheduling-Privilege). Assistants
// can schedule meetings on behalf of the current user, and can also manage and act as an alternative
// host for all meetings if the admin has enabled the [co-host option](https://zoom.
// us/account/setting) on the account.
// **Prerequisites:**
// * The user as well as the assistant must have Licensed or an On-prem license.
// * Assistants must be under the current user's account, or the assistants' account must be in the
// same organization as the current user's account.
// **Scopes:** `user:write:admin`,`user:write`
// **Granular Scopes:** `user:write:assistant`,`user:write:assistant:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// POST /users/{userId}/assistants
func (c *Client) UserAssistantCreate(ctx context.Context, request OptUserAssistantCreateReq, params UserAssistantCreateParams) (*UserAssistantCreateCreated, error) {
	res, err := c.sendUserAssistantCreate(ctx, request, params)
	return res, err
}

func (c *Client) sendUserAssistantCreate(ctx context.Context, request OptUserAssistantCreateReq, params UserAssistantCreateParams) (res *UserAssistantCreateCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("userAssistantCreate"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/users/{userId}/assistants"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UserAssistantCreate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/assistants"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUserAssistantCreateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UserAssistantCreate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UserAssistantCreate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUserAssistantCreateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UserAssistantDelete invokes userAssistantDelete operation.
//
// Delete a specific assistant of a user. For user-level apps, pass [the `me`
// value](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the
// `userId` parameter.
// Assistants are the users who the current user has assigned [scheduling privilege](https://support.
// zoom.us/hc/en-us/articles/201362803-Scheduling-Privilege). These assistants can schedule meeting
// on behalf of the current user as well as manage and act as an alternative host for all meetings if
// the admin has enabled [co-host option](https://zoom.us/account/setting) on the account.
// **Prerequisites:**
// * The user as well as the assistant must have Licensed or an On-prem license.
// * Assistants must be under the current user's account.
// **Scopes:** `user:write:admin`,`user:write`
// **Granular Scopes:** `user:delete:assistant`,`user:delete:assistant:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /users/{userId}/assistants/{assistantId}
func (c *Client) UserAssistantDelete(ctx context.Context, params UserAssistantDeleteParams) error {
	_, err := c.sendUserAssistantDelete(ctx, params)
	return err
}

func (c *Client) sendUserAssistantDelete(ctx context.Context, params UserAssistantDeleteParams) (res *UserAssistantDeleteNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("userAssistantDelete"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/users/{userId}/assistants/{assistantId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UserAssistantDelete",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/assistants/"
	{
		// Encode "assistantId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "assistantId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AssistantId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UserAssistantDelete", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UserAssistantDelete", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUserAssistantDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UserAssistants invokes userAssistants operation.
//
// List a user's assistants. For user-level apps, pass [the `me` value](https://developers.zoom.
// us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the `userId` parameter.
// Assistants are users who the current user has assigned [scheduling privilege](https://support.zoom.
// us/hc/en-us/articles/201362803-Scheduling-Privilege). These assistants can schedule meetings on
// behalf of the current user, as well as manage and act as an alternative host for all meetings if
// the admin has enabled the [co-host option](https://zoom.us/account/setting) on the account.
// **Prerequisites:**
// * Current user as well as the assistant must have Licensed or an On-prem license.
// * Assistants must be under the current user's account.
// **Scopes:** `user:read`,`user:write`,`user:read:admin`,`user:write:admin`,`user_profile`
// **Granular Scopes:** `user:read:list_assistants`,`user:read:list_assistants:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /users/{userId}/assistants
func (c *Client) UserAssistants(ctx context.Context, params UserAssistantsParams) (*UserAssistantsOK, error) {
	res, err := c.sendUserAssistants(ctx, params)
	return res, err
}

func (c *Client) sendUserAssistants(ctx context.Context, params UserAssistantsParams) (res *UserAssistantsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("userAssistants"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{userId}/assistants"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UserAssistants",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/assistants"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UserAssistants", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UserAssistants", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUserAssistantsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UserAssistantsDelete invokes userAssistantsDelete operation.
//
// Delete all of the current user's assistants. For user-level apps, pass [the `me`
// value](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the
// `userId` parameter.
// Assistants are the users who the current user has assigned [scheduling privilege](https://support.
// zoom.us/hc/en-us/articles/201362803-Scheduling-Privilege). These assistants can schedule meeting
// on behalf of the current user, and manage and act as an alternative host for all meetings if the
// admin has enabled [co-host option](https://zoom.us/account/setting) on the account.
// **Prerequisites:**
// * The user as well as the assistant must have Licensed or an On-prem license.
// * Assistants must be under the current user's account.
// **Scopes:** `user:write:admin`,`user:write`
// **Granular Scopes:** `user:delete:assistant`,`user:delete:assistant:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /users/{userId}/assistants
func (c *Client) UserAssistantsDelete(ctx context.Context, params UserAssistantsDeleteParams) error {
	_, err := c.sendUserAssistantsDelete(ctx, params)
	return err
}

func (c *Client) sendUserAssistantsDelete(ctx context.Context, params UserAssistantsDeleteParams) (res *UserAssistantsDeleteNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("userAssistantsDelete"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/users/{userId}/assistants"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UserAssistantsDelete",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/assistants"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UserAssistantsDelete", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UserAssistantsDelete", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUserAssistantsDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UserCreate invokes userCreate operation.
//
// Add a new user to your Zoom account.
// **Note** These rate limits apply when you use the `create` value for the `action` field:
// * 50 requests per day for **Free** accounts.
// * 1,500 requests per day for **Pro** accounts.
// * 10,000 requests per day for **Business+** accounts.
// **Prerequisites:**
// * A Pro or higher plan.
// **Scopes:** `user:write`,`user:write:admin`
// **Granular Scopes:** `user:write:user:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// POST /users
func (c *Client) UserCreate(ctx context.Context, request OptUserCreateReq) (*UserCreateCreated, error) {
	res, err := c.sendUserCreate(ctx, request)
	return res, err
}

func (c *Client) sendUserCreate(ctx context.Context, request OptUserCreateReq) (res *UserCreateCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("userCreate"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/users"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UserCreate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/users"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUserCreateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UserCreate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UserCreate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUserCreateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UserDelete invokes userDelete operation.
//
// **Disassociate** (unlink) a user or permanently **delete** a user.
// **Disassociating** a user unlinks the user from the associated Zoom account and provides the user
// their own basic free Zoom account. The disassociated user can then purchase their own Zoom
// licenses. An account owner or account admin can transfer the user's meetings, webinars, and cloud
// recordings to another user before disassociation.
// **Deleting** a user permanently removes the user and their data from Zoom. Users can create a new
// Zoom account using the same email address. An account owner or an account admin can transfer
// meetings, webinars, and cloud recordings to another Zoom user account before deleting.
// For user-level apps, pass [the `me` value](https://developers.zoom.
// us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the `userId` parameter.
// **Note:** This API does not support the deletion requirements of a [Data Subject Access Request
// (DSAR)](https://dataprivacymanager.net/what-is-data-subject-access-request-dsar/). For a DSAR
// request, contact Zoom Support.
// **Scopes:** `user:write:admin`,`user:write`
// **Granular Scopes:** `user:delete:user`,`user:delete:user:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// DELETE /users/{userId}
func (c *Client) UserDelete(ctx context.Context, params UserDeleteParams) error {
	_, err := c.sendUserDelete(ctx, params)
	return err
}

func (c *Client) sendUserDelete(ctx context.Context, params UserDeleteParams) (res *UserDeleteNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("userDelete"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/users/{userId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UserDelete",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "encrypted_email" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "encrypted_email",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EncryptedEmail.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "action" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "action",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Action.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "transfer_email" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "transfer_email",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.TransferEmail.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "transfer_meeting" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "transfer_meeting",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.TransferMeeting.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "transfer_webinar" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "transfer_webinar",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.TransferWebinar.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "transfer_recording" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "transfer_recording",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.TransferRecording.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "transfer_whiteboard" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "transfer_whiteboard",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.TransferWhiteboard.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UserDelete", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UserDelete", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUserDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UserEmail invokes userEmail operation.
//
// Verify if a user's email is registered with Zoom.
// &lt;b&gt;Note: &lt;/b&gt;You can successfully check if a user is a registered Zoom user only if
// the user **signed up for Zoom via email and is within your account.** If you provide an email
// address of a user who is not in your account, the value of &quot;existed_email&quot; parameter
// will be &quot;false&quot; irrespective of whether or not the user is registered with Zoom. The
// response of this API call will not include users who joined Zoom using options such as &quot;Sign
// in with SSO&quot;, &quot;Sign in with Google&quot; or &quot;Sign in with Facebook&quot; even if
// they are in the same account as yours.
// **Scopes:** `user:read`,`user:write`,`user:read:admin`,`user:write:admin`
// **Granular Scopes:** `user:read:email`,`user:read:email:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /users/email
func (c *Client) UserEmail(ctx context.Context, params UserEmailParams) (*UserEmailOK, error) {
	res, err := c.sendUserEmail(ctx, params)
	return res, err
}

func (c *Client) sendUserEmail(ctx context.Context, params UserEmailParams) (res *UserEmailOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("userEmail"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/email"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UserEmail",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/users/email"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "email" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "email",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Email))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UserEmail", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UserEmail", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUserEmailResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UserEmailUpdate invokes userEmailUpdate operation.
//
// Change a user's [email address](https://support.zoom.
// us/hc/en-us/articles/201362563-How-Do-I-Change-the-Email-on-My-Account-) on a Zoom account that
// has managed domain set up. For user-level apps, pass [the `me` value](https://developers.zoom.
// us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the `userId` parameter.
// * If the Zoom account in which the user belongs has multiple [managed domains](https://support.
// zoom.us/hc/en-us/articles/203395207-What-is-Managed-Domain-), then the email to be updated
// **must** match one of the managed domains.
// * A user's email address can be changed up to 3 times in any 24 hour period.
// **Prerequisites:**
// * Managed domain must be enabled in the account.
// * The new email address should not already exist in Zoom.
// **Scopes:** `user:write:admin`,`user:write`
// **Granular Scopes:** `user:update:email`,`user:update:email:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// PUT /users/{userId}/email
func (c *Client) UserEmailUpdate(ctx context.Context, request OptUserEmailUpdateReq, params UserEmailUpdateParams) error {
	_, err := c.sendUserEmailUpdate(ctx, request, params)
	return err
}

func (c *Client) sendUserEmailUpdate(ctx context.Context, request OptUserEmailUpdateReq, params UserEmailUpdateParams) (res *UserEmailUpdateNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("userEmailUpdate"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/users/{userId}/email"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UserEmailUpdate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/email"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUserEmailUpdateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UserEmailUpdate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UserEmailUpdate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUserEmailUpdateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UserPassword invokes userPassword operation.
//
// Update the [password](https://support.zoom.
// us/hc/en-us/articles/206344385-Change-a-User-s-Password) of a user using which the user can login
// to Zoom. For user-level apps, pass [the `me` value](https://developers.zoom.
// us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the `userId` parameter.
// After this request is processed successfully, an email notification is sent to the user saying
// that the password was changed.
// **Prerequisites:**
// * Owner or admin of the Zoom account.
// **Scopes:** `user:write:admin`,`user:write`
// **Granular Scopes:** `user:update:password`,`user:update:password:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// PUT /users/{userId}/password
func (c *Client) UserPassword(ctx context.Context, request OptUserPasswordReq, params UserPasswordParams) error {
	_, err := c.sendUserPassword(ctx, request, params)
	return err
}

func (c *Client) sendUserPassword(ctx context.Context, request OptUserPasswordReq, params UserPasswordParams) (res *UserPasswordNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("userPassword"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/users/{userId}/password"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UserPassword",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/password"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUserPasswordRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UserPassword", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UserPassword", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUserPasswordResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UserPermission invokes userPermission operation.
//
// Get permissions that have been granted to the user. For user-level apps, pass [the `me`
// value](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the
// `userId` parameter.
// Users can be assigned a set of permissions that allows them to access only the pages or
// information that a user needs to view or edit.
// **Scopes:** `user:read`,`user:write`,`user:read:admin`,`user:write:admin`,`user_profile`
// **Granular Scopes:** `user:read:list_permissions`,`user:read:list_permissions:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// GET /users/{userId}/permissions
func (c *Client) UserPermission(ctx context.Context, params UserPermissionParams) (*UserPermissionOK, error) {
	res, err := c.sendUserPermission(ctx, params)
	return res, err
}

func (c *Client) sendUserPermission(ctx context.Context, params UserPermissionParams) (res *UserPermissionOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("userPermission"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{userId}/permissions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UserPermission",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/permissions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UserPermission", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UserPermission", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUserPermissionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UserPicture invokes userPicture operation.
//
// Upload a user's profile picture. For user-level apps, pass [the `me` value](https://developers.
// zoom.us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the `userId` parameter.
// Provide `multipart/form-data` as the value of the `content-type` header for this request. This API
// supports `.jpeg` and `.png` file formats.
// **Scopes:** `user:write:admin`,`user:write`
// **Granular Scopes:** `user:write:profile_picture`,`user:write:profile_picture:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// POST /users/{userId}/picture
func (c *Client) UserPicture(ctx context.Context, request OptUserPictureReq, params UserPictureParams) error {
	_, err := c.sendUserPicture(ctx, request, params)
	return err
}

func (c *Client) sendUserPicture(ctx context.Context, request OptUserPictureReq, params UserPictureParams) (res *UserPictureCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("userPicture"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/users/{userId}/picture"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UserPicture",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/picture"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUserPictureRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UserPicture", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UserPicture", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUserPictureResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UserPictureDelete invokes userPictureDelete operation.
//
// Delete a user's profile picture. For user-level apps, pass [the `me` value](https://developers.
// zoom.us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the `userId` parameter.
// **Scopes:** `user:write:admin`,`user:write`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// DELETE /users/{userId}/picture
func (c *Client) UserPictureDelete(ctx context.Context, params UserPictureDeleteParams) error {
	_, err := c.sendUserPictureDelete(ctx, params)
	return err
}

func (c *Client) sendUserPictureDelete(ctx context.Context, params UserPictureDeleteParams) (res *UserPictureDeleteNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("userPictureDelete"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/users/{userId}/picture"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UserPictureDelete",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/picture"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UserPictureDelete", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UserPictureDelete", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUserPictureDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UserSSOTokenDelete invokes userSSOTokenDelete operation.
//
// Revokes a user's SSO token. For user-level apps, pass [the `me` value](https://developers.zoom.
// us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the `userId` parameter.
// After calling this API, the SSO user will be logged out of their current Zoom session.
// **Scopes:** `user:write:admin`,`user:write`
// **Granular Scopes:** `user:delete:token`,`user:delete:token:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// DELETE /users/{userId}/token
func (c *Client) UserSSOTokenDelete(ctx context.Context, params UserSSOTokenDeleteParams) error {
	_, err := c.sendUserSSOTokenDelete(ctx, params)
	return err
}

func (c *Client) sendUserSSOTokenDelete(ctx context.Context, params UserSSOTokenDeleteParams) (res *UserSSOTokenDeleteNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("userSSOTokenDelete"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/users/{userId}/token"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UserSSOTokenDelete",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/token"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UserSSOTokenDelete", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UserSSOTokenDelete", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUserSSOTokenDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UserSchedulerDelete invokes userSchedulerDelete operation.
//
// Delete a scheduler. For user-level apps, pass [the `me` value](https://developers.zoom.
// us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the `userId` parameter.
// Schedulers are users who the current user (assistant) can schedule meetings on their behalf. By
// calling this API, the current user will no longer be a scheduling assistant of this scheduler.
// **Prerequisites:**
// * Current user must be under the same account as the scheduler.
// **Scopes:** `user:write:admin`,`user:write`
// **Granular Scopes:** `user:delete:scheduler`,`user:delete:scheduler:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /users/{userId}/schedulers/{schedulerId}
func (c *Client) UserSchedulerDelete(ctx context.Context, params UserSchedulerDeleteParams) error {
	_, err := c.sendUserSchedulerDelete(ctx, params)
	return err
}

func (c *Client) sendUserSchedulerDelete(ctx context.Context, params UserSchedulerDeleteParams) (res *UserSchedulerDeleteNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("userSchedulerDelete"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/users/{userId}/schedulers/{schedulerId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UserSchedulerDelete",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/schedulers/"
	{
		// Encode "schedulerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "schedulerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SchedulerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UserSchedulerDelete", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UserSchedulerDelete", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUserSchedulerDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UserSchedulers invokes userSchedulers operation.
//
// List all of a user's schedulers. For user-level apps, pass [the `me` value](https://developers.
// zoom.us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the `userId` parameter.
// Schedulers in this context are users who can schedule meetings for the current user. For example,
// if the current user, the user whose `userId` was passed in the `path` parameter, is **User A**,
// this API's response will list all users for whom **User A** can schedule and manage meetings.
// **User A** is the assistant of these users, and thus has scheduling privilege for these users.
// **Prerequisites**
// * Current user must be under the same account as the scheduler.
// **Scopes:** `user:read`,`user:write`,`user:read:admin`,`user:write:admin`,`user_profile`
// **Granular Scopes:** `user:read:list_schedulers`,`user:read:list_schedulers:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Medium`.
//
// GET /users/{userId}/schedulers
func (c *Client) UserSchedulers(ctx context.Context, params UserSchedulersParams) (*UserSchedulersOK, error) {
	res, err := c.sendUserSchedulers(ctx, params)
	return res, err
}

func (c *Client) sendUserSchedulers(ctx context.Context, params UserSchedulersParams) (res *UserSchedulersOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("userSchedulers"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{userId}/schedulers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UserSchedulers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/schedulers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UserSchedulers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UserSchedulers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUserSchedulersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UserSchedulersDelete invokes userSchedulersDelete operation.
//
// Delete all of a user's schedulers. For user-level apps, pass [the `me` value](https://developers.
// zoom.us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the `userId` parameter.
// Schedulers are users on whose behalf the current user (assistant) can schedule meetings for. By
// calling this API, the current user will no longer be a scheduling assistant of any user.
// **Prerequisites:**
// * Current user (assistant) must be under the same account as the scheduler.
// **Scopes:** `user:write:admin`,`user:write`
// **Granular Scopes:** `user:delete:scheduler`,`user:delete:scheduler:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// DELETE /users/{userId}/schedulers
func (c *Client) UserSchedulersDelete(ctx context.Context, params UserSchedulersDeleteParams) error {
	_, err := c.sendUserSchedulersDelete(ctx, params)
	return err
}

func (c *Client) sendUserSchedulersDelete(ctx context.Context, params UserSchedulersDeleteParams) (res *UserSchedulersDeleteNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("userSchedulersDelete"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/users/{userId}/schedulers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UserSchedulersDelete",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/schedulers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UserSchedulersDelete", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UserSchedulersDelete", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUserSchedulersDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UserSettings invokes userSettings operation.
//
// Retrieve a user's settings. For user-level apps, pass [the `me` value](https://developers.zoom.
// us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the `userId` parameter.
// **Scopes:** `user:read`,`user:write`,`user:read:admin`,`user:write:admin`
// **Granular Scopes:** `user:read:settings`,`user:read:settings:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// GET /users/{userId}/settings
func (c *Client) UserSettings(ctx context.Context, params UserSettingsParams) (UserSettingsOK, error) {
	res, err := c.sendUserSettings(ctx, params)
	return res, err
}

func (c *Client) sendUserSettings(ctx context.Context, params UserSettingsParams) (res UserSettingsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("userSettings"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{userId}/settings"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UserSettings",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/settings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "login_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "login_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.LoginType.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "option" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "option",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Option.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "custom_query_fields" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "custom_query_fields",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CustomQueryFields.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UserSettings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UserSettings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUserSettingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UserSettingsUpdate invokes userSettingsUpdate operation.
//
// Updates a user's settings. For user-level apps, pass [the `me` value](https://developers.zoom.
// us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the `userId` parameter.
// **Scopes:** `user:write:admin`,`user:write`
// **Granular Scopes:** `user:update:settings`,`user:update:settings:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// PATCH /users/{userId}/settings
func (c *Client) UserSettingsUpdate(ctx context.Context, request OptUserSettingsUpdateReq, params UserSettingsUpdateParams) error {
	_, err := c.sendUserSettingsUpdate(ctx, request, params)
	return err
}

func (c *Client) sendUserSettingsUpdate(ctx context.Context, request OptUserSettingsUpdateReq, params UserSettingsUpdateParams) (res *UserSettingsUpdateNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("userSettingsUpdate"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/users/{userId}/settings"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UserSettingsUpdate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/settings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "option" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "option",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Option.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUserSettingsUpdateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UserSettingsUpdate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UserSettingsUpdate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUserSettingsUpdateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UserStatus invokes userStatus operation.
//
// [Deactivate](https://support.zoom.
// us/hc/en-us/articles/115005269946-Remove-User-from-your-Account#h_6a9bc1c3-d739-4945-b1f2-00b3b88fb5cc) an active user or to [reactivate](https://support.zoom.us/hc/en-us/articles/115005269946-Remove-User-from-your-Account#h_16319724-d120-4be6-af5d-31582d134ea0) a deactivated user. For user-level apps, pass [the `me` value](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the `userId` parameter.
// An account owner or admins can deactivate as well as activate a user in a Zoom account.
// Deactivating a user removes all licenses associated with a user, and prevents the deactivated user
// from logging into their Zoom account. A deactivated user can be reactivated. Reactivating a user
// grants the user access to log in to their Zoom account.
// **Scopes:** `user:write:admin`,`user:write`
// **Granular Scopes:** `user:update:presence_status`,`user:update:presence_status:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// PUT /users/{userId}/status
func (c *Client) UserStatus(ctx context.Context, request OptUserStatusReq, params UserStatusParams) error {
	_, err := c.sendUserStatus(ctx, request, params)
	return err
}

func (c *Client) sendUserStatus(ctx context.Context, request OptUserStatusReq, params UserStatusParams) (res *UserStatusOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("userStatus"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/users/{userId}/status"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UserStatus",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/status"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUserStatusRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UserStatus", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UserStatus", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUserStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UserSummary invokes userSummary operation.
//
// Gets a summary of users, including the number and types of users in the account.
// **Scopes:** `user:read`,`user:write`,`user:read:admin`,`user:write:admin`
// **Granular Scopes:** `user:read:summary:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// GET /users/summary
func (c *Client) UserSummary(ctx context.Context) (*UserSummaryOK, error) {
	res, err := c.sendUserSummary(ctx)
	return res, err
}

func (c *Client) sendUserSummary(ctx context.Context) (res *UserSummaryOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("userSummary"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/summary"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UserSummary",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/users/summary"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UserSummary", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UserSummary", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUserSummaryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UserToken invokes userToken operation.
//
// Gets a user's Zoom token or Zoom Access Key (ZAK). For user-level apps, pass [the `me`
// value](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the
// `userId` parameter.
// **Scopes:** `user:read`,`user:write`,`user:read:admin`,`user:write:admin`,`user_profile`
// **Granular Scopes:** `user:read:token`,`user:read:token:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// GET /users/{userId}/token
func (c *Client) UserToken(ctx context.Context, params UserTokenParams) (*UserTokenOK, error) {
	res, err := c.sendUserToken(ctx, params)
	return res, err
}

func (c *Client) sendUserToken(ctx context.Context, params UserTokenParams) (res *UserTokenOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("userToken"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{userId}/token"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UserToken",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/token"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "ttl" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "ttl",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.TTL.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UserToken", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UserToken", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUserTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UserUpdate invokes userUpdate operation.
//
// Updates a user's [Zoom profile](https://support.zoom.us/hc/en-us/articles/201363203-My-Profile)
// information.
// For user-level apps, pass [the `me` value](hhttps://developers.zoom.
// us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the `userId` parameter.
// **Scopes:** `user:write:admin`,`user:write`
// **Granular Scopes:** `user:update:user`,`user:update:user:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `LIGHT`.
//
// PATCH /users/{userId}
func (c *Client) UserUpdate(ctx context.Context, request OptUserUpdateReq, params UserUpdateParams) error {
	_, err := c.sendUserUpdate(ctx, request, params)
	return err
}

func (c *Client) sendUserUpdate(ctx context.Context, request OptUserUpdateReq, params UserUpdateParams) (res *UserUpdateNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("userUpdate"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/users/{userId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UserUpdate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "login_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "login_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.LoginType.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "remove_tsp_credentials" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "remove_tsp_credentials",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.RemoveTspCredentials.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUserUpdateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UserUpdate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UserUpdate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUserUpdateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UserVanityName invokes userVanityName operation.
//
// A personal meeting room is a virtual meeting room that can be permanently assigned to a user.
// Use this API to check if a personal meeting room with the given name exists or not.
// **Scopes:** `user:read`,`user:write`,`user:read:admin`,`user:write:admin`
// **Granular Scopes:** `user:read:pm_room`,`user:read:pm_room:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /users/vanity_name
func (c *Client) UserVanityName(ctx context.Context, params UserVanityNameParams) (*UserVanityNameOK, error) {
	res, err := c.sendUserVanityName(ctx, params)
	return res, err
}

func (c *Client) sendUserVanityName(ctx context.Context, params UserVanityNameParams) (res *UserVanityNameOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("userVanityName"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/vanity_name"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UserVanityName",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/users/vanity_name"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "vanity_name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "vanity_name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.VanityName))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UserVanityName", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UserVanityName", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUserVanityNameResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UserZak invokes userZak operation.
//
// Get the Zoom Access Key (ZAK) for the authenticated user associated with the access token in the
// API request. Use a ZAK to start or join a meeting on behalf of this user.
// ZAKs obtained with this endpoint expire five minutes after receipt.
// To get a ZAK for a different user or with a different expiration, use the [Get a user
// token](https://marketplace.zoom.us/docs/api-reference/zoom-api/methods#operation/userToken) API
// with the `zak` `type` query parameter.
// See [Getting a Zoom Access Key (ZAK)](https://developers.zoom.
// us/docs/meeting-sdk/auth/#start-meetings-and-webinars-with-a-zoom-users-zak-token) for details.
// **Scopes:** `user_zak:read`
// **Granular Scopes:** `user:read:zak`,`user:read:zak:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `Light`.
//
// GET /users/me/zak
func (c *Client) UserZak(ctx context.Context) (*UserZakOK, error) {
	res, err := c.sendUserZak(ctx)
	return res, err
}

func (c *Client) sendUserZak(ctx context.Context) (res *UserZakOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("userZak"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/me/zak"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UserZak",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/users/me/zak"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "UserZak", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "UserZak", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUserZakResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// Users invokes users operation.
//
// Retrieve a list your account's users.
// **Scopes:** `user:read`,`user:write`,`user:read:admin`,`user:write:admin`
// **Granular Scopes:** `user:read:list_users:admin`
// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):**
// `MEDIUM`.
//
// GET /users
func (c *Client) Users(ctx context.Context, params UsersParams) (*UsersOK, error) {
	res, err := c.sendUsers(ctx, params)
	return res, err
}

func (c *Client) sendUsers(ctx context.Context, params UsersParams) (res *UsersOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "Users",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/users"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Status.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "role_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "role_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.RoleID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_number" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_number",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include_fields" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_fields",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeFields.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "license" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "license",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.License.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OpenapiAuthorization"
			switch err := c.securityOpenapiAuthorization(ctx, "Users", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiAuthorization\"")
			}
		}
		{
			stage = "Security:OpenapiOAuth"
			switch err := c.securityOpenapiOAuth(ctx, "Users", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenapiOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUsersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
